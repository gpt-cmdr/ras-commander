File: c:\GH\ras-commander\.cursorrules
==================================================
# RAS Commander (ras-commander) Coding Assistant

## Overview

This Assistant helps you write efficient Python code for HEC-RAS projects using the RAS Commander library. It automates tasks, provides a Pythonic interface, supports flexible execution modes, and offers built-in examples.

**Core Concepts:** RAS Objects, Project Initialization, File Handling (pathlib.Path), Data Management (Pandas), Execution Modes, Utility Functions.

## Classes, Functions and Arguments




Certainly! I'll summarize the decorators, provide tables for each class showing the decorators used and arguments, and give a summary of each class's function.

Decorator Summaries:

1. @log_call: Logs function calls, including entry and exit times, and any exceptions raised.
2. @standardize_input: Standardizes input for HDF file operations, handling different input types and ensuring consistent file paths.
3. @hdf_operation: Handles opening and closing of HDF files, and manages error handling for HDF operations.

Now, lets go through each class:


1. RasPrj Class:

| Function Name | @log_call | @standardize_input | @hdf_operation | Arguments |
|---------------|-----------|--------------------|--------------------|-----------|
| initialize | X | | | project_folder, ras_exe_path |
| _load_project_data | X | | | |
| _get_geom_file_for_plan | X | | | plan_number |
| _parse_plan_file | X | | | plan_file_path |
| _get_prj_entries | X | | | entry_type |
| _parse_unsteady_file | X | | | unsteady_file_path |
| check_initialized | X | | | |
| find_ras_prj | X | | | folder_path |
| get_project_name | X | | | |
| get_prj_entries | X | | | entry_type |
| get_plan_entries | X | | | |
| get_flow_entries | X |
1. RasPrj Class:

| Function Name | @log_call | @standardize_input | Arguments |
|---------------|-----------|--------------------|--------------------|
| initialize | X | | project_folder, ras_exe_path |
| _load_project_data | X | | |
| _get_geom_file_for_plan | X | | plan_number |
| _parse_plan_file | X | | plan_file_path |
| _get_prj_entries | X | | entry_type |
| _parse_unsteady_file | X | | unsteady_file_path |
| check_initialized | X | | |
| find_ras_prj | X | | folder_path |
| get_project_name | X | | |
| get_prj_entries | X | | entry_type |
| get_plan_entries | X | | |
| get_flow_entries | X | | |
| get_unsteady_entries | X | | |
| get_geom_entries | X | | |
| get_hdf_entries | X | | |
| print_data | X | | |
| get_plan_value | X | X | plan_number_or_path, key, ras_object |
| get_boundary_conditions | X | | |
| _parse_boundary_condition | X | | block, unsteady_number, bc_number |

2. RasPlan Class:

| Function Name | @log_call | @standardize_input | Arguments |
|---------------|-----------|--------------------|--------------------|
| set_geom | X | | plan_number, new_geom, ras_object |
| set_steady | X | | plan_number, new_steady_flow_number, ras_object |
| set_unsteady | X | | plan_number, new_unsteady_flow_number, ras_object |
| set_num_cores | X | | plan_number, num_cores, ras_object |
| set_geom_preprocessor | X | | file_path, run_htab, use_ib_tables, ras_object |
| get_results_path | X | X | plan_number, ras_object |
| get_plan_path | X | X | plan_number, ras_object |
| get_flow_path | X | X | flow_number, ras_object |
| get_unsteady_path | X | X | unsteady_number, ras_object |
| get_geom_path | X | X | geom_number, ras_object |
| clone_plan | X | | template_plan, new_plan_shortid, ras_object |
| clone_unsteady | X | | template_unsteady, ras_object |
| clone_steady | X | | template_flow, ras_object |
| clone_geom | X | | template_geom, ras_object |
| get_next_number | X | | existing_numbers |
| get_plan_value | X | X | plan_number_or_path, key, ras_object |
| update_plan_value | X | X | plan_number_or_path, key, value, ras_object |

3. RasGeo Class:

| Function Name | @log_call | @standardize_input | Arguments |
|---------------|-----------|--------------------|--------------------|
| clear_geompre_files | X | | plan_files, ras_object |

4. RasUnsteady Class:

| Function Name | @log_call | @standardize_input | Arguments |
|---------------|-----------|--------------------|--------------------|
| update_unsteady_parameters | X | | unsteady_file, modifications, ras_object |

5. RasCmdr Class:

| Function Name | @log_call | @standardize_input | Arguments |
|---------------|-----------|--------------------|--------------------|
| compute_plan | X | | plan_number, dest_folder, ras_object, clear_geompre, num_cores, overwrite_dest |
| compute_parallel | X | | plan_number, max_workers, num_cores, clear_geompre, ras_object, dest_folder, overwrite_dest |
| compute_test_mode | X | | plan_number, dest_folder_suffix, clear_geompre, num_cores, ras_object, overwrite_dest |

6. RasUtils Class:

| Function Name | @log_call | @standardize_input | Arguments |
|---------------|-----------|--------------------|--------------------|
| create_directory | X | | directory_path, ras_object |
| find_files_by_extension | X | | extension, ras_object |
| get_file_size | X | | file_path, ras_object |
| get_file_modification_time | X | | file_path, ras_object |
| get_plan_path | X | | current_plan_number_or_path, ras_object |
| remove_with_retry | X | | path, max_attempts, initial_delay, is_folder, ras_object |
| update_plan_file | X | | plan_number_or_path, file_type, entry_number, ras_object |
| check_file_access | X | | file_path, mode |
| convert_to_dataframe | X | | data_source, **kwargs |
| save_to_excel | X | | dataframe, excel_path, **kwargs |
| calculate_rmse | X | | observed_values, predicted_values, normalized |
| calculate_percent_bias | X | | observed_values, predicted_values, as_percentage |
| calculate_error_metrics | X | | observed_values, predicted_values |
| update_file | X | | file_path, update_function, *args |
| get_next_number | X | | existing_numbers |
| clone_file | X | | template_path, new_path, update_function, *args |
| update_project_file | X | | prj_file, file_type, new_num, ras_object |
| decode_byte_strings | X | | dataframe |
| perform_kdtree_query | X | | reference_points, query_points, max_distance |
| find_nearest_neighbors | X | | points, max_distance |
| consolidate_dataframe | X | | dataframe, group_by, pivot_columns, level, n_dimensional, aggregation_method |
| find_nearest_value | X | | array, target_value |
| horizontal_distance | X | | coord1, coord2 |

7. HdfBase Class:

| Function Name | @log_call | @standardize_input | Arguments |
|---------------|-----------|--------------------|--------------------|
| _get_simulation_start_time | | | hdf_file |
| _get_unsteady_datetimes | | | hdf_file |
| _get_2d_flow_area_names_and_counts | | | hdf_file |
| _parse_ras_datetime | | | datetime_str |
| _parse_ras_simulation_window_datetime | | | datetime_str |
| _parse_duration | | | duration_str |
| _parse_ras_datetime_ms | | | datetime_str |
| _convert_ras_hdf_string | | | value |

8. HdfBndry Class:

| Function Name | @log_call | @standardize_input | Arguments |
|---------------|-----------|--------------------|--------------------|
| bc_lines | | X (plan_hdf) | hdf_path |
| breaklines | | X (plan_hdf) | hdf_path |
| refinement_regions | | X (plan_hdf) | hdf_path |
| reference_lines_names | | X (plan_hdf) | hdf_path, mesh_name |
| reference_points_names | | X (plan_hdf) | hdf_path, mesh_name |
| reference_lines | | X (plan_hdf) | hdf_path |
| reference_points | | X (plan_hdf) | hdf_path |
| get_boundary_attributes | | X (plan_hdf) | hdf_path, boundary_type |
| get_boundary_count | | X (plan_hdf) | hdf_path, boundary_type |
| get_boundary_names | | X (plan_hdf) | hdf_path, boundary_type |

9. HdfMesh Class:

| Function Name | @log_call | @standardize_input | Arguments |
|---------------|-----------|--------------------|--------------------|
| mesh_area_names | | X (plan_hdf) | hdf_path |
| mesh_areas | | X (geom_hdf) | hdf_path |
| mesh_cell_polygons | | X (geom_hdf) | hdf_path |
| mesh_cell_points | | X (plan_hdf) | hdf_path |
| mesh_cell_faces | | X (plan_hdf) | hdf_path |
| get_geom_2d_flow_area_attrs | | X (geom_hdf) | hdf_path |

10. HdfPlan Class:

| Function Name | @log_call | @standardize_input | Arguments |
|---------------|-----------|--------------------|--------------------|
| get_simulation_start_time | X | X (plan_hdf) | hdf_path |
| get_simulation_end_time | X | X (plan_hdf) | hdf_path |
| get_unsteady_datetimes | X | X (plan_hdf) | hdf_path |
| get_plan_info_attrs | X | X (plan_hdf) | hdf_path |
| get_plan_param_attrs | X | X (plan_hdf) | hdf_path |
| get_meteorology_precip_attrs | X | X (plan_hdf) | hdf_path |
| get_geom_attrs | X | X (plan_hdf) | hdf_path |

11. HdfResultsMesh Class:

| Function Name | @log_call | @standardize_input | Arguments |
|---------------|-----------|--------------------|--------------------|
| mesh_summary_output | X | X (plan_hdf) | hdf_path, var, round_to |
| mesh_timeseries_output | X | X (plan_hdf) | hdf_path, mesh_name, var, truncate |
| mesh_faces_timeseries_output | X | X (plan_hdf) | hdf_path, mesh_name |
| mesh_cells_timeseries_output | X | X (plan_hdf) | hdf_path, mesh_names, var, truncate, ras_object |
| mesh_last_iter | X | X (plan_hdf) | hdf_path |
| mesh_max_ws | X | X (plan_hdf) | hdf_path, round_to |
| mesh_min_ws | X | X (plan_hdf) | hdf_path, round_to |
| mesh_max_face_v | X | X (plan_hdf) | hdf_path, round_to |
| mesh_min_face_v | X | X (plan_hdf) | hdf_path, round_to |
| mesh_max_ws_err | X | X (plan_hdf) | hdf_path, round_to |
| mesh_max_iter | X | X (plan_hdf) | hdf_path, round_to |

12. HdfResultsPlan Class:

| Function Name | @log_call | @standardize_input | Arguments |
|---------------|-----------|--------------------|--------------------|
| get_results_unsteady_attrs | X | X (plan_hdf) | hdf_path |
| get_results_unsteady_summary_attrs | X | X (plan_hdf) | hdf_path |
| get_results_volume_accounting_attrs | X | X (plan_hdf) | hdf_path |
| get_runtime_data | | X (plan_hdf) | hdf_path |
| reference_timeseries_output | X | X (plan_hdf) | hdf_path, reftype |
| reference_lines_timeseries_output | X | X (plan_hdf) | hdf_path |
| reference_points_timeseries_output | X | X (plan_hdf) | hdf_path |
| reference_summary_output | X | X (plan_hdf) | hdf_path, reftype |

13. HdfResultsXsec Class:

| Function Name | @log_call | @standardize_input | Arguments |
|---------------|-----------|--------------------|--------------------|
| steady_profile_xs_output | | X (plan_hdf) | hdf_path, var, round_to |
| cross_sections_wsel | | X (plan_hdf) | hdf_path |
| cross_sections_flow | | X (plan_hdf) | hdf_path |
| cross_sections_energy_grade | | X (plan_hdf) | hdf_path |
| cross_sections_additional_enc_station_left | | X (plan_hdf) | hdf_path |
| cross_sections_additional_enc_station_right | | X (plan_hdf) | hdf_path |
| cross_sections_additional_area_total | | X (plan_hdf) | hdf_path |
| cross_sections_additional_velocity_total | | X (plan_hdf) | hdf_path |

14. HdfStruc Class:

| Function Name | @log_call | @standardize_input | Arguments |
|---------------|-----------|--------------------|--------------------|
| structures | X | X (geom_hdf) | hdf_path, datetime_to_str |
| get_geom_structures_attrs | X | X (geom_hdf) | hdf_path |

15. HdfUtils Class:

| Function Name | @log_call | @standardize_input | Arguments |
|---------------|-----------|--------------------|--------------------|
| get_hdf_filename | | X (plan_hdf) | hdf_input, ras_object |
| get_root_attrs | | X (plan_hdf) | hdf_path |
| get_attrs | | X (plan_hdf) | hdf_path, attr_path |
| get_hdf_paths_with_properties | | X (plan_hdf) | hdf_path |
| get_group_attributes_as_df | | X (plan_hdf) | hdf_path, group_path |
| get_2d_flow_area_names_and_counts | | X (plan_hdf) | hdf_path |
| projection | | X (plan_hdf) | hdf_path |

16. HdfXsec Class:

| Function Name | @log_call | @standardize_input | Arguments |
|---------------|-----------|--------------------|--------------------|
| cross_sections | X | X (geom_hdf) | hdf_path, datetime_to_str |
| cross_sections_elevations | X | X (geom_hdf) | hdf_path, round_to |
| river_reaches | X | X (geom_hdf) | hdf_path, datetime_to_str |

17. RasExamples Class:

| Function Name | @log_call | @standardize_input | Arguments |
|---------------|-----------|--------------------|--------------------|
| __init__ | X | | |
| get_example_projects | X | | version_number |
| _load_project_data | X | | |
| _find_zip_file | X | | |
| _extract_folder_structure | X | | |
| _save_to_csv | X | | |
| list_categories | X | | |
| list_projects | X | | category |
| extract_project | X | | project_names |
| is_project_extracted | X | | project_name |
| clean_projects_directory | X | | |
| download_fema_ble_model | X | | huc8, output_dir |
| _make_safe_folder_name | X | | name |
| _download_file_with_progress | X | | url, dest_folder, file_size |
| _convert_size_to_bytes | X | | size_str |

18. RasGpt Class:

This class is mentioned in the code but has no implemented methods yet.

19. Standalone functions:

| Function Name | @log_call | @standardize_input | Arguments |
|---------------|-----------|--------------------|--------------------|
| init_ras_project | X | | ras_project_folder, ras_version, ras_instance |
| get_ras_exe | X | | ras_version |




Overall, the ras-commander library provides a comprehensive set of tools for working with HEC-RAS projects, including project management, file operations, data extraction, and simulation execution. The library makes extensive use of logging and input standardization through decorators, ensuring consistent behavior and traceability across its various components.


## Coding Assistance Rules:

1. Use default libraries, especially pathlib for file operations.
2. Use r-strings for paths, f-strings for formatting.
3. Always use pathlib over os for file/directory operations.
4. Include comments and use logging for output.
5. Follow PEP 8 conventions.
6. Provide clear error handling and user feedback.
7. Explain RAS Commander function purposes and key arguments.
8. Use either global 'ras' object or custom instances consistently.
9. Highlight parallel execution best practices.
10. Suggest RasExamples for testing when appropriate.
11. Utilize RasHdf for HDF file operations and data extraction.
12. Use type hints for function arguments and return values.
13. Apply the @log_call decorator for automatic function logging.
14. Emphasize proper error handling and logging in all functions.
15. When working with RasHdfGeom, always use the @standardize_input decorator for methods that interact with HDF files.
16. Remember that RasHdfGeom methods often return GeoDataFrames, which combine geometric data with attribute information.
17. When dealing with cross-sections or river reaches, consider using the datetime_to_str parameter to convert datetime objects to strings if needed.
18. For methods that accept a mesh_name parameter, remember that they can return either a dictionary of lists or a single list depending on whether a specific mesh is specified.
19. Use 'union_all()' for geodataframes. For pandas >= 2.0, use pd.concat instead of append.
20. Provide full code segments or scripts with no elides.
21. When importing from the Decorators module, use:
    ```python
    from .Decorators import standardize_input, log_call
    ```
22. When importing from the LoggingConfig module, use:
    ```python
    from .LoggingConfig import setup_logging, get_logger
    ```
23. Be aware that while the code will work with capitalized module names (Decorators.py and LoggingConfig.py), it's generally recommended to stick to lowercase names for modules as per PEP 8.
24. When revising code, label planning steps as:
    ## Explicit Planning and Reasoning for Revisions

25. Always consider the implications of file renaming on import statements throughout the project.
26. When working with GeoDataFrames, remember to use appropriate geometric operations and consider spatial relationships.
27. For HDF file operations, always use the standardize_input decorator to ensure consistent handling of file paths.
28. When dealing with large datasets, consider using chunking or iterative processing to manage memory usage.
29. Utilize the RasExamples class for testing and demonstrating functionality with sample projects.
30. When working with the RasGpt class, be aware that it's mentioned but currently has no implemented methods.
==================================================

Folder: c:\GH\ras-commander\.gitignore
==================================================

Folder: c:\GH\ras-commander\examples
==================================================

File: c:\GH\ras-commander\LICENSE
==================================================
MIT License

Copyright (c) 2024 William M. Katzenmeyer

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so.

==================================================

File: c:\GH\ras-commander\pyproject.toml
==================================================
[build-system]
requires = ["setuptools>=45", "wheel"]
build-backend = "setuptools.build_meta:__legacy__"

==================================================

Folder: c:\GH\ras-commander\ras_commander
==================================================

File: c:\GH\ras-commander\requirements.txt
==================================================
aider-chat @ git+https://github.com/paul-gauthier/aider.git@00d5348ee6295662c78a8ece31d71632145d9746
alabaster==0.7.16
annotated-types==0.6.0
anyio==3.7.1
asttokens @ file:///home/conda/feedstock_root/build_artifacts/asttokens_1698341106958/work
attrs==23.1.0
babel==2.16.0
backoff==2.2.1
backports.tarfile==1.2.0
black==24.8.0
boto3==1.35.25
botocore==1.35.25
certifi==2023.11.17
cffi==1.16.0
charset-normalizer==3.3.2
click==8.1.7
colorama==0.4.6
comm @ file:///home/conda/feedstock_root/build_artifacts/comm_1710320294760/work
ConfigArgParse==1.7
contourpy==1.3.0
cycler==0.12.1
debugpy @ file:///D:/bld/debugpy_1725269345345/work
decorator @ file:///home/conda/feedstock_root/build_artifacts/decorator_1641555617451/work
diff-match-patch==20230430
diskcache==5.6.3
distro==1.8.0
docutils==0.20.1
exceptiongroup @ file:///home/conda/feedstock_root/build_artifacts/exceptiongroup_1720869315914/work
executing @ file:///home/conda/feedstock_root/build_artifacts/executing_1725214404607/work
flake8==7.1.1
fonttools==4.53.1
geopandas==1.0.1
gitdb==4.0.11
GitPython==3.1.40
grep-ast==0.2.4
h11==0.14.0
h5py==3.11.0
httpcore==1.0.2
idna==3.6
imagesize==1.4.1
importlib_metadata @ file:///home/conda/feedstock_root/build_artifacts/importlib-metadata_1726082825846/work
iniconfig==2.0.0
ipykernel @ file:///D:/bld/ipykernel_1719845595208/work
ipython @ file:///D:/bld/ipython_1725050320818/work
jaraco.classes==3.4.0
jaraco.context==6.0.1
jaraco.functools==4.1.0
jedi @ file:///home/conda/feedstock_root/build_artifacts/jedi_1696326070614/work
Jinja2==3.1.4
jmespath==1.0.1
jsonschema==4.20.0
jsonschema-specifications==2023.11.2
jupyter_client @ file:///home/conda/feedstock_root/build_artifacts/jupyter_client_1726610684920/work
jupyter_core @ file:///D:/bld/jupyter_core_1710257313664/work
keyring==25.4.1
kiwisolver==1.4.7
markdown-it-py==3.0.0
MarkupSafe==2.1.5
matplotlib==3.9.2
matplotlib-inline @ file:///home/conda/feedstock_root/build_artifacts/matplotlib-inline_1713250518406/work
mccabe==0.7.0
mdurl==0.1.2
more-itertools==10.5.0
mypy-extensions==1.0.0
nest_asyncio @ file:///home/conda/feedstock_root/build_artifacts/nest-asyncio_1705850609492/work
networkx==3.2.1
nh3==0.2.18
numpy==1.26.2
packaging==23.2
pandas==2.2.3
parso @ file:///home/conda/feedstock_root/build_artifacts/parso_1712320355065/work
pathlib==1.0.1
pathspec==0.11.2
pickleshare @ file:///home/conda/feedstock_root/build_artifacts/pickleshare_1602536217715/work
pillow==10.4.0
pkginfo==1.10.0
platformdirs @ file:///home/conda/feedstock_root/build_artifacts/platformdirs_1726613481435/work
pluggy==1.5.0
prompt-toolkit==3.0.41
psutil @ file:///D:/bld/psutil_1725737996000/work
pure_eval @ file:///home/conda/feedstock_root/build_artifacts/pure_eval_1721585709575/work
pycodestyle==2.12.1
pycparser==2.21
pydantic==2.5.2
pydantic_core==2.14.5
pyflakes==3.2.0
Pygments==2.17.2
pyogrio==0.9.0
pyparsing==3.1.4
pyproj==3.6.1
pytest==8.3.3
python-dateutil @ file:///home/conda/feedstock_root/build_artifacts/python-dateutil_1709299778482/work
pytz==2024.2
pywin32==306
pywin32-ctypes==0.2.3
PyYAML==6.0.1
pyzmq @ file:///D:/bld/pyzmq_1725449086441/work
readme_renderer==43.0
referencing==0.31.1
regex==2023.10.3
requests==2.32.3
requests-toolbelt==1.0.0
rfc3986==2.0.0
rich==13.7.0
rpds-py==0.13.2
s3transfer==0.10.2
scipy==1.11.4
shapely==2.0.6
six @ file:///home/conda/feedstock_root/build_artifacts/six_1620240208055/work
smmap==5.0.1
sniffio==1.3.0
snowballstemmer==2.2.0
sounddevice==0.4.6
soundfile==0.12.1
Sphinx==7.4.7
sphinx-rtd-theme==2.0.0
sphinxcontrib-applehelp==2.0.0
sphinxcontrib-devhelp==2.0.0
sphinxcontrib-htmlhelp==2.1.0
sphinxcontrib-jquery==4.1
sphinxcontrib-jsmath==1.0.1
sphinxcontrib-qthelp==2.0.0
sphinxcontrib-serializinghtml==2.0.0
stack-data @ file:///home/conda/feedstock_root/build_artifacts/stack_data_1669632077133/work
tornado @ file:///D:/bld/tornado_1724956185692/work
tqdm==4.66.1
traitlets @ file:///home/conda/feedstock_root/build_artifacts/traitlets_1713535121073/work
tree-sitter==0.20.4
tree-sitter-languages==1.8.0
twine==5.1.1
typing_extensions @ file:///home/conda/feedstock_root/build_artifacts/typing_extensions_1717802530399/work
tzdata==2024.1
urllib3==2.2.3
wcwidth==0.2.12
zipp @ file:///home/conda/feedstock_root/build_artifacts/zipp_1726248574750/work

==================================================

File: c:\GH\ras-commander\setup.py
==================================================
from setuptools import setup, find_packages
from setuptools.command.build_py import build_py
import subprocess
from pathlib import Path

class CustomBuildPy(build_py):
    def run(self):
        # Run the summary_knowledge_bases.py script
        script_path = Path(__file__).parent / 'ai_tools' / 'summary_knowledge_bases.py'
        subprocess.run(['python', str(script_path)], check=True)
        
        # Continue with the regular build process
        super().run()

setup(
    name="ras-commander",
    version="0.44.0",
    packages=["ras_commander"],
    include_package_data=True,
    python_requires='>=3.10',
    author="William M. Katzenmeyer",
    author_email="billk@fenstermaker.com",
    description="A Python library for automating HEC-RAS operations",
    long_description=open('README.md').read(),
    long_description_content_type="text/markdown",
    url="https://github.com/billk-FM/ras-commander",
    cmdclass={
        'build_py': CustomBuildPy,
    },
)

"""
ras-commander setup.py

This file is used to build and publish the ras-commander package to PyPI.

To build and publish this package, follow these steps:

1. Ensure you have the latest versions of setuptools, wheel, and twine installed:
   pip install --upgrade setuptools wheel twine

2. Update the version number in ras_commander/__init__.py (if not using automatic versioning)

3. Create source distribution and wheel:
   python setup.py sdist bdist_wheel

4. Check the distribution:
   twine check dist/*

5. Upload to Test PyPI (optional):
   twine upload --repository testpypi dist/*

6. Install from Test PyPI to verify (optional):
   pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple ras-commander

7. Upload to PyPI:
   twine upload dist/* --username __token__ --password <your_api_key>


8. Install from PyPI to verify:
   pip install ras-commander

Note: Ensure you have the necessary credentials and access rights to upload to PyPI.
For more information, visit: https://packaging.python.org/tutorials/packaging-projects/

"""

==================================================

File: c:\GH\ras-commander\.gitignore\.gitignore
==================================================
# Ignore the example_projects folder and all its subfolders
examples/example_projects/

# Ignore workspace, projects, and my_projects folders
workspace/
projects/
my_projects/

# Ignore FEMA BLE Models
examples/FEMA_BLE_Models/
examples/hdf_example_data/


# Ignore library assistant config
library_assistant/config/

# Ignore Python egg info
*.egg-info/
.eggs/

# Ignore the Example_Projects_6_5.zip file
Example_Projects_6_5.zip

# Ignore the misc folder and all its subfolders
misc/

# Ignore Python cache files
__pycache__/
*.py[cod]

# Ignore compiled Python files
*.so

# Ignore distribution / packaging
dist/
build/

# Ignore test cache
.pytest_cache/

# Ignore virtual environments
.venv/
venv/

# Ignore IDE-specific files (optional, uncomment if needed)
# .vscode/
# .idea/

# Ignore OS-specific files
.DS_Store
Thumbs.db
==================================================

File: c:\GH\ras-commander\examples\01_project_initialization.py
==================================================
# 01_project_initialization.py

#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek", "BaldEagleCrkMulti2D", "Muncie"])

#### --- START OF SCRIPT --- ####

# RAS Commander Library Notes:
# 1. This example demonstrates both the default global 'ras' object and custom ras objects.
# 2. The global 'ras' object is suitable for simple scripts working with a single project.
# 3. Custom ras objects are recommended for complex scripts or when working with multiple projects.
# 4. The init_ras_project function initializes a project and sets up the ras object.
# 5. Each ras object contains comprehensive information about its project, including plan, geometry, flow files, and boundary conditions.

# Best Practices:
# 1. For simple scripts working with a single project, using the global 'ras' object is fine.
# 2. For complex scripts or when working with multiple projects, create and use separate ras objects.
# 3. Be consistent in your approach: don't mix global and non-global ras object usage in the same script.
# 4. Use descriptive names for custom ras objects to clearly identify different projects.

def print_ras_object_data(ras_obj, project_name):
    print(f"\n{project_name} Project Data:")
    print("=" * 50)
    print(f"Project Name: {ras_obj.get_project_name()}")
    print(f"Project Folder: {ras_obj.project_folder}")
    print(f"PRJ File: {ras_obj.prj_file}")
    print(f"HEC-RAS Executable Path: {ras_obj.ras_exe_path}")
    
    print("\nPlan Files DataFrame:")
    print(ras_obj.plan_df)
    
    print("\nFlow Files DataFrame:")
    print(ras_obj.flow_df)
    
    print("\nUnsteady Flow Files DataFrame:")
    print(ras_obj.unsteady_df)
    
    print("\nGeometry Files DataFrame:")
    print(ras_obj.geom_df)
    
    print("\nHDF Entries DataFrame:")
    print(ras_obj.get_hdf_entries())
    
    print("\nBoundary Conditions DataFrame:")
    print(ras_obj.get_boundary_conditions())
    
    print("\nMeteorological Data:")
    for attr in ['precipitation_mode', 'wind_mode', 'precipitation_metadata', 'evapotranspiration_metadata']:
        if hasattr(ras_obj, attr):
            print(f"{attr.capitalize().replace('_', ' ')}: {getattr(ras_obj, attr)}")
        else:
            print(f"{attr.capitalize().replace('_', ' ')}: Not available")

def main():
    # Get the current script's directory
    current_dir = Path(__file__).parent
    
    # Define paths to example projects
    bald_eagle_path = current_dir.parent / "examples" / "example_projects" / "Balde Eagle Creek"
    multi_2d_path = current_dir.parent / "examples" / "example_projects" / "BaldEagleCrkMulti2D"
    muncie_path = current_dir.parent / "examples" / "example_projects" / "Muncie"

    print("Example Set 1: Using the default global 'ras' object")
    print("-----------------------------------------------------")

    # Initialize using the global RAS instance
    print("Step 1: Initializing with global RAS instance")
    init_ras_project(bald_eagle_path, "6.5") # This will set the global 'ras' object
    print_ras_object_data(ras, "Global RAS Instance (Bald Eagle Creek)")

    print("\nExample Set 2: Using custom ras objects")
    print("-----------------------------------------------------")

    # Initialize multiple project instances
    print("Step 1: Initializing multiple project instances")
    multi_2d_project = init_ras_project(multi_2d_path, "6.5")
    muncie_project = init_ras_project(muncie_path, "6.5")

    print_ras_object_data(multi_2d_project, "Multi2D Project")
    print_ras_object_data(muncie_project, "Muncie Project")

    print("\nExample of simplified import (not recommended for complex scripts)")
    print("-----------------------------------------------------")
    print("from ras_commander import *")
    print("# This allows you to use all functions and classes without prefixes")
    print("# For example: compute_plan() instead of RasCmdr.compute_plan()")
    print("# Note: This approach can lead to naming conflicts and is generally not recommended for larger scripts")

if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\02_plan_operations.py
==================================================
# 02_plan_operations.py

#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek"])

#### --- START OF SCRIPT --- ####

"""
This script demonstrates the process of initializing a HEC-RAS project and performing various operations on plans, geometries, and unsteady flows using the functions within the RasPlan Class.

Process Flow:
1. Project Initialization: Initialize a HEC-RAS project by specifying the project path and version.
2. Plan Cloning: Clone an existing plan, creating a new plan entry.
3. Geometry Cloning: Clone a geometry associated with the original plan, generating a new geometry entry.
4. Unsteady Flow Cloning: Clone an unsteady flow, creating a new unsteady flow entry.
5. Plan Configuration:
   a. Set the cloned geometry for the new plan.
   b. Set the cloned unsteady flow for the new plan.
   c. Update the number of cores to be used for the new plan.
   d. Configure geometry preprocessor options for the new plan.
6. Plan Computation: Compute the new plan and verify successful execution.
7. Results Verification: Check the HDF entries to confirm that results were written.

Additional operations that could be demonstrated:
8. Plan Modification: Update specific parameters in the plan file (e.g., simulation time, output intervals).
9. Geometry Editing: Modify cross-sections, manning's n values, or other geometry data.
10. Unsteady Flow Modification: Adjust boundary conditions or initial conditions.
11. Batch Operations: Perform operations on multiple plans simultaneously.
12. Error Handling: Demonstrate how to handle and report errors during plan operations.
13. Results Analysis: Extract and analyze key output values from the computed plan.
"""

# RAS Commander Library Notes:
# 1. This example uses the default global 'ras' object for simplicity.
# 2. If you need to work with multiple projects, use separate ras objects for each project.
# 3. Once you start using non-global ras objects, stick with that approach throughout your script.

# Best Practices:
# 1. For simple scripts working with a single project, using the global 'ras' object is fine.
# 2. For complex scripts or when working with multiple projects, create and use separate ras objects.
# 3. Be consistent in your approach: don't mix global and non-global ras object usage in the same script.

def main():
    # Initialize the project
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Balde Eagle Creek"
    init_ras_project(project_path, "6.6")

    print("Initial plan files:")
    print(ras.plan_df)
    print()

    # Step 1: Clone a plan
    print("Step 1: Cloning a plan")
    new_plan_number = RasPlan.clone_plan("01")
    print(f"New plan created: {new_plan_number}")
    print("Updated plan files:")
    print(ras.plan_df)
    print()
    
    # Step 2: Clone a geometry
    print("Step 2: Cloning a geometry")
    new_geo_number = RasPlan.clone_geom("01")
    print(f"New geometry created: {new_geo_number}")
    print("Updated geometry files:")
    print(ras.geom_df)
    print()
    
    # Step 3: Clone an unsteady flow
    print("Step 3: Cloning an unsteady flow")
    new_unsteady_number = RasPlan.clone_unsteady("02")
    print(f"New unsteady flow created: {new_unsteady_number}")
    print("Updated unsteady flow files:")
    print(ras.unsteady_df)
    print()

    # Step 4: Set geometry for the cloned plan
    print("Step 4: Setting geometry for a plan")
    RasPlan.set_geom(new_plan_number, new_geo_number)
    plan_path = RasPlan.get_plan_path(new_plan_number)
    print(f"Updated geometry for plan {new_plan_number}")
    print(f"Plan file path: {plan_path}")
    print()

    # Step 5: Set unsteady flow for the cloned plan
    print("Step 5: Setting unsteady flow for a plan")
    RasPlan.set_unsteady(new_plan_number, new_unsteady_number)
    print(f"Updated unsteady flow for plan {new_plan_number}")
    print()

    # Step 6: Set the number of cores for the cloned plan
    print("Step 6: Setting the number of cores for a plan")
    RasPlan.set_num_cores(new_plan_number, 2)
    print(f"Updated number of cores for plan {new_plan_number}")
    print()

    # Step 7: Set geometry preprocessor options for the cloned plan
    print("Step 7: Setting geometry preprocessor options")
    RasPlan.set_geom_preprocessor(plan_path, run_htab=-1, use_ib_tables=-1)
    print(f"Updated geometry preprocessor options for plan {new_plan_number}")
    
    # Step 8: Compute the cloned plan
    print("Step 8: Computing the cloned plan")
    success = RasCmdr.compute_plan(new_plan_number)
    print(f"Computing plan {new_plan_number}")
    if success:
        print(f"Plan {new_plan_number} computed successfully")
    else:
        print(f"Failed to compute plan {new_plan_number}")
    print()
    
    # Step 9: Get the HDF entries for the cloned plan to prove that the results were written
    print("Step 9: Retrieving HDF entries for the cloned plan")
    # Refresh the plan entries to ensure we have the latest data
    ras.plan_df = ras.get_plan_entries()
    hdf_entries = ras.get_hdf_entries()
    if not hdf_entries.empty:
        print("HDF entries for the cloned plan:")
        print(hdf_entries)
    else:
        print("No HDF entries found. This could mean the plan hasn't been computed successfully or the results haven't been written yet.")
    
    # Display the plan entries to see if the HDF path is populated
    print("\nCurrent plan entries:")
    print(ras.plan_df)
    
if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\03_geometry_operations.py
==================================================
# 03_geometry_operations.py

#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Muncie"])

#### --- START OF SCRIPT --- ####

# RAS Commander Library Notes:
# 1. This example uses the default global 'ras' object for simplicity.
# 2. If you need to work with multiple projects, use separate ras objects for each project.
# 3. Once you start using non-global ras objects, stick with that approach throughout your script.
# 4. The RasGeo class provides methods for working with geometry files and preprocessor operations.

# Best Practices:
# 1. For simple scripts working with a single project, using the global 'ras' object is fine.
# 2. For complex scripts or when working with multiple projects, create and use separate ras objects.
# 3. Be consistent in your approach: don't mix global and non-global ras object usage in the same script.
# 4. Always clear geometry preprocessor files before making significant changes to ensure clean results.

def main():
    # Initialize the project
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Muncie"
    init_ras_project(project_path, "6.6")

    print("Initial plan files:")
    print(ras.plan_df)
    print()

    # Step 1: Clone a plan
    print("Step 1: Cloning a plan")
    new_plan_number = RasPlan.clone_plan("01")
    print(f"New plan created: {new_plan_number}")
    print("Updated plan files:")
    print(ras.plan_df)
    print()

    # Step 2: Clone a geometry file and assign it to the cloned plan
    print("Step 2: Cloning a geometry file and assigning it to the cloned plan")
    new_geom_number = RasPlan.clone_geom("01")
    print(f"New geometry created: {new_geom_number}")
    print(f"Now set the new geometry to the new plan")
    RasPlan.set_geom(new_plan_number, new_geom_number)
    print(f"New geometry {new_geom_number} assigned to plan {new_plan_number}")
    print("Updated geometry files:")
    print(ras.geom_df)
    print()

    # Step 3: Clear geometry preprocessor files for the cloned plan
    print("Step 3: Clearing geometry preprocessor files for the cloned plan")
    plan_path = RasPlan.get_plan_path(new_plan_number)
    RasGeo.clear_geompre_files(plan_path)
    print(f"Cleared geometry preprocessor files for plan {new_plan_number}")
    print()

    # Step 4: Clear geometry preprocessor files for all plans
    print("Step 4: Clearing geometry preprocessor files for all plans")
    RasGeo.clear_geompre_files()
    print("Cleared geometry preprocessor files for all plans")
    print()

    # Step 5: Print the updated plan information
    print("Step 5: Updated plan information")
    plan_df = ras.get_plan_entries()
    print(plan_df)
    print()

    # Step 6: Compute the cloned plan with new geometry and core count
    print("Step 6: Computing the cloned plan")
    success = RasCmdr.compute_plan(new_plan_number)
    print(f"Computing plan {new_plan_number}")
    if success:
        print(f"Plan {new_plan_number} computed successfully")
    else:
        print(f"Failed to compute plan {new_plan_number}")
        
    # Step 7: Get and print results paths
    print("\nStep 7: Getting results paths")
    for plan_number in [new_plan_number, "01"]:  # Check both the new plan and the original plan
        results_path = RasPlan.get_results_path(plan_number)
        if results_path:
            print(f"Results for plan {plan_number} are located at: {results_path}")
        else:
            print(f"No results found for plan {plan_number}")
        

if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\04_unsteady_flow_operations.py
==================================================
# 04_unsteady_flow_operations.py

#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek"])

#### --- START OF SCRIPT --- ####

"""
This script demonstrates the process of initializing a HEC-RAS project and performing various operations on unsteady flow plans using the ras-commander library.

Process Flow:
1. Project Initialization: Initialize a HEC-RAS project by specifying the project path and version.
2. Plan Cloning: Clone an existing plan, creating a new plan entry.
3. Unsteady Flow Parameter Updates: Modify various unsteady flow parameters in the new plan.
4. Plan Computation: Compute the new plan and verify successful execution.

Note: This example uses the default global 'ras' object for simplicity. For complex scripts or when working with
multiple projects, it's recommended to create and use separate ras objects.
"""

def main():
    # Initialize the project using the global 'ras' object
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Balde Eagle Creek"
    init_ras_project(project_path, "6.6")

    print("Initial plan files:")
    print(ras.plan_df)
    print()

    # Step 1: Clone a plan
    print("Step 1: Cloning a plan")
    new_plan_number = RasPlan.clone_plan("01")
    print(f"New plan created: {new_plan_number}")
    print("Updated plan files:")
    print(ras.plan_df)
    print()

    # Step 2: Get the plan file path
    plan_path = RasPlan.get_plan_path(new_plan_number)

    # Step 3: Update unsteady flow parameters individually
    print("Step 3: Updating unsteady flow parameters individually")
    RasUnsteady.update_unsteady_parameters(plan_path, {"Simulation Date": "01JAN2023,0000,05JAN2023,2400"})
    RasUnsteady.update_unsteady_parameters(plan_path, {"Computation Interval": "1MIN"})
    RasUnsteady.update_unsteady_parameters(plan_path, {"Output Interval": "15MIN"})
    print("Updated parameters individually")
    print()

    # Step 4: Update unsteady flow parameters in batch
    print("Step 4: Updating unsteady flow parameters in batch")
    batch_modifications = {
        "Mapping Interval": "30MIN",
        "Hydrograph Output Interval": "1HOUR",
        "Detailed Output Interval": "1HOUR"
    }
    RasUnsteady.update_unsteady_parameters(plan_path, batch_modifications)
    print("Updated parameters in batch")
    print()

    # Step 5: Verify changes
    print("Step 5: Verifying changes")
    with open(plan_path, 'r') as f:
        content = f.read()
        for param in ["Simulation Date", "Computation Interval", "Output Interval", 
                      "Mapping Interval", "Hydrograph Output Interval", "Detailed Output Interval"]:
            for line in content.split('\n'):
                if line.startswith(param):
                    print(f"Updated {line}")
                    break
    print()

    # Step 6: Compute the updated plan
    print("Step 6: Computing the updated plan")
    success = RasCmdr.compute_plan(new_plan_number)
    if success:
        print(f"Plan {new_plan_number} computed successfully")
    else:
        print(f"Failed to compute plan {new_plan_number}")

if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\05_utility_functions.py
==================================================
# 05_utility_functions.py

#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek"])

#### --- START OF SCRIPT --- ####

# RAS Commander (ras-commander) Library Notes:
# 1. This example uses the default global 'ras' object for simplicity.
# 2. If you need to work with multiple projects, use separate ras objects for each project.
# 3. Once you start using non-global ras objects, stick with that approach throughout your script.
# 4. The RasUtils class provides various utility functions for working with HEC-RAS projects.

# Best Practices:
# 1. For simple scripts working with a single project, using the global 'ras' object is fine.
# 2. For complex scripts or when working with multiple projects, create and use separate ras objects.
# 3. Be consistent in your approach: don't mix global and non-global ras object usage in the same script.

def main():
    # Initialize the project
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Balde Eagle Creek"
    init_ras_project(project_path, "6.6")
    plan_number = "01"

    # Example 1: Get plan path using RasUtils
    print("Example 1: Getting plan path")
    plan_path = RasUtils.get_plan_path(plan_number)
    print(f"Path for plan {plan_number} is: {plan_path}")
    
    # Example 2: Get geometry path using RasPlan
    print("\nExample 2: Getting geometry path")
    geom_number = "01"
    geom_path = RasPlan.get_geom_path(geom_number)
    print(f"Path for geometry {geom_number} is: {geom_path}")
    
    # Example 3: Get unsteady flow path using RasPlan
    print("\nExample 3: Getting unsteady flow path")
    unsteady_number = "01"
    unsteady_path = RasPlan.get_unsteady_path(unsteady_number)
    print(f"Path for unsteady flow {unsteady_number} is: {unsteady_path}")
    
    # Example 4: Get project name
    print("\nExample 4: Getting project name")
    project_name = ras.get_project_name()
    print(f"Project name: {project_name}")


if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\06_single_plan_execution.py
==================================================
#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Define the "example_projects" folder in the same directory as the script
examples_path = Path(__file__).parent / "example_projects"

# Delete the project if it exists
if examples_path.exists():
    import shutil
    shutil.rmtree(examples_path)

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek"])

#### --- START OF SCRIPT --- ####

# ras-commander Library Notes:
# 1. This example uses the default global 'ras' object for simplicity.
# 2. If you need to work with multiple projects, use separate ras objects for each project.
# 3. Once you start using non-global ras objects, stick with that approach throughout your script.

# Best Practices:
# 1. For simple scripts working with a single project, using the global 'ras' object is fine.
# 2. For complex scripts or when working with multiple projects, create and use separate ras objects.
# 3. Be consistent in your approach: don't mix global and non-global ras object usage in the same script.

def main():
    # Initialize the project using the global 'ras' object
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Balde Eagle Creek"
    init_ras_project(project_path, "6.6")

    print("Available plans:")
    print(ras.plan_df)
    print()

    # Example 1: Execute a single plan
    print("Example 1: Executing a single plan")
    plan_number = "01"
    success = RasCmdr.compute_plan(plan_number)
    if success:
        print(f"Plan {plan_number} executed successfully")
    else:
        print(f"Plan {plan_number} execution failed")
    print()
    

    # Example 2: Execute a plan in a separate destination folder
    print("Example 2: Executing a plan in a separate destination folder")
    plan_number = "02"
    dest_folder = project_path.parent / "compute_test_2"
    success = RasCmdr.compute_plan(plan_number, dest_folder=dest_folder)
    if success:
        print(f"Plan {plan_number} executed successfully in {dest_folder}")
    else:
        print(f"Plan {plan_number} execution failed in {dest_folder}")
    print()

    # Example 3: Get and print results path
    print("Example 3: Getting results path")
    results_path = RasPlan.get_results_path(plan_number)
    if results_path:
        print(f"Results for plan {plan_number} are located at: {results_path}")
    else:
        print(f"No results found for plan {plan_number}")
    print()    

    # Example 4: Execute a plan with cleared geometry preprocessor files
    print("Example 4: Executing a plan with cleared geometry preprocessor files")
    plan_number = "03"
    dest_folder = project_path.parent / "compute_test_3"
    success = RasCmdr.compute_plan(plan_number, dest_folder=dest_folder, clear_geompre=True)
    if success:
        print(f"Plan {plan_number} executed successfully with cleared geometry preprocessor files")
    else:
        print(f"Plan {plan_number} execution failed")
    print()
    

    # Example 5: Execute a plan with a specified number of cores, overwriting compute_test_3
    print("Example 5: Executing a plan with a specified number of cores, overwriting compute_test_3")
    plan_number = "01"
    num_cores = 2  # Specify the number of cores to use
    success = RasCmdr.compute_plan(plan_number, dest_folder=dest_folder, num_cores=num_cores, overwrite_dest=True)
    if success:
        print(f"Plan {plan_number} executed successfully using {num_cores} cores")
    else:
        print(f"Plan {plan_number} execution failed")
    print()
    

    # Example 6: Execute a plan with all new options combined
    print("Example 6: Executing a plan with all new options combined")
    plan_number = "02"
    dest_folder = project_path.parent / "compute_test_all_options"
    num_cores = 4
    
    success = RasCmdr.compute_plan(
        plan_number,
        dest_folder=dest_folder,
        clear_geompre=True,
        num_cores=num_cores
    )
    if success:
        print(f"Plan {plan_number} executed successfully with all options:")
        print(f"- Destination folder: {dest_folder}")
        print(f"- Cleared geometry preprocessor files")
        print(f"- Used {num_cores} cores")
    else:
        print(f"Plan {plan_number} execution failed")

if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\07_sequential_plan_execution.py
==================================================
#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Housekeeping Note: 
# For all of the functions that do batched execution (sequential or parallel), they are careful not to overwrite existing folders
# So if you want your script to be repeatable, you need to make sure you delete the folders before running again.
# Otherwise an error will be raised to prevent overwriting any results from your previous runs.
# This will not be done by the example projects routines, which only overwrite the source folder for repeatability. 
    
import shutil
from pathlib import Path
# Define the keys to search for in folder names
# Delete example projects folder
current_file = Path(__file__).resolve()
current_dir = current_file.parent
delete_folder_path = current_dir / "example_projects"

if delete_folder_path.exists():
    print(f"Removing existing folder: {delete_folder_path}")
    shutil.rmtree(delete_folder_path)
else:
    print(f"Folder not found: {delete_folder_path}")

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek"])

#### --- START OF SCRIPT --- ####

# ras-commander Library Notes:
# 1. This example uses the default global 'ras' object for simplicity.
# 2. If you need to work with multiple projects, use separate ras objects for each project.
# 3. Once you start using non-global ras objects, stick with that approach throughout your script.

# Best Practices:
# 1. For simple scripts working with a single project, using the global 'ras' object is fine.
# 2. For complex scripts or when working with multiple projects, create and use separate ras objects.
# 3. Be consistent in your approach: don't mix global and non-global ras object usage in the same script.
# 4. For functions that do batched execution (sequential or parallel), they are careful not to overwrite existing folders.
# 5. If you want your script to be repeatable, make sure to delete the folders before running again.

def main():
    # Initialize the project using the global 'ras' object
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Balde Eagle Creek"
    init_ras_project(project_path, "6.6")

    print("Available plans:")
    print(ras.plan_df)
    print()

    # Example 1: Sequential execution of all plans with overwrite_dest
    print("Example 1: Sequential execution of all plans with overwrite_dest")
    RasCmdr.compute_test_mode(
        dest_folder_suffix="[AllSequential]",
        overwrite_dest=True
    )
    print("Sequential execution of all plans completed with overwrite_dest")
    print()
    
    # Example 2: Sequential execution of specific plans with clearing geompre files and overwrite_dest
    print("Example 2: Sequential execution of specific plans with clearing geompre files and overwrite_dest")
    RasCmdr.compute_test_mode(
        plan_number=["01", "02"],
        dest_folder_suffix="[SpecificSequentialClearGeompre]",
        clear_geompre=True,
        overwrite_dest=True
    )
    print("Sequential execution of specific plans completed with clearing geompre files and overwrite_dest")
    print()

    # Example 3: Demonstrate clearing geompre files for specific plans
    print("Example 3: Clearing geompre files for specific plans")
    plan_files = [RasPlan.get_plan_path("01"), RasPlan.get_plan_path("02")]
    RasGeo.clear_geompre_files(plan_files)
    print("Geometry preprocessor files cleared for specific plans")
    print()

    # Example 4: Demonstrate clearing all geompre files
    print("Example 4: Clearing all geompre files")
    RasGeo.clear_geompre_files()
    print("All geometry preprocessor files cleared")

if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\08_parallel_execution.py
==================================================
#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path
import shutil
import psutil
import math

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, RasPrj
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, RasPrj

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek"])

#### --- START OF SCRIPT --- ####

# ras-commander Library Notes:
# 1. This example uses separate RasPrj objects for each project/folder.
# 2. Using separate RasPrj objects allows working with multiple projects or folders.
# 3. We'll create new RasPrj objects for the original project and each output folder.
# 4. For functions that do batched execution (sequential or parallel), they are careful not to overwrite existing folders.
# 5. If you want your script to be repeatable, make sure to delete the folders before running again.

# Best Practices:
# 1. For complex scripts or when working with multiple projects/folders, create and use separate RasPrj objects.
# 2. Be consistent in your approach: use non-global RasPrj objects throughout the script.
# 3. When using parallel execution, consider the number of cores available on your machine.
# 4. Use the dest_folder argument to keep your project folder clean and organized.

def get_physical_core_count():
    return psutil.cpu_count(logical=False)

def main():
    # Initialize the project using a new RasPrj object
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Balde Eagle Creek"
    source_project = init_ras_project(project_path, "6.6")

    print("Available plans:")
    print(source_project.plan_df)
    print()

    # Example 1: Parallel execution of all plans with overwrite_dest
    print("Example 1: Parallel execution of all plans with overwrite_dest")
    compute_folder = project_path.parent / "compute_test_parallel"
    results_all = RasCmdr.compute_parallel(
        max_workers=3,
        num_cores=2,
        dest_folder=compute_folder,
        overwrite_dest=True,
        ras_object=source_project
    )
    print("Parallel execution of all plans results:")
    for plan_number, success in results_all.items():
        print(f"Plan {plan_number}: {'Successful' if success else 'Failed'}")
    print()
    
    # Initialize a new RasPrj object for the compute_folder
    compute_source_project = init_ras_project(compute_folder, "6.6")
    print("Plan DataFrame after parallel execution of all plans:")
    print(compute_source_project.plan_df)
    print()

    # Example 2: Parallel execution of specific plans with overwrite_dest
    print("Example 2: Parallel execution of specific plans with overwrite_dest")
    specific_plans = ["01", "02"]
    specific_compute_folder = project_path.parent / "compute_test_parallel_specific"
    results_specific = RasCmdr.compute_parallel(
        plan_number=specific_plans,
        max_workers=2,
        num_cores=2,
        dest_folder=specific_compute_folder,
        overwrite_dest=True,
        ras_object=source_project
    )
    print("Parallel execution of specific plans results:")
    for plan_number, success in results_specific.items():
        print(f"Plan {plan_number}: {'Successful' if success else 'Failed'}")
    print()

    # Example 3: Parallel execution with dynamic max_workers based on physical cores
    print("Example 3: Parallel execution with dynamic max_workers")
    num_cores = 2
    physical_cores = get_physical_core_count()
    max_workers = math.floor(physical_cores / num_cores)
    
    dynamic_compute_folder = project_path.parent / "compute_test_parallel_dynamic"
    results_dynamic = RasCmdr.compute_parallel(
        max_workers=max_workers,
        num_cores=num_cores,
        dest_folder=dynamic_compute_folder,
        overwrite_dest=True,
        ras_object=source_project
    )
    print(f"Parallel execution with {max_workers} workers and {num_cores} cores per worker:")
    for plan_number, success in results_dynamic.items():
        print(f"Plan {plan_number}: {'Successful' if success else 'Failed'}")
    print()

    # Get and print results paths
    print("Results paths for dynamic execution:")
    dynamic_compute_source_project = init_ras_project(dynamic_compute_folder, "6.6")
    print(dynamic_compute_source_project.plan_df)

if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\09_specifying_plans.py
==================================================
#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Housekeeping Note: 
# For all of the functions that do batched execution (sequential or parallel), they are careful not to overwrite existing folders
# So if you want your script to be repeatable, you need to make sure you delete the folders before running again.
# Otherwise an error will be raised to prevent overwriting any results from your previous runs.
# This will not be done by the example projects routines, which only overwrite the source folder for repeatability. 
    
import shutil
from pathlib import Path

# Delete example projects folder
current_file = Path(__file__).resolve()
current_dir = current_file.parent
delete_folder_path = current_dir / "example_projects"

if delete_folder_path.exists():
    print(f"Removing existing folder: {delete_folder_path}")
    shutil.rmtree(delete_folder_path)
else:
    print(f"Folder not found: {delete_folder_path}")

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek"])

#### --- START OF SCRIPT --- ####

# RAS Commander (ras-commander) Library Notes:
# 1. This example uses the default global 'ras' object for simplicity.
# 2. If you need to work with multiple projects, use separate ras objects for each project.
# 3. Once you start using non-global ras objects, stick with that approach throughout your script.
# 4. The RasCmdr class provides methods for executing plans in various ways.
# 5. You can specify individual plans or lists of plans for batch operations.

# Best Practices:
# 1. For simple scripts working with a single project, using the global 'ras' object is fine.
# 2. For complex scripts or when working with multiple projects, create and use separate ras objects.
# 3. Be consistent in your approach: don't mix global and non-global ras object usage in the same script.
# 4. When specifying plans, use plan numbers as strings (e.g., "01", "02") for consistency.
# 5. Always check the available plans in the project before specifying plan numbers for execution.

def main():
    # Initialize the project
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Balde Eagle Creek"
    init_ras_project(project_path, "6.6")

    print("Available plans:")
    print(ras.plan_df)
    print()

    # Example 1: Sequential execution of specific plans
    print("Example 1: Sequential execution of specific plans (1 and 3)")
    RasCmdr.compute_test_mode(plan_number=["01", "03"], dest_folder_suffix="[SpecificSequential]", num_cores=6)
    print("Sequential execution of specific plans completed")
    print()

    # Example 2: Parallel execution of specific plans
    print("Example 2: Parallel execution of specific plans")
    results_specific = RasCmdr.compute_parallel(
        plan_number=["01", "02"],
        max_workers=2,
        num_cores=2
    )
    print("Parallel execution of specific plans results:")
    for plan_number, success in results_specific.items():
        print(f"Plan {plan_number}: {'Successful' if success else 'Failed'}")
    print()

    # Example 3: Execute all plans
    print("Example 3: Execute all plans")
    all_plan_numbers = ras.plan_df['plan_number'].tolist()
    RasCmdr.compute_test_mode(plan_number=all_plan_numbers, dest_folder_suffix="[AllPlans]")
    print("Execution of all plans completed")
    print()

if __name__ == "__main__":
    main()

==================================================

File: c:\GH\ras-commander\examples\10_arguments_for_compute.py
==================================================
#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek"])

#### --- START OF SCRIPT --- ####

# RAS Commander Library Notes:
# 1. This example uses the default global 'ras' object for simplicity.
# 2. If you need to work with multiple projects, use separate ras objects for each project.
# 3. Once you start using non-global ras objects, stick with that approach throughout your script.
# 4. The RasCmdr class provides various arguments for fine-tuning plan computation:
#    - plan_number: String representing the plan number to compute (e.g., "01")
#    - dest_folder: Path object specifying the destination folder for computation results
#    - clear_geompre: Boolean to clear geometry preprocessor files before computation
#    - num_cores: Integer specifying the number of cores to use
#    - overwrite_dest: Boolean to determine if existing destination folders should be overwritten

# Best Practices:
# 1. For simple scripts working with a single project, using the global 'ras' object is fine.
# 2. For complex scripts or when working with multiple projects, create and use separate ras objects.
# 3. Be consistent in your approach: don't mix global and non-global ras object usage in the same script.
# 4. Utilize the various arguments in compute functions to customize plan execution.
# 5. Always consider your system's capabilities when setting num_cores.
# 6. Use clear_geompre=True when you want to ensure a clean computation environment.
# 7. Specify dest_folder to keep your project folder organized and prevent overwriting previous results.

def main():
    # Initialize the project
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Balde Eagle Creek"
    init_ras_project(project_path, "6.6")

    print("Available plans:")
    print(ras.plan_df)
    print()

    # Example 1: Sequential execution (compute_test_mode) with various arguments
    print("Example 1: Sequential execution with various arguments")
    for plan_number in ["01", "02"]:
        # Put dest_folder in the parent directory of the project folder (placing it horizontally with the project folder)
        # Test mode only allows dest_folder_suffix, and always creates a copy in the project folder's parent directory. 
        # So instead of building the full folder name or path, we only define the suffix. 
        dest_folder_suffix = f"_{plan_number}_[SequentialWithArgs]"
        success = RasCmdr.compute_test_mode(
            plan_number=plan_number,
            dest_folder_suffix=dest_folder_suffix,  # Test mode only allows dest_folder_suffix, and always creates a copy in the project folder's parent directory
            clear_geompre=True,
            num_cores=2,
            overwrite_dest=True
        )
        print(f"Plan {plan_number} execution: {'Successful' if success else 'Failed'}")
    print("Sequential execution completed")
    print()
    
    # This variation will fail, as the folder already exists and overwrite_dest is False.  
    # Be sure to think step by step about folder management in your multi-folder automation workflows:
    # Also, try to run the same thing with compute_parallel, but with overwrite_dest=False
    # Since we just created these folders, they are not empty, so this should generate an error message on the terminal
    # Put in Try-Except block:
    try:
        dest_folder = project_path.parent / f"{ras.project_name}_compute_test_01_[SequentialWithArgs]"
        success = RasCmdr.compute_test_mode(
            plan_number="01",
            dest_folder_suffix=dest_folder_suffix,
            clear_geompre=True,
            num_cores=2,
            overwrite_dest=False
        )
    except ValueError as e:
        print(f"If the example operates successfully (it is meant to generate an error above), you will not see this message.")

    # Example 2: Parallel execution (compute_parallel) with various arguments
    print("Example 2: Parallel execution with various arguments")
    results = RasCmdr.compute_parallel(
        plan_number=["01", "02"],
        max_workers=2,
        num_cores=2,
        dest_folder=project_path.parent / "parallel_results",
        clear_geompre=True
    )
    print("Parallel execution results:")
    for plan_number, success in results.items():
        print(f"Plan {plan_number}: {'Successful' if success else 'Failed'}")
    print()

    # Example 3: Single plan execution (compute_plan) with specific arguments
    print("Example 3: Single plan execution with specific arguments")
    plan_number = "02"
    dest_folder = project_path.parent / "compute_test_2"
    success = RasCmdr.compute_plan(plan_number, dest_folder=dest_folder, num_cores=2, clear_geompre=True, overwrite_dest=True)
    print(f"Single plan execution: {'Successful' if success else 'Failed'}")

if __name__ == "__main__":
    main()

==================================================

File: c:\GH\ras-commander\examples\12_plan_set_execution.py
==================================================
#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek"])

#### --- START OF SCRIPT --- ####

import pandas as pd


def create_plan_set(base_plan, base_geom, num_copies):
    plan_set = []
    for i in range(num_copies):
        new_plan = RasPlan.clone_plan(base_plan)
        new_geom = RasPlan.clone_geom(base_geom)
        RasPlan.set_geom(new_plan, new_geom)
        plan_set.append({
            'plan_number': new_plan,
            'geom_number': new_geom
        })
    return pd.DataFrame(plan_set)

def main():
    # Initialize the project
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Balde Eagle Creek"
    init_ras_project(project_path, "6.6")

    print("Available plans:")
    print(ras.plan_df)
    print("\nAvailable geometries:")
    print(ras.geom_df)
    print()

    # Create a plan set
    base_plan = "01"
    base_geom = "01"
    num_copies = 5
    plan_set = create_plan_set(base_plan, base_geom, num_copies)
    
    print("Created plan set:")
    print(plan_set)
    print()

    # Placeholder for user to insert code that makes programmatic changes to the model
    # For example:
    # for index, row in plan_set.iterrows():
    #     plan_path = RasPlan.get_plan_path(row['plan_number'])
    #     geom_path = RasPlan.get_geom_path(row['geom_number'])
    #     # Make changes to the plan or geometry file here
    #     # For example, you could modify Manning's n values, cross-section data, etc.

    # Execute the plan set in parallel
    print("Executing plan set in parallel")
    results = RasCmdr.compute_parallel(
        plan_number=plan_set['plan_number'].tolist(),
        max_workers=3,
        num_cores=2
    )

    # Add execution results to the plan_set DataFrame
    plan_set['execution_success'] = plan_set['plan_number'].map(results)

    print("\nPlan set execution results:")
    print(plan_set)

    # Here you could add code to analyze the results, such as:
    # - Extracting key output values from each simulation
    # - Comparing results across different plans
    # - Creating visualizations of the results

if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\13_multiple_project_operations.py
==================================================
#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
import shutil
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek", "Muncie"])

#### --- START OF SCRIPT --- ####

def execute_plan(plan_number, ras_object, compute_folder):
    # Set the number of cores to 2 before executing the plan
    RasPlan.set_num_cores(plan_number, 2, ras_object=ras_object)
    
    # Execute the plan in the compute folder
    success = RasCmdr.compute_plan(plan_number, ras_object=ras_object, dest_folder=compute_folder)
    
    return plan_number, success

def main():
    # Initialize two projects
    current_dir = Path(__file__).parent
    bald_eagle_path = current_dir / "example_projects" / "Balde Eagle Creek"
    muncie_path = current_dir / "example_projects" / "Muncie"
    
    bald_eagle = init_ras_project(bald_eagle_path, "6.6")
    muncie = init_ras_project(muncie_path, "6.6")

    print("Available plans in Bald Eagle Creek project:")
    print(bald_eagle.plan_df)
    print("\nAvailable plans in Muncie project:")
    print(muncie.plan_df)
    print()

    # Example 1: Clone plans with custom short identifiers
    print("Example 1: Cloning plans with custom short identifiers")
    new_bald_eagle_plan = RasPlan.clone_plan("01", new_plan_shortid="BECustom", ras_object=bald_eagle)
    new_muncie_plan = RasPlan.clone_plan("01", new_plan_shortid="MunCustom", ras_object=muncie)
    print(f"Created new plan {new_bald_eagle_plan} in Bald Eagle Creek project")
    print(f"Created new plan {new_muncie_plan} in Muncie project")
    print()

    # Example 2: Set geometry for the new plans
    print("Example 2: Setting geometry for the new plans")
    RasPlan.set_geom(new_bald_eagle_plan, "01", ras_object=bald_eagle)
    RasPlan.set_geom(new_muncie_plan, "01", ras_object=muncie)
    print(f"Set geometry for plan {new_bald_eagle_plan} in Bald Eagle Creek project")
    print(f"Set geometry for plan {new_muncie_plan} in Muncie project")
    print()

    # Example 3: Update unsteady flow parameters for both projects
    print("Example 3: Updating unsteady flow parameters")
    bald_eagle_plan_file = RasPlan.get_plan_path(new_bald_eagle_plan, ras_object=bald_eagle)
    muncie_plan_file = RasPlan.get_plan_path(new_muncie_plan, ras_object=muncie)

    modifications = {
        "Computation Interval": "2MIN",
        "Output Interval": "30MIN",
        "Mapping Interval": "1HOUR"
    }

    RasUnsteady.update_unsteady_parameters(bald_eagle_plan_file, modifications, ras_object=bald_eagle)
    RasUnsteady.update_unsteady_parameters(muncie_plan_file, modifications, ras_object=muncie)
    print("Updated unsteady flow parameters for both projects")
    print()

    # Example 4: Execute plans for both projects simultaneously in separate compute folders
    print("Example 4: Executing plans for both projects simultaneously in separate compute folders")
    
    # Create compute folders
    bald_eagle_compute_folder = bald_eagle_path.parent / "compute_bald_eagle"
    muncie_compute_folder = muncie_path.parent / "compute_muncie"
    
    # Remove existing compute folders if they exist
    for folder in [bald_eagle_compute_folder, muncie_compute_folder]:
        if folder.exists():
            shutil.rmtree(folder)
        folder.mkdir(parents=True, exist_ok=True)
    
    with ThreadPoolExecutor(max_workers=2) as executor:
        futures = [
            executor.submit(execute_plan, new_bald_eagle_plan, bald_eagle, bald_eagle_compute_folder),
            executor.submit(execute_plan, new_muncie_plan, muncie, muncie_compute_folder)
        ]
        
        results = {}
        for future in futures:
            plan_number, success = future.result()
            results[plan_number] = success

    print("Execution results:")
    for plan_number, success in results.items():
        print(f"Plan {plan_number} execution: {'Successful' if success else 'Failed'}")
    print()

    # Example 5: Get and print results paths
    print("Example 5: Getting results paths")
    bald_eagle_results = RasPlan.get_results_path(new_bald_eagle_plan, ras_object=bald_eagle)
    muncie_results = RasPlan.get_results_path(new_muncie_plan, ras_object=muncie)

    if bald_eagle_results:
        print(f"Results for Bald Eagle Creek plan {new_bald_eagle_plan} are located at: {bald_eagle_results}")
    else:
        print(f"No results found for Bald Eagle Creek plan {new_bald_eagle_plan}")

    if muncie_results:
        print(f"Results for Muncie plan {new_muncie_plan} are located at: {muncie_results}")
    else:
        print(f"No results found for Muncie plan {new_muncie_plan}")

    print("\nNote: The original project folders can now be edited while the compute operations are running in separate folders.")

if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\14_Core_Sensitivity.ipynb
==================================================
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "#%pip install ras-commander pandas requests pathlib matplotlib"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 14_Core_Sensitivity.ipynb\n",
    "Testing Core Sensitivity for RAS using the Bald Eagle Creek Multi-Gage 2D project.  \n",
    "\n",
    "\n",
    "This should take around 15-45 minutes to run depending on your hardware."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys\n",
    "from pathlib import Path\n",
    "\n",
    "# Flexible imports to allow for development without installation\n",
    "try:\n",
    "    # Try to import from the installed package\n",
    "    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, RasHdf, ras\n",
    "except ImportError:\n",
    "    # If the import fails, add the parent directory to the Python path\n",
    "    import os\n",
    "    current_file = Path(os.getcwd()).resolve()\n",
    "    parent_directory = current_file.parent\n",
    "    sys.path.append(str(parent_directory))\n",
    "    \n",
    "    # Now try to import again\n",
    "    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, RasHdf, ras\n",
    "\n",
    "print(\"ras_commander imported successfully\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import time\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from pathlib import Path\n",
    "from ras_commander import RasExamples, init_ras_project, RasCmdr, RasPlan, RasGeo\n",
    "\n",
    "# Step 1: Initialize RasExamples and extract the BaldEagleCrkMulti2D project\n",
    "ras_examples = RasExamples()\n",
    "ras_examples.extract_project([\"BaldEagleCrkMulti2D\"])\n",
    "\n",
    "# Use Path.cwd() to get the current working directory in a Jupyter Notebook\n",
    "current_directory = Path.cwd()\n",
    "project_path = current_directory / \"example_projects\" / \"BaldEagleCrkMulti2D\"\n",
    "\n",
    "# Step 2: Initialize the Muncie Project using init_ras_project (from ras_commander)\n",
    "muncie_project = init_ras_project(project_path, \"6.6\")\n",
    "\n",
    "# Step 3: Initialize a DataFrame to store execution results\n",
    "results = []\n",
    "\n",
    "# Step 4: Run sensitivity analysis for Plan 03 with core counts 1-8\n",
    "plan_number = '03'\n",
    "print(f\"Running sensitivity analysis for Plan {plan_number}\")\n",
    "\n",
    "# Clear geompre files before running the plan\n",
    "plan_path = RasPlan.get_plan_path(plan_number)\n",
    "RasGeo.clear_geompre_files(plan_path)\n",
    "\n",
    "for cores in range(1, 9):\n",
    "    print(f\"Running with {cores} core(s)\")\n",
    "    # Set core count for this plan\n",
    "    RasPlan.set_num_cores(plan_number, cores)\n",
    "    \n",
    "    # Time the execution of the plan\n",
    "    start_time = time.time()\n",
    "    RasCmdr.compute_plan(plan_number)\n",
    "    execution_time = time.time() - start_time\n",
    "    \n",
    "    # Store the results\n",
    "    results.append({\n",
    "        \"plan_number\": plan_number,\n",
    "        \"cores\": cores,\n",
    "        \"execution_time\": execution_time\n",
    "    })\n",
    "    \n",
    "    print(f\"Execution time: {execution_time:.2f} seconds\")\n",
    "\n",
    "print(\"Sensitivity analysis complete\")\n",
    "\n",
    "# Step 5: Convert results into a DataFrame\n",
    "results_df = pd.DataFrame(results)\n",
    "\n",
    "# Optionally, save the results to a CSV file\n",
    "results_df.to_csv(\"core_sensitivity_results.csv\", index=False)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "NOTES FOR REVISIONS:\n",
    "- Use HDF compute summary to show the time for each preproces/unsteady compute/postprocess step. \n",
    "- First, run preprocessor and then toggle options to only run unsteady compute and postprocess. \n",
    "- Plot each step separately. \n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Optionally, load the results from a CSV file\n",
    "results_df = pd.read_csv(\"core_sensitivity_results.csv\")\n",
    "\n",
    "# Display the results dataframe for verification\n",
    "print(\"results_df DataFrame:\")\n",
    "display(results_df)\n",
    "\n",
    "# Step 6: Calculate unit runtime (based on 1 core execution time)\n",
    "results_df['unit_runtime'] = results_df.groupby('plan_number')['execution_time'].transform(lambda x: x / x.iloc[0])\n",
    "\n",
    "# Get the project name from the ras object\n",
    "project_name = ras.project_name\n",
    "\n",
    "# Step 7: Plot a line chart for unit runtime vs. cores for each plan\n",
    "plt.figure(figsize=(10, 6))\n",
    "for plan in results_df['plan_number'].unique():\n",
    "    plan_data = results_df[results_df['plan_number'] == plan]\n",
    "    plt.plot(plan_data['cores'], plan_data['unit_runtime'], label=f\"Plan {plan}\")\n",
    "\n",
    "plt.xlabel(\"Number of Cores\")\n",
    "plt.ylabel(\"Unit Runtime (Relative to 1 Core)\")\n",
    "plt.title(f\"{project_name} (HEC Example Project)\\nCore Count Sensitivity Analysis\")\n",
    "plt.legend(title=\"Plan Number\")\n",
    "plt.grid(True)\n",
    "plt.show()\n",
    "\n",
    "# Print summary statistics\n",
    "print(\"\\nSummary Statistics:\")\n",
    "summary_stats = results_df.groupby('cores')['execution_time'].agg(['mean', 'min', 'max'])\n",
    "display(summary_stats)\n",
    "\n",
    "# Calculate and print speedup\n",
    "speedup = results_df[results_df['cores'] == 1]['execution_time'].mean() / results_df[results_df['cores'] == 8]['execution_time'].mean()\n",
    "print(f\"\\nAverage speedup from 1 to 8 cores: {speedup:.2f}x\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "releasecmdr311",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}

==================================================

File: c:\GH\ras-commander\examples\15_plan_key_operations.py
==================================================
# 15_plan_key_operations.py

#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek"])

#### --- START OF SCRIPT --- ####

def main():
    # Initialize the project
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Balde Eagle Creek"
    ras_obj = init_ras_project(project_path, "6.6")

    print("Example 15: Getting and Setting Plan Keys")
    print("------------------------------------------")

    # Get the first plan number
    plan_number = ras_obj.plan_df['plan_number'].iloc[0]
    print(f"Working with Plan: {plan_number}")

    # 1. Get and print multiple plan values
    keys_to_check = ['Computation Interval', 'Simulation Date', 'Short Identifier', 'UNET D1 Cores']
    print("\n1. Current Plan Values:")
    for key in keys_to_check:
        value = RasPlan.get_plan_value(plan_number, key, ras_object=ras_obj)
        print(f"  {key}: {value}")

    # 2. Update plan values
    print("\n2. Updating Plan Values:")
    updates = {
        'Computation Interval': '30SEC',
        'Short Identifier': 'Updated_Plan',
        'UNET D1 Cores': '4'
    }
    for key, value in updates.items():
        RasPlan.update_plan_value(plan_number, key, value, ras_object=ras_obj)
        print(f"  Updated {key} to: {value}")

    # 3. Verify updates
    print("\n3. Verifying Updates:")
    for key in updates.keys():
        new_value = RasPlan.get_plan_value(plan_number, key, ras_object=ras_obj)
        print(f"  {key}: {new_value}")

    # 4. Get description
    print("\n4. Plan Description:")
    current_description = RasPlan.get_plan_value(plan_number, 'Description', ras_object=ras_obj)
    print(f"  Current description: {current_description}")
    # Updating descriptions is a multi-line operation that will need additional logic in update_plan_value

    # 5. Attempt to get and set an invalid key
    print("\n5. Handling Invalid Keys:")
    RasPlan.get_plan_value(plan_number, 'Invalid Key', ras_object=ras_obj)

    RasPlan.update_plan_value(plan_number, 'Invalid Key', 'some_value', ras_object=ras_obj)

    print("\nExample 15 completed.")

if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\16_scanning_ras_project_info.py
==================================================
import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    from ras_commander import init_ras_project, RasPrj, RasExamples
except ImportError:
    sys.path.append(str(parent_directory))
    from ras_commander import init_ras_project, RasPrj, RasExamples

import logging

def generate_category_summary(category_path):
    summary = []
    summary.append(f"RAS-Commander Example Projects Summary for Category: {category_path.name}\n")
    summary.append("=" * 80 + "\n\n")

    for project_path in category_path.iterdir():
        if project_path.is_dir():
            summary.append(f"Project Folder: {project_path.name}")
            summary.append(f"Full Path: {project_path.resolve()}\n")

            try:
                ras_project = init_ras_project(project_path, "6.6", ras_instance=RasPrj())
                
                summary.append(f"Project Name: {ras_project.get_project_name()}")
                summary.append(f"PRJ File: {ras_project.prj_file}")
                summary.append(f"RAS Executable: {ras_project.ras_exe_path}\n")

                summary.append("Plan Files:")
                summary.append(ras_project.plan_df.to_string())
                summary.append("\n")

                summary.append("Flow Files:")
                summary.append(ras_project.flow_df.to_string())
                summary.append("\n")

                summary.append("Geometry Files:")
                summary.append(ras_project.geom_df.to_string())
                summary.append("\n")

                summary.append("Unsteady Flow Files:")
                summary.append(ras_project.unsteady_df.to_string())
                summary.append("\n")

                summary.append("Boundary Conditions:")
                summary.append(ras_project.boundaries_df.to_string())
                summary.append("\n")

                # Add unparsed lines for each boundary condition
                summary.append("Unparsed Boundary Condition Lines:")
                for _, row in ras_project.boundaries_df.iterrows():
                    bc_number = row['boundary_condition_number']
                    unsteady_number = row['unsteady_number']
                    unparsed_lines = ras_project._parse_boundary_condition(
                        ras_project._get_boundary_condition_block(unsteady_number, bc_number),
                        unsteady_number,
                        bc_number
                    )[1]
                    if unparsed_lines:
                        summary.append(f"BC {bc_number} in Unsteady File {unsteady_number}:")
                        summary.append(unparsed_lines)
                        summary.append("\n")
                summary.append("\n")

            except Exception as e:
                summary.append(f"Error initializing RAS project: {str(e)}\n")

            summary.append("-" * 80 + "\n\n")

    return "\n".join(summary)

def main():
    # Set logging level to DEBUG to capture unparsed lines
    logging.getLogger().setLevel(logging.DEBUG)

    ras_examples = RasExamples()
    selected_categories = ["1D Unsteady Flow Hydraulics", "2D Unsteady Flow Hydraulics"]

    base_dir = Path.cwd() / "ras_example_categories"
    base_dir.mkdir(exist_ok=True)

    for category in selected_categories:
        category_dir = base_dir / category
        category_dir.mkdir(exist_ok=True)

        projects = ras_examples.list_projects(category)
        extracted_paths = ras_examples.extract_project(projects)

        # Move extracted projects to the category directory
        for path in extracted_paths:
            new_path = category_dir / path.name
            path.rename(new_path)

        # Generate and save summary for this category
        summary_text = generate_category_summary(category_dir)
        output_file = base_dir / f"ras-commander {category} summary.txt"
        with open(output_file, "w") as f:
            f.write(summary_text)

        print(f"Summary for category '{category}' has been written to: {output_file}")

    print("All category summaries have been generated.")

    # Clean up extracted projects
    ras_examples.clean_projects_directory()
    print("Cleaned up original extracted example projects.")

if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\17_parallel_execution_ble.py
==================================================
#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path
import shutil
import psutil
import math
import logging

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, RasPrj
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, RasPrj

# Configure logging
logging.basicConfig(
    level=logging.INFO,  # Set the logging level to INFO
    format='%(asctime)s - %(levelname)s - %(message)s',  # Log message format
    handlers=[
        logging.StreamHandler()  # Log to stderr
    ]
)

# Initialize RasExamples
ras_examples = RasExamples()

#### --- START OF SCRIPT --- ####

# ras-commander Library Notes:
# 1. This example uses separate RasPrj objects for each project/folder.
# 2. Using separate RasPrj objects allows working with multiple projects or folders.
# 3. We'll create new RasPrj objects for the original project and each output folder.
# 4. For functions that do batched execution (sequential or parallel), they are careful not to overwrite existing folders.
# 5. If you want your script to be repeatable, make sure to delete the folders before running again.

# Best Practices:
# 1. For complex scripts or when working with multiple projects/folders, create and use separate RasPrj objects.
# 2. Be consistent in your approach: use non-global RasPrj objects throughout the script.
# 3. When using parallel execution, consider the number of cores available on your machine.
# 4. Use the dest_folder argument to keep your project folder clean and organized.

##  WHISKY CHITTO DOES NOT WORK - BLE MODEL IS BROKEN AND REQUIRED FIXING BEFORE RUNNING

def get_physical_core_count():
    return psutil.cpu_count(logical=False)

def main():
    # Define paths
    current_dir = Path(__file__).parent
    csv_directory = current_dir / "FEMA_BLE_Models"
    csv_file = csv_directory / "08080204_WhiskyChitto_DownloadIndex.csv"
    
    # Download FEMA BLE Models (specifically WhiskyChitto)
    ras_examples.download_fema_ble_model(csv_file=csv_file)
    
    
    # Initialize the RasPrj object for WhiskyChitto
    project_path = csv_directory / "WhiskyChitto" / "HECRAS_Models" / "Model" / "Input"
    logging.info(f"Initializing RasPrj for project at: {project_path}")
    whisky_project = init_ras_project(project_path, "5.0.7")
    
    print("Available plans:")
    print(whisky_project.plan_df)
    print()
    
    # Example 1: Parallel execution of all plans with overwrite_dest
    print("Example 1: Parallel execution of all plans with overwrite_dest")
    compute_folder = project_path.parent / "compute_test_parallel_whisky"
    results_all = RasCmdr.compute_parallel(
        max_workers=2,
        num_cores=2,
        dest_folder=compute_folder,
        overwrite_dest=True,
        ras_object=whisky_project
    )
    print("Parallel execution of all plans results:")
    for plan_number, success in results_all.items():
        print(f"Plan {plan_number}: {'Successful' if success else 'Failed'}")
    print()
    
    # Initialize a new RasPrj object for the compute_folder
    compute_source_project = init_ras_project(compute_folder, "6.6")
    print("Plan DataFrame after parallel execution of all plans:")
    print(compute_source_project.plan_df)
    print()
    
    # Example 2: Parallel execution of specific plans with overwrite_dest
    print("Example 2: Parallel execution of specific plans with overwrite_dest")
    specific_plans = ["01", "02"]
    specific_compute_folder = project_path.parent / "compute_test_parallel_specific_whisky"
    results_specific = RasCmdr.compute_parallel(
        plan_number=specific_plans,
        max_workers=2,
        num_cores=2,
        dest_folder=specific_compute_folder,
        overwrite_dest=True,
        ras_object=whisky_project
    )
    print("Parallel execution of specific plans results:")
    for plan_number, success in results_specific.items():
        print(f"Plan {plan_number}: {'Successful' if success else 'Failed'}")
    print()
    
    # Example 3: Parallel execution with dynamic max_workers based on physical cores
    print("Example 3: Parallel execution with dynamic max_workers")
    num_cores = 2
    physical_cores = get_physical_core_count()
    max_workers = math.floor(physical_cores / num_cores) if num_cores > 0 else 1
    
    dynamic_compute_folder = project_path.parent / "compute_test_parallel_dynamic_whisky"
    results_dynamic = RasCmdr.compute_parallel(
        max_workers=max_workers,
        num_cores=num_cores,
        dest_folder=dynamic_compute_folder,
        overwrite_dest=True,
        ras_object=whisky_project
    )
    print(f"Parallel execution with {max_workers} workers and {num_cores} cores per worker:")
    for plan_number, success in results_dynamic.items():
        print(f"Plan {plan_number}: {'Successful' if success else 'Failed'}")
    print()
    
    # Get and print results paths
    print("Results paths for dynamic execution:")
    dynamic_compute_source_project = init_ras_project(dynamic_compute_folder, "6.6")
    print(dynamic_compute_source_project.plan_df)

if __name__ == "__main__":
    main()


==================================================

File: c:\GH\ras-commander\examples\18_2d_hdf_data_extraction.ipynb
==================================================
{"cells":[{"cell_type":"markdown","metadata":{},"source":["# HEC-RAS 2D HDF Data Analysis Notebook\n","\n","This notebook demonstrates how to manipulate and analyze HEC-RAS 2D HDF data using the ras-commander library. It leverages the HdfBase, HdfUtils, HdfStruc, HdfMesh, HdfXsec, HdfBndry, HdfPlan, HdfResultsPlan, HdfResultsMesh, and HdfResultsXsec classes to streamline data extraction, processing, and visualization.\n"]},{"cell_type":"code","execution_count":1,"metadata":{},"outputs":[],"source":["# Import required Libraries\n","import subprocess\n","import sys\n","import os\n","from pathlib import Path\n","\n","def install_module(module_name):\n","    try:\n","        __import__(module_name)\n","    except ImportError:\n","        print(f\"{module_name} not found. Installing...\")\n","        subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"-U\", module_name])\n","\n","# List of modules to check and install if necessary\n","modules = ['h5py', 'numpy', 'requests', 'geopandas', 'matplotlib', 'pandas', 'pyproj', 'shapely', 'xarray']\n","for module in modules:\n","    install_module(module)\n","\n","# Import the rest of the required libraries\n","import pandas as pd\n","import numpy as np\n","import geopandas as gpd\n","import matplotlib.pyplot as plt\n","import pyproj\n","from shapely.geometry import Point, LineString, Polygon\n","import xarray as xr\n"]},{"cell_type":"code","execution_count":2,"metadata":{},"outputs":[],"source":["# Install ras-commander if you are not in a dev environment. \n","# install_module(ras-commander)"]},{"cell_type":"markdown","metadata":{},"source":["## Importing ras-commander flexibly (from package or local dev copy)"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["import sys\n","from pathlib import Path\n","\n","# Flexible imports to allow for development without installation \n","#  ** Use this version with Jupyter Notebooks **\n","try:\n","    # Try to import from the installed package\n","    from ras_commander import (\n","        init_ras_project, \n","        HdfBase, \n","        HdfUtils, \n","        HdfStruc, \n","        HdfMesh, \n","        HdfXsec, \n","        HdfBndry, \n","        HdfPlan, \n","        HdfResultsPlan, \n","        HdfResultsMesh, \n","        HdfResultsXsec,\n","        RasExamples, \n","        RasCmdr, \n","        RasPlan, \n","        RasGeo, \n","        RasUnsteady, \n","        RasUtils, \n","        RasPrj, \n","        RasGpt, \n","        ras,\n","        XsSteadyOutputVar,\n","        SummaryOutputVar,\n","        TimeSeriesOutputVar\n","    )\n","    from ras_commander.Decorators import standardize_input, log_call\n","    from ras_commander.LoggingConfig import setup_logging, get_logger\n","except ImportError:\n","    # If the import fails, add the parent directory to the Python path\n","    import os\n","    current_file = Path(os.getcwd()).resolve()\n","    parent_directory = current_file.parent\n","    sys.path.append(str(parent_directory))\n","    \n","    # Now try to import again\n","    from ras_commander import (\n","        init_ras_project, \n","        HdfBase, \n","        HdfUtils, \n","        HdfStruc, \n","        HdfMesh, \n","        HdfXsec, \n","        HdfBndry, \n","        HdfPlan, \n","        HdfResultsPlan, \n","        HdfResultsMesh, \n","        HdfResultsXsec,\n","        RasExamples, \n","        RasCmdr, \n","        RasPlan, \n","        RasGeo, \n","        RasUnsteady, \n","        RasUtils, \n","        RasPrj, \n","        RasGpt, \n","        ras,\n","    )\n","    from ras_commander.Decorators import standardize_input, log_call\n","    from ras_commander.LoggingConfig import setup_logging, get_logger\n","\n","print(\"ras_commander imported successfully\")"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Download the BaldEagleCrkMulti2D project from HEC and run plan 01\n","\n","# Define the path to the BaldEagleCrkMulti2D project\n","current_dir = Path.cwd()  # Adjust if your notebook is in a different directory\n","bald_eagle_path = current_dir / \"example_projects\" / \"BaldEagleCrkMulti2D\"\n","import logging\n","\n","# Check if BaldEagleCrkMulti2D.p06.hdf exists (so we don't have to re-run the simulation when re-running or debugging)\n","hdf_file = bald_eagle_path / \"BaldEagleDamBrk.p06.hdf\"\n","\n","if not hdf_file.exists():\n","    # Initialize RasExamples and extract the BaldEagleCrkMulti2D project\n","    ras_examples = RasExamples()\n","    ras_examples.extract_project([\"BaldEagleCrkMulti2D\"])\n","\n","    # Initialize custom Ras object\n","    bald_eagle = RasPrj()\n","\n","    # Initialize the RAS project using the custom ras object\n","    bald_eagle = init_ras_project(bald_eagle_path, \"6.6\", ras_instance=bald_eagle)\n","    logging.info(f\"Bald Eagle project initialized with folder: {bald_eagle.project_folder}\")\n","    \n","    logging.info(f\"Bald Eagle object id: {id(bald_eagle)}\")\n","    \n","    # Define the plan number to execute\n","    plan_number = \"06\"\n","\n","    # Set plan keys for the project\n","    RasPlan.update_plan_value(plan_number, \"Run HTab\", 1, ras_object=bald_eagle)\n","    RasPlan.update_plan_value(plan_number, \"Run UNet\", 1, ras_object=bald_eagle)\n","    RasPlan.update_plan_value(plan_number, \"Run PostProcess\", 1, ras_object=bald_eagle)\n","    RasPlan.update_plan_value(plan_number, \"Run RASMapper\", 0, ras_object=bald_eagle)\n","\n","    # Execute Plan 06 using RasCmdr for Bald Eagle\n","    print(f\"Executing Plan {plan_number} for the Bald Eagle Creek project...\")\n","    success_bald_eagle = RasCmdr.compute_plan(plan_number, ras_object=bald_eagle)\n","    if success_bald_eagle:\n","        print(f\"Plan {plan_number} executed successfully for Bald Eagle.\\n\")\n","    else:\n","        print(f\"Plan {plan_number} execution failed for Bald Eagle.\\n\")\n","else:\n","    print(\"BaldEagleCrkMulti2D.p06.hdf already exists. Skipping project extraction and plan execution.\")\n","    # Initialize the RAS project using the custom ras object\n","    bald_eagle = RasPrj()\n","    bald_eagle = init_ras_project(bald_eagle_path, \"6.6\", ras_instance=bald_eagle)\n","    plan_number = \"06\""]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Load Plan and Geometry Dataframes and find Plan and Geometry HDF Paths\n","\n","# Display plan_df for bald_eagle project\n","print(\"Plan DataFrame for bald_eagle project:\")\n","display(bald_eagle.plan_df)\n","\n","# Display geom_df for bald_eagle project\n","print(\"\\nGeometry DataFrame for bald_eagle project:\")\n","display(bald_eagle.geom_df)\n","\n","# Get the plan HDF path\n","plan_number = \"06\"  # Assuming we're using plan 01 as in the previous code\n","plan_hdf_path = bald_eagle.plan_df.loc[bald_eagle.plan_df['plan_number'] == plan_number, 'HDF_Results_Path'].values[0]\n","\n","# Get the geometry file number from the plan DataFrame\n","geom_file = bald_eagle.plan_df.loc[bald_eagle.plan_df['plan_number'] == plan_number, 'Geom File'].values[0]\n","geom_number = geom_file[1:]  # Remove the 'g' prefix\n","\n","# Get the geometry HDF path\n","geom_hdf_path = bald_eagle.geom_df.loc[bald_eagle.geom_df['geom_number'] == geom_number, 'hdf_path'].values[0]\n","\n","print(f\"\\nPlan HDF path for Plan {plan_number}: {plan_hdf_path}\")\n","print(f\"Geometry HDF path for Plan {plan_number}: {geom_hdf_path}\")"]},{"cell_type":"code","execution_count":6,"metadata":{},"outputs":[],"source":["# Define the HDF input path as Plan Number\n","\n","plan_number = \"06\"  # Assuming we're using plan 01 as in the previous code\n"]},{"cell_type":"markdown","metadata":{},"source":["RasHdfUtils\n","| Method Name | Description |\n","|-------------|-------------|\n","| get_attrs | Converts attributes from a HEC-RAS HDF file into a Python dictionary for a given attribute path |\n","| get_root_attrs | Returns attributes at root level of HEC-RAS HDF file |\n","| get_hdf_paths_with_properties | Gets all paths in the HDF file with their properties |\n","| get_group_attributes_as_df | Gets attributes of a group in the HDF file as a DataFrame |\n","| get_hdf_filename | Gets the HDF filename from various input types |\n","| get_runtime_data | Extracts runtime and compute time data from a single HDF file |\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get HDF Paths with Properties (For Exploring HDF Files)\n","plan_number = \"06\"  # Assuming we're using plan 06 as in the previous code\n","hdf_paths_df = HdfUtils.get_hdf_paths_with_properties(plan_number, ras_object=bald_eagle)\n","display(hdf_paths_df.head())"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Extract runtime and compute time data\n","print(\"\\nExample 2: Extracting runtime and compute time data\")\n","runtime_df = HdfResultsPlan.get_runtime_data(hdf_input=plan_number, ras_object=bald_eagle)\n","if runtime_df is not None:\n","    display(runtime_df)\n","else:\n","    print(\"No runtime data found.\")"]},{"cell_type":"code","execution_count":9,"metadata":{},"outputs":[],"source":["# TODO: Example for get_attrs"]},{"cell_type":"code","execution_count":10,"metadata":{},"outputs":[],"source":["# TODO: Example for get_root_attrs"]},{"cell_type":"code","execution_count":11,"metadata":{},"outputs":[],"source":["# TODO: Example for get_hdf_paths_with_properties"]},{"cell_type":"code","execution_count":12,"metadata":{},"outputs":[],"source":["# TODO: Example for get_group_attributes_as_df"]},{"cell_type":"markdown","metadata":{},"source":["Table of all the functions in the RasGeomHdf class from the ras_commander/RasGeomHdf.py file:\n","\n","| Function Name | Description |\n","|---------------|-------------|\n","| projection | Returns the projection of the RAS geometry as a pyproj.CRS object |\n","| get_geom_attrs | Returns base geometry attributes from a HEC-RAS HDF file |\n","\n","| mesh_area_names | Returns a list of the 2D mesh area names of the RAS geometry |\n","| get_geom_2d_flow_area_attrs | Returns geometry 2d flow area attributes from a HEC-RAS HDF file |\n","| mesh_areas | Returns 2D flow area perimeter polygons |\n","| mesh_cell_polygons | Returns 2D flow mesh cell polygons |\n","| mesh_cell_points | Returns 2D flow mesh cell points |\n","| mesh_cell_faces | Returns 2D flow mesh cell faces |\n","\n","| get_geom_structures_attrs | Returns geometry structures attributes from a HEC-RAS HDF file |\n","\n","\n","\n","\n","| bc_lines | Returns 2D mesh area boundary condition lines |\n","| breaklines | Returns 2D mesh area breaklines |\n","\n","\n","\n","| refinement_regions | Returns 2D mesh area refinement regions |\n","| structures | Returns the model structures |\n","| reference_lines_names | Returns reference line names |\n","| reference_points_names | Returns reference point names |\n","| reference_lines | Returns the reference lines geometry and attributes |\n","| reference_points | Returns the reference points geometry and attributes |\n","| cross_sections | Returns the model 1D cross sections |\n","| river_reaches | Returns the model 1D river reach lines |\n","| cross_sections_elevations | Returns the model cross section elevation information |"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# For all of the RasGeomHdf Class Functions, we will use geom_hdf_path\n","print(geom_hdf_path)\n","\n","# For the example project, plan 06 is associated with geometry 09\n","# If you want to call the geometry by number, call RasHdfGeom functions with a number\n","# Otherwise, if you want to look up geometry hdf path by plan number, follow the logic in the previous code cells"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Use HdfUtils for extracting projection\n","print(\"\\nExtracting Projection from HDF\")\n","projection = HdfUtils.projection(hdf_path=geom_hdf_path)\n","if projection:\n","    print(f\"Projection: {projection}\")\n","else:\n","    print(\"No projection information found.\")"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Use HdfPlan for geometry-related operations\n","print(\"\\nExample: Extracting Base Geometry Attributes\")\n","geom_attrs = HdfPlan.get_geom_attrs(geom_hdf_path, ras_object=bald_eagle)\n","\n","if geom_attrs:\n","    # Convert the dictionary to a DataFrame for better display\n","    geom_attrs_df = pd.DataFrame([geom_attrs])\n","    \n","    # Display the DataFrame\n","    print(\"Base Geometry Attributes:\")\n","    display(geom_attrs_df)\n","else:\n","    print(\"No base geometry attributes found.\")\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Use HdfMesh for geometry-related operations\n","print(\"\\nExample 3: Listing 2D Flow Area Names\")\n","flow_area_names = HdfMesh.mesh_area_names(geom_hdf_path, ras_object=bald_eagle)\n","print(\"2D Flow Area Names:\", flow_area_names)"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get 2D Flow Area Attributes (get_geom_2d_flow_area_attrs)\n","print(\"\\nExample: Extracting 2D Flow Area Attributes\")\n","flow_area_attributes = HdfMesh.get_geom_2d_flow_area_attrs(geom_hdf_path, ras_object=bald_eagle)\n","\n","if flow_area_attributes:\n","    # Convert the dictionary to a DataFrame for better display\n","    flow_area_df = pd.DataFrame([flow_area_attributes])\n","    \n","    # Display the DataFrame\n","    print(\"2D Flow Area Attributes:\")\n","    display(flow_area_df)\n","    \n","    # Optionally, you can access specific attributes\n","    print(\"\\nSpecific Attribute Examples:\")\n","    print(f\"Cell Average Size: {flow_area_attributes.get('Cell Average Size', 'N/A')}\")\n","    print(f\"Manning's n: {flow_area_attributes.get('Manning''s n', 'N/A')}\")\n","    print(f\"Terrain Filename: {flow_area_attributes.get('Terrain Filename', 'N/A')}\")\n","else:\n","    print(\"No 2D Flow Area attributes found.\")\n","\n","# Note: This example assumes that get_geom_2d_flow_area_attrs returns a dictionary.\n","# If it returns a different format, you may need to adjust the code accordingly.\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get 2D Flow Area Perimeter Polygons (mesh_areas)\n","print(\"\\nExample: Extracting 2D Flow Area Perimeter Polygons\")\n","mesh_areas = HdfMesh.mesh_areas(geom_hdf_path, ras_object=bald_eagle)"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Plot the 2D Flow Area Perimeter Polygons\n","import matplotlib.pyplot as plt\n","\n","fig, ax = plt.subplots(figsize=(12, 8))\n","mesh_areas.plot(ax=ax, edgecolor='black', facecolor='none')\n","\n","# Add labels for each polygon\n","for idx, row in mesh_areas.iterrows():\n","    centroid = row.geometry.centroid\n","    # Check if 'Name' column exists, otherwise use a default label\n","    label = row.get('Name', f'Area {idx}')\n","    ax.annotate(label, (centroid.x, centroid.y), ha='center', va='center')\n","\n","plt.title('2D Flow Area Perimeter Polygons')\n","plt.xlabel('Easting')\n","plt.ylabel('Northing')\n","plt.tight_layout()\n","plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Extract 2D Flow Area Attributes \n","print(\"\\nExample 4: Extracting 2D Flow Area Attributes\")\n","flow_area_attributes = HdfMesh.get_geom_2d_flow_area_attrs(geom_hdf_path, ras_object=bald_eagle)\n","if flow_area_attributes:\n","    # Convert the dictionary to a DataFrame for better display\n","    flow_area_attributes_df = pd.DataFrame([flow_area_attributes])\n","    display(flow_area_attributes_df)\n","else:\n","    print(\"No 2D Flow Area attributes found.\")"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Extract mesh cell faces\n","print(\"\\nExample: Extracting mesh cell faces\")\n","\n","# Get mesh cell faces\n","mesh_cell_faces = HdfMesh.mesh_cell_faces(geom_hdf_path, ras_object=bald_eagle)\n","\n","# Display the first few rows of the mesh cell faces DataFrame\n","print(\"First few rows of mesh cell faces:\")\n","display(mesh_cell_faces.head())\n","\n","# Plot the mesh cell faces\n","fig, ax = plt.subplots(figsize=(12, 8))\n","\n","# Plot all cell faces\n","for _, row in mesh_cell_faces.iterrows():\n","    ax.plot(*row['geometry'].xy, color='blue', linewidth=0.5, alpha=0.5)\n","\n","# Set plot title and labels\n","plt.title('Mesh Cell Faces')\n","plt.xlabel('Easting')\n","plt.ylabel('Northing')\n","\n","# Add a colorbar to show face IDs\n","scatter = ax.scatter(\n","    mesh_cell_faces.geometry.centroid.x,\n","    mesh_cell_faces.geometry.centroid.y,\n","    c=mesh_cell_faces['face_id'],\n","    cmap='viridis',\n","    s=1,\n","    alpha=0.5\n",")\n","plt.colorbar(scatter, label='Face ID')\n","\n","plt.tight_layout()\n","plt.show()\n","\n","# Calculate and display some statistics\n","print(\"\\nMesh Cell Faces Statistics:\")\n","print(f\"Total number of cell faces: {len(mesh_cell_faces)}\")\n","print(f\"Number of unique meshes: {mesh_cell_faces['mesh_name'].nunique()}\")\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Function to find the nearest cell face to a given point\n","def find_nearest_cell_face(point, cell_faces_df):\n","    \"\"\"\n","    Find the nearest cell face to a given point.\n","\n","    Args:\n","        point (shapely.geometry.Point): The input point.\n","        cell_faces_df (GeoDataFrame): DataFrame containing cell face linestrings.\n","\n","    Returns:\n","        int: The face_id of the nearest cell face.\n","        float: The distance to the nearest cell face.\n","    \"\"\"\n","    # Calculate distances from the input point to all cell faces\n","    distances = cell_faces_df.geometry.distance(point)\n","\n","    # Find the index of the minimum distance\n","    nearest_index = distances.idxmin()\n","\n","    # Get the face_id and distance of the nearest cell face\n","    nearest_face_id = cell_faces_df.loc[nearest_index, 'face_id']\n","    nearest_distance = distances[nearest_index]\n","\n","    return nearest_face_id, nearest_distance\n","\n","# Example usage\n","print(\"\\nExample: Finding the nearest cell face to a given point\")\n","\n","# Create a sample point (you can replace this with any point of interest)\n","from shapely.geometry import Point\n","from geopandas import GeoDataFrame\n","\n","# Get the projection from the geometry file\n","projection = HdfUtils.projection(hdf_path=geom_hdf_path)\n","if projection:\n","    print(f\"Using projection: {projection}\")\n","else:\n","    print(\"No projection information found. Using default CRS.\")\n","    projection = \"EPSG:4326\"  # Default to WGS84 if no projection is found\n","\n","# Create the sample point with the correct CRS\n","sample_point = GeoDataFrame({'geometry': [Point(2042250, 351750)]}, crs=projection)\n","\n","if not mesh_cell_faces.empty and not sample_point.empty:\n","    # Ensure the CRS of the sample point matches the mesh_cell_faces\n","    if sample_point.crs != mesh_cell_faces.crs:\n","        sample_point = sample_point.to_crs(mesh_cell_faces.crs)\n","    \n","    nearest_face_id, distance = find_nearest_cell_face(sample_point.geometry.iloc[0], mesh_cell_faces)\n","    print(f\"Nearest cell face to point {sample_point.geometry.iloc[0].coords[0]}:\")\n","    print(f\"Face ID: {nearest_face_id}\")\n","    print(f\"Distance: {distance:.2f} units\")\n","\n","    # Visualize the result\n","    fig, ax = plt.subplots(figsize=(12, 8))\n","    \n","    # Plot all cell faces\n","    mesh_cell_faces.plot(ax=ax, color='blue', linewidth=0.5, alpha=0.5, label='Cell Faces')\n","    \n","    # Plot the sample point\n","    sample_point.plot(ax=ax, color='red', markersize=100, alpha=0.7, label='Sample Point')\n","    \n","    # Plot the nearest cell face\n","    nearest_face = mesh_cell_faces[mesh_cell_faces['face_id'] == nearest_face_id]\n","    nearest_face.plot(ax=ax, color='green', linewidth=2, alpha=0.7, label='Nearest Face')\n","    \n","    # Set labels and title\n","    ax.set_xlabel('X Coordinate')\n","    ax.set_ylabel('Y Coordinate')\n","    ax.set_title('Nearest Cell Face to Sample Point')\n","    \n","    # Add legend and grid\n","    ax.legend()\n","    ax.grid(True)\n","    \n","    # Adjust layout and display\n","    plt.tight_layout()\n","    plt.show()\n","else:\n","    print(\"Unable to perform nearest cell face search due to missing data.\")\n","\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Extract Cell Polygons\n","print(\"\\nExample 6: Extracting Cell Polygons\")\n","cell_polygons_df = HdfMesh.mesh_cell_polygons(geom_hdf_path, ras_object=bald_eagle)\n","if not cell_polygons_df.empty:\n","    display(cell_polygons_df.head())\n","else:\n","    print(\"No Cell Polygons found.\")\n","\n","# Plot cell polygons\n","if not cell_polygons_df.empty:\n","    fig, ax = plt.subplots(figsize=(12, 8))\n","    \n","    # Plot cell polygons\n","    cell_polygons_df.plot(ax=ax, edgecolor='blue', facecolor='none')\n","    \n","    # Set labels and title\n","    ax.set_xlabel('X Coordinate')\n","    ax.set_ylabel('Y Coordinate')\n","    ax.set_title('2D Flow Area Cell Polygons')\n","    \n","    # Add grid\n","    ax.grid(True)\n","    \n","    # Adjust layout and display\n","    plt.tight_layout()\n","    plt.show()\n","else:\n","    print(\"No cell polygon data available for plotting.\")"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example 5: Extract Cell Info\n","print(\"\\nExample 5: Extracting Cell Info\")\n","cell_info_df = HdfMesh.mesh_cell_points(geom_hdf_path, ras_object=bald_eagle)\n","if not cell_info_df.empty:\n","    display(cell_info_df.head())\n","else:\n","    print(\"No Cell Info found.\")\n","\n","# Plot cell centers\n","import matplotlib.pyplot as plt\n","\n","if not cell_info_df.empty:\n","    fig, ax = plt.subplots(figsize=(12, 8))\n","    \n","    # Plot cell centers\n","    cell_info_df.plot(ax=ax, color='red', markersize=5)\n","    \n","    # Set labels and title\n","    ax.set_xlabel('X Coordinate')\n","    ax.set_ylabel('Y Coordinate')\n","    ax.set_title('2D Flow Area Cell Centers')\n","    \n","    # Add grid\n","    ax.grid(True)\n","    \n","    # Adjust layout and display\n","    plt.tight_layout()\n","    plt.show()\n","else:\n","    print(\"No cell data available for plotting.\")\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Provide function that will accept a geopandas point object and will find the nearest cell center\n","# Function to find the nearest cell center to a given point\n","def find_nearest_cell(point, cell_centers_df):\n","    \"\"\"\n","    Find the nearest cell center to a given point.\n","\n","    Args:\n","        point (shapely.geometry.Point): The input point.\n","        cell_centers_df (GeoDataFrame): DataFrame containing cell center points.\n","\n","    Returns:\n","        int: The cell_id of the nearest cell.\n","        float: The distance to the nearest cell center.\n","    \"\"\"\n","    # Calculate distances from the input point to all cell centers\n","    distances = cell_centers_df.geometry.distance(point)\n","\n","    # Find the index of the minimum distance\n","    nearest_index = distances.idxmin()\n","\n","    # Get the cell_id and distance of the nearest cell\n","    nearest_cell_id = cell_centers_df.loc[nearest_index, 'cell_id']\n","    nearest_distance = distances[nearest_index]\n","\n","    return nearest_cell_id, nearest_distance\n","\n","# Example usage\n","print(\"\\nExample: Finding the nearest cell to a given point\")\n","\n","# Create a sample point (you can replace this with any point of interest)\n","from shapely.geometry import Point\n","from geopandas import GeoDataFrame\n","\n","# Get the projection from the geometry file\n","projection = HdfUtils.projection(hdf_path=geom_hdf_path)\n","if projection:\n","    print(f\"Using projection: {projection}\")\n","else:\n","    print(\"No projection information found. Using default CRS.\")\n","    projection = \"EPSG:4326\"  # Default to WGS84 if no projection is found\n","\n","# Create the sample point with the correct CRS\n","sample_point = GeoDataFrame({'geometry': [Point(2083500, 370800)]}, crs=projection)\n","\n","if not cell_info_df.empty and not sample_point.empty:\n","    # Ensure the CRS of the sample point matches the cell_info_df\n","    if sample_point.crs != cell_info_df.crs:\n","        sample_point = sample_point.to_crs(cell_info_df.crs)\n","    \n","    nearest_cell_id, distance = find_nearest_cell(sample_point.geometry.iloc[0], cell_info_df)\n","    print(f\"Nearest cell to point {sample_point.geometry.iloc[0].coords[0]}:\")\n","    print(f\"Cell ID: {nearest_cell_id}\")\n","    print(f\"Distance: {distance:.2f} units\")\n","\n","    # Visualize the result\n","    fig, ax = plt.subplots(figsize=(12, 8))\n","    \n","    # Plot all cell centers\n","    cell_info_df.plot(ax=ax, color='blue', markersize=5, alpha=0.5, label='Cell Centers')\n","    \n","    # Plot the sample point\n","    sample_point.plot(ax=ax, color='red', markersize=100, alpha=0.7, label='Sample Point')\n","    \n","    # Plot the nearest cell center\n","    nearest_cell = cell_info_df[cell_info_df['cell_id'] == nearest_cell_id]\n","    nearest_cell.plot(ax=ax, color='green', markersize=100, alpha=0.7, label='Nearest Cell')\n","    \n","    # Set labels and title\n","    ax.set_xlabel('X Coordinate')\n","    ax.set_ylabel('Y Coordinate')\n","    ax.set_title('Nearest Cell to Sample Point')\n","    \n","    # Add legend and grid\n","    ax.legend()\n","    ax.grid(True)\n","    \n","    # Adjust layout and display\n","    plt.tight_layout()\n","    plt.show()\n","else:\n","    print(\"Unable to perform nearest cell search due to missing data.\")\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get geometry structures attributes\n","print(\"\\nGetting geometry structures attributes\")\n","geom_structures_attrs = HdfStruc.get_geom_structures_attrs(geom_hdf_path, ras_object=bald_eagle)\n","if geom_structures_attrs:\n","    print(\"Geometry structures attributes:\")\n","    for key, value in geom_structures_attrs.items():\n","        print(f\"{key}: {value}\")\n","else:\n","    print(\"No geometry structures attributes found.\")"]},{"cell_type":"code","execution_count":27,"metadata":{},"outputs":[],"source":["# TODO: Paths and Functions for each type of structure: \n","\n","# Getting geometry structures attributes\n","# Geometry structures attributes:\n","# Bridge/Culvert Count: 0\n","# Connection Count: 4\n","# Has Bridge Opening (2D): 0\n","# Inline Structure Count: 0\n","# Lateral Structure Count: 0"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Extract Boundary Condition Lines and Plot with 2D Flow Area Perimeter Polygons\n","print(\"\\nExample 7: Extracting Boundary Condition Lines and Plotting with 2D Flow Area Perimeter Polygons\")\n","bc_lines_df = HdfBndry.bc_lines(geom_hdf_path, ras_object=bald_eagle)\n","if not bc_lines_df.empty:\n","    display(bc_lines_df.head())\n","else:\n","    print(\"No Boundary Condition Lines found.\")\n","\n","# Plot if data exists\n","if not bc_lines_df.empty or not mesh_areas.empty:\n","    fig, ax = plt.subplots(figsize=(12, 8))\n","    \n","    # Plot 2D Flow Area Perimeter Polygons\n","    if not mesh_areas.empty:\n","        mesh_areas.plot(ax=ax, edgecolor='black', facecolor='none', alpha=0.7, label='2D Flow Area')\n","        \n","        # Add labels for each polygon\n","        for idx, row in mesh_areas.iterrows():\n","            centroid = row.geometry.centroid\n","            label = row.get('Name', f'Area {idx}')\n","            ax.annotate(label, (centroid.x, centroid.y), ha='center', va='center')\n","    \n","    # Plot boundary condition lines\n","    if not bc_lines_df.empty:\n","        bc_lines_df.plot(ax=ax, color='red', linewidth=2, label='Boundary Condition Lines')\n","    \n","    # Set labels and title\n","    ax.set_xlabel('Easting')\n","    ax.set_ylabel('Northing')\n","    ax.set_title('2D Flow Area Perimeter Polygons and Boundary Condition Lines')\n","    \n","    # Add grid and legend\n","    ax.grid(True)\n","    ax.legend()\n","    \n","    # Adjust layout and display\n","    plt.tight_layout()\n","    plt.show()\n","else:\n","    print(\"No data available for plotting.\")"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Extract Breaklines and Plot with 2D Flow Area Perimeter Polygons\n","print(\"\\nExample 8: Extracting Breaklines and Plotting with 2D Flow Area Perimeter Polygons\")\n","breaklines_df = HdfBndry.breaklines(geom_hdf_path, ras_object=bald_eagle)\n","if not breaklines_df.empty:\n","    display(breaklines_df.head())\n","else:\n","    print(\"No Breaklines found.\")\n","\n","# Plot breaklines and 2D Flow Area Perimeter Polygons if they exist\n","if not breaklines_df.empty or not mesh_areas.empty:\n","    fig, ax = plt.subplots(figsize=(12, 8))\n","    \n","    # Plot 2D Flow Area Perimeter Polygons\n","    if not mesh_areas.empty:\n","        mesh_areas.plot(ax=ax, edgecolor='black', facecolor='none', alpha=0.7, label='2D Flow Area')\n","        \n","        # Add labels for each polygon\n","        for idx, row in mesh_areas.iterrows():\n","            centroid = row.geometry.centroid\n","            label = row.get('Name', f'Area {idx}')\n","            ax.annotate(label, (centroid.x, centroid.y), ha='center', va='center')\n","    \n","    # Plot breaklines\n","    if not breaklines_df.empty:\n","        breaklines_df.plot(ax=ax, color='blue', linewidth=2, label='Breaklines')\n","    \n","    # Set labels and title\n","    ax.set_xlabel('Easting')\n","    ax.set_ylabel('Northing')\n","    ax.set_title('2D Flow Area Perimeter Polygons and Breaklines')\n","    \n","    # Add grid and legend\n","    ax.grid(True)\n","    ax.legend()\n","    \n","    # Adjust layout and display\n","    plt.tight_layout()\n","    plt.show()\n","else:\n","    print(\"No data available for plotting.\")"]},{"cell_type":"code","execution_count":30,"metadata":{},"outputs":[],"source":["# INSTEAD OF hdf_input, USE plan_hdf_path or geom_hdf_path as appropriate "]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get structures\n","structures_gdf = HdfStruc.structures(geom_hdf_path, ras_object=bald_eagle)\n","print(\"Structures:\")\n","if not structures_gdf.empty:\n","    display(structures_gdf.head())\n","else:\n","    print(\"No structures found in the geometry file.\")"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get reference line names\n","ref_line_names = HdfBndry.reference_lines_names(geom_hdf_path, ras_object=bald_eagle)\n","print(\"\\nReference Line Names:\")\n","print(ref_line_names)"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get reference point names\n","ref_point_names = HdfBndry.reference_points_names(geom_hdf_path, ras_object=bald_eagle)\n","print(\"\\nReference Point Names:\")\n","print(ref_point_names)"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get reference lines\n","ref_lines_gdf = HdfBndry.reference_lines(geom_hdf_path, ras_object=bald_eagle)\n","print(\"\\nReference Lines:\")\n","if not ref_lines_gdf.empty:\n","    display(ref_lines_gdf.head())\n","else:\n","    print(\"No reference lines found in the geometry file.\")"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get reference points\n","ref_points_gdf = HdfBndry.reference_points(geom_hdf_path, ras_object=bald_eagle)\n","print(\"\\nReference Points:\")\n","if not ref_points_gdf.empty:\n","    display(ref_points_gdf.head())\n","else:\n","    print(\"No reference points found in the geometry file.\")"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get cross sections\n","cross_sections_gdf = HdfXsec.cross_sections(geom_hdf_path, ras_object=bald_eagle)\n","print(\"\\nCross Sections:\")\n","if not cross_sections_gdf.empty:\n","    display(cross_sections_gdf.head())\n","else:\n","    print(\"No cross sections found in the geometry file.\")"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get river reaches\n","river_reaches_gdf = HdfXsec.river_reaches(geom_hdf_path, ras_object=bald_eagle)\n","print(\"\\nRiver Reaches:\")\n","if not river_reaches_gdf.empty:\n","    display(river_reaches_gdf.head())\n","else:\n","    print(\"No river reaches found in the geometry file.\")\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get cross sections elevations\n","cross_sections_elevations_df = HdfXsec.cross_sections_elevations(geom_hdf_path, ras_object=bald_eagle)\n","print(\"\\nCross Sections Elevations:\")\n","if not cross_sections_elevations_df.empty:\n","    display(cross_sections_elevations_df.head())\n","else:\n","    print(\"No cross section elevation data found in the geometry file.\")\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Extract Refinement Regions\n","print(\"\\nExample: Extracting Refinement Regions\")\n","\n","# Make sure to pass the bald_eagle object as the ras_object parameter\n","refinement_regions_df = HdfBndry.refinement_regions(geom_hdf_path, ras_object=bald_eagle)\n","\n","if not refinement_regions_df.empty:\n","    print(\"Refinement Regions DataFrame:\")\n","    display(refinement_regions_df.head())\n","    \n","    # Plot refinement regions\n","    fig, ax = plt.subplots(figsize=(12, 8))\n","    refinement_regions_df.plot(ax=ax, column='CellSize', legend=True, \n","                               legend_kwds={'label': 'Cell Size', 'orientation': 'horizontal'},\n","                               cmap='viridis')\n","    ax.set_title('2D Mesh Area Refinement Regions')\n","    ax.set_xlabel('Easting')\n","    ax.set_ylabel('Northing')\n","    plt.tight_layout()\n","    plt.show()\n","else:\n","    print(\"No refinement regions found in the geometry file.\")\n","\n","# Example: Analyze Refinement Regions\n","if not refinement_regions_df.empty:\n","    print(\"\\nRefinement Regions Analysis:\")\n","    print(f\"Total number of refinement regions: {len(refinement_regions_df)}\")\n","    print(\"\\nCell Size Statistics:\")\n","    print(refinement_regions_df['CellSize'].describe())\n","    \n","    # Group by Shape Type\n","    shape_type_counts = refinement_regions_df['ShapeType'].value_counts()\n","    print(\"\\nRefinement Region Shape Types:\")\n","    print(shape_type_counts)\n","    \n","    # Plot Shape Type distribution\n","    plt.figure(figsize=(10, 6))\n","    shape_type_counts.plot(kind='bar')\n","    plt.title('Distribution of Refinement Region Shape Types')\n","    plt.xlabel('Shape Type')\n","    plt.ylabel('Count')\n","    plt.xticks(rotation=45)\n","    plt.tight_layout()\n","    plt.show()"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Extract Compute Messages as String\n","print(\"Extracting Compute Messages\")\n","\n","import h5py\n","import numpy as np\n","\n","def extract_string_from_hdf(results_hdf_filename: str, hdf_path: str) -> str:\n","    \"\"\"\n","    Extract string from HDF object at a given path\n","\n","    Parameters\n","    ----------\n","    results_hdf_filename : str\n","        Name of the HDF file\n","    hdf_path : str\n","        Path of the object in the HDF file\n","\n","    Returns\n","    -------\n","    str\n","        Extracted string from the specified HDF object\n","    \"\"\"\n","    with h5py.File(results_hdf_filename, 'r') as hdf_file:\n","        try:\n","            hdf_object = hdf_file[hdf_path]\n","            if isinstance(hdf_object, h5py.Group):\n","                return f\"Group: {hdf_path}\\nContents: {list(hdf_object.keys())}\"\n","            elif isinstance(hdf_object, h5py.Dataset):\n","                data = hdf_object[()]\n","                if isinstance(data, bytes):\n","                    return data.decode('utf-8')\n","                elif isinstance(data, np.ndarray) and data.dtype.kind == 'S':\n","                    return [v.decode('utf-8') for v in data]\n","                else:\n","                    return str(data)\n","            else:\n","                return f\"Unsupported object type: {type(hdf_object)}\"\n","        except KeyError:\n","            return f\"Path not found: {hdf_path}\"\n","\n","try:\n","    results_summary_string = extract_string_from_hdf(plan_hdf_path, '/Results/Summary/Compute Messages (text)')\n","    print(\"Compute Messages:\")\n","    \n","    # Parse and print the compute messages in a more visually friendly way\n","    messages = results_summary_string[0].split('\\r\\n')\n","    \n","    for message in messages:\n","        if message.strip():  # Skip empty lines\n","            if ':' in message:\n","                key, value = message.split(':', 1)\n","                print(f\"{key.strip():40} : {value.strip()}\")\n","            else:\n","                print(f\"\\n{message.strip()}\")\n","    \n","    # Print computation summary in a table format\n","    print(\"\\nComputation Summary:\")\n","    print(\"-\" * 50)\n","    print(f\"{'Computation Task':<30} {'Time':<20}\")\n","    print(\"-\" * 50)\n","    for line in messages:\n","        if 'Computation Task' in line:\n","            task, time = line.split('\\t')\n","            print(f\"{task:<30} {time:<20}\")\n","    \n","    print(\"\\nComputation Speed:\")\n","    print(\"-\" * 50)\n","    print(f\"{'Task':<30} {'Simulation/Runtime':<20}\")\n","    print(\"-\" * 50)\n","    for line in messages:\n","        if 'Computation Speed' in line:\n","            task, speed = line.split('\\t')\n","            print(f\"{task:<30} {speed:<20}\")\n","\n","except Exception as e:\n","    print(f\"Error extracting compute messages: {str(e)}\")\n","    print(\"\\nNote: If 'Results/Summary Output' is not in the file structure, it might indicate that the simulation didn't complete successfully or the results weren't saved properly.\")\n","\n"," \n","\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Advanced Compute Messages Example - TODO: Move this function into a class of the library \n","import pandas as pd\n","import re\n","import matplotlib.pyplot as plt\n","import geopandas as gpd\n","import logging\n","\n","# Configure logging\n","logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n","\n","def parse_2d_compute_messages(compute_messages):\n","    \"\"\"\n","    Parse 2D compute messages to extract data lines, clean the data, \n","    and retrieve top 20 cells with the highest error.\n","\n","    Parameters:\n","        compute_messages (list or str): The raw compute messages.\n","\n","    Returns:\n","        tuple: A tuple containing the parsed compute messages string and the main DataFrame.\n","    \"\"\"\n","    try:\n","        # Handle both list and string inputs\n","        if isinstance(compute_messages, list):\n","            compute_messages = '\\n'.join(compute_messages)\n","        elif not isinstance(compute_messages, str):\n","            logging.error(f\"Unexpected type for compute_messages: {type(compute_messages)}\")\n","            return \"\", pd.DataFrame()\n","\n","        # Split the message into lines\n","        lines = compute_messages.split('\\n')\n","        logging.info(\"Successfully split compute messages into lines.\")\n","        \n","        # Initialize lists to store parsed data\n","        data_lines = []\n","        header_lines = []\n","        footer_lines = []\n","        \n","        # Regular expression to match timestamp lines\n","        timestamp_pattern = re.compile(r'^\\d{2}[A-Z]{3}\\d{4}\\s+\\d{2}:\\d{2}:\\d{2}')\n","        logging.debug(\"Compiled timestamp regular expression.\")\n","        \n","        data_started = False\n","        for line in lines:\n","            stripped_line = line.strip()\n","            if timestamp_pattern.match(stripped_line):\n","                data_started = True\n","                # Split the line and add to data_lines\n","                parts = stripped_line.split()\n","                if len(parts) >= 8:  # Ensure we have all expected columns\n","                    # Combine Date and Time into 'Date and Time'\n","                    date_time = f\"{parts[0]} {parts[1]}\"\n","                    location = parts[2]\n","                    cell_type = f\"{parts[3]} {parts[4]}\"\n","                    cell_number = parts[5]\n","                    wsel = parts[6]\n","                    error = parts[7]\n","                    iterations = parts[8] if len(parts) > 8 else None\n","                    data_lines.append([date_time, location, cell_type, cell_number, wsel, error, iterations])\n","                    logging.debug(f\"Parsed data line: {data_lines[-1]}\")\n","                else:\n","                    logging.warning(f\"Line skipped due to insufficient parts: {stripped_line}\")\n","            elif not data_started:\n","                header_lines.append(stripped_line)\n","            elif data_started and not stripped_line:\n","                data_started = False\n","            elif not data_started:\n","                footer_lines.append(stripped_line)\n","        \n","        # Create DataFrame from data lines\n","        df = pd.DataFrame(\n","            data_lines, \n","            columns=['Date and Time', 'Location', 'Cell Type', 'Cell Number', 'WSEL', 'ERROR', 'ITERATIONS']\n","        )\n","        logging.info(\"Created DataFrame from parsed data lines.\")\n","        \n","        # Clean and convert columns to appropriate types\n","        df['Cell Number'] = (\n","            pd.to_numeric(df['Cell Number'].replace('#', pd.NA), errors='coerce')\n","            .fillna(-1)\n","            .astype('Int64')\n","        )\n","        df['WSEL'] = pd.to_numeric(df['WSEL'], errors='coerce')\n","        df['ERROR'] = pd.to_numeric(df['ERROR'], errors='coerce')\n","        df['ITERATIONS'] = pd.to_numeric(df['ITERATIONS'], errors='coerce').astype('Int64')\n","        logging.info(\"Converted DataFrame columns to appropriate types.\")\n","        \n","        # Get top 20 cells with highest error\n","        top_20_cells = (\n","            df.sort_values('ERROR', ascending=False)\n","            .drop_duplicates('Cell Number')\n","            .head(20)\n","        )\n","        \n","        # Construct the reordered message\n","        reordered_message = '\\n'.join(header_lines + \n","                                      ['\\nTop 20 Cells with Highest Error:'] + \n","                                      [' '.join(map(str, row)) for row in top_20_cells.values] + \n","                                      ['\\n'] + footer_lines)\n","        \n","        logging.info(\"Reordered compute messages.\")\n","        \n","        return reordered_message, df\n","    except Exception as e:\n","        logging.error(f\"Error parsing compute messages: {e}\")\n","        return \"\", pd.DataFrame()\n","\n","# Use the function to parse compute messages\n","parsed_messages, df = parse_2d_compute_messages(results_summary_string)\n","\n","print(parsed_messages)\n","print(df)\n","\n","# Get top 20 cells with highest error\n","if not df.empty and 'ERROR' in df.columns:\n","    top_20_cells = (\n","        df.sort_values('ERROR', ascending=False)\n","        .drop_duplicates('Cell Number')\n","        .head(20)\n","    )\n","else:\n","    logging.warning(\"Unable to get top 20 cells with highest error. DataFrame is empty or 'ERROR' column is missing.\")\n","    top_20_cells = pd.DataFrame()\n","\n","# Example: Get 2D Flow Area Perimeter Polygons (mesh_areas)\n","print(\"\\nExample: Extracting 2D Flow Area Perimeter Polygons\")\n","mesh_areas = HdfMesh.mesh_areas(geom_hdf_path, ras_object=bald_eagle)\n","\n","print(\"\\n2D Flow Area Groups and Perimeters:\")\n","if not mesh_areas.empty:\n","    print(\"Available columns:\", mesh_areas.columns.tolist())\n","    \n","    # Display the first few rows of the mesh_areas DataFrame\n","    print(\"\\nFirst few rows of mesh_areas DataFrame:\")\n","    display(mesh_areas.head())\n","else:\n","    print(\"No 2D Flow Area groups found in the HDF file.\")\n","\n","# Use the previously extracted cell_polygons_df\n","print(\"\\nTop 20 Cell Polygons:\")\n","if 'cell_polygons_df' in locals() and not cell_polygons_df.empty and not top_20_cells.empty:\n","    # Get the cell numbers from top_20_cells\n","    top_20_cell_numbers = top_20_cells['Cell Number'].tolist()\n","    \n","    # Filter cell_polygons_df to only include top 20 cells\n","    top_20_cell_polygons = cell_polygons_df[cell_polygons_df['cell_id'].isin(top_20_cell_numbers)]\n","    \n","    display(top_20_cell_polygons)\n","\n","    # Plot top 20 cell polygons and mesh areas\n","    fig, ax = plt.subplots(figsize=(12, 8))\n","    \n","    # Plot mesh areas\n","    mesh_areas.plot(ax=ax, edgecolor='red', facecolor='none', alpha=0.5, label='Mesh Areas')\n","    \n","    # Plot top 20 cell polygons\n","    top_20_cell_polygons.plot(ax=ax, edgecolor='blue', facecolor='none', alpha=0.7, label='Top 20 Error Cells')\n","    \n","    # Set labels and title\n","    ax.set_xlabel('X Coordinate')\n","    ax.set_ylabel('Y Coordinate')\n","    ax.set_title('2D Flow Area Perimeters and Top 20 Cell Polygons')\n","    \n","    # Add legend\n","    ax.legend()\n","    \n","    # Add grid\n","    ax.grid(True)\n","    \n","    # Adjust layout and display\n","    plt.tight_layout()\n","    plt.show()\n","else:\n","    print(\"No Cell Polygons found or no top 20 cells with highest error available.\")\n","    print(\"Unable to plot cell polygons.\")"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Exploratory Example for Debugging or New Features: List all paths, groups, and attributes under \"/Results/Unsteady/Summary/Volume Accounting\"\n","print(\"\\nListing paths, groups, and attributes under '/Results/Unsteady/Summary/Volume Accounting'\")\n","\n","from ras_commander import HdfUtils\n","\n","def list_hdf_structure(hdf_path: str, group_path: str) -> None:\n","    with h5py.File(hdf_path, 'r') as hdf:\n","        if group_path not in hdf:\n","            print(f\"Group '{group_path}' not found in the HDF file.\")\n","            return\n","\n","        def print_group_structure(name: str, obj: h5py.Group) -> None:\n","            indent = '  ' * name.count('/')\n","            if isinstance(obj, h5py.Group):\n","                print(f\"{indent}{name} (Group)\")\n","                for attr_name, attr_value in obj.attrs.items():\n","                    print(f\"{indent}  Attribute: {attr_name} = {attr_value}\")\n","            elif isinstance(obj, h5py.Dataset):\n","                print(f\"{indent}{name} (Dataset)\")\n","                for attr_name, attr_value in obj.attrs.items():\n","                    print(f\"{indent}  Attribute: {attr_name} = {attr_value}\")\n","\n","        hdf[group_path].visititems(print_group_structure)\n","\n","try:\n","    list_hdf_structure(plan_hdf_path, \"/Results/Unsteady/Summary/Volume Accounting\")\n","except Exception as e:\n","    print(f\"An error occurred while listing HDF structure: {str(e)}\")\n","\n","# Additional error handling and logging\n","logger = logging.getLogger(__name__)\n","logger.info(\"Finished listing HDF structure for Volume Accounting\")\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example 12: Extract Plan Parameters and Volume Accounting\n","print(\"\\nExample 12: Extracting Plan Parameters and Volume Accounting Data\")\n","\n","# Extract plan parameters\n","plan_parameters_df = HdfPlan.get_plan_param_attrs(plan_hdf_path)\n","\n","# Extract volume accounting data\n","volume_accounting_df = HdfResultsPlan.get_results_volume_accounting_attrs(plan_hdf_path)\n","\n","print(\"\\nPlan Parameters DataFrame:\")\n","display(plan_parameters_df)\n","\n","print(\"\\nVolume Accounting DataFrame:\")\n","display(volume_accounting_df)"]},{"cell_type":"markdown","metadata":{},"source":["# RasPlanHdf Class Functions"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get simulation start time\n","start_time = HdfPlan.get_simulation_start_time(plan_hdf_path)\n","print(f\"Simulation start time: {start_time}\")"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get simulation end time\n","end_time = HdfPlan.get_simulation_end_time(plan_hdf_path)\n","print(f\"Simulation end time: {end_time}\")"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Extract 2D Flow Area Attributes \n","print(\"\\nExample 4: Extracting 2D Flow Area Attributes\")\n","flow_area_attributes = HdfMesh.get_geom_2d_flow_area_attrs(geom_hdf_path, ras_object=bald_eagle)\n","if flow_area_attributes:\n","    # Convert the dictionary to a DataFrame for better display\n","    flow_area_attributes_df = pd.DataFrame([flow_area_attributes])\n","    display(flow_area_attributes_df)\n","else:\n","    print(\"No 2D Flow Area attributes found.\")"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get mesh max iterations\n","max_iter_df = HdfResultsMesh.mesh_max_iter(plan_hdf_path)\n","print(\"\\nMesh Max Iterations:\")\n","print(max_iter_df.attrs)\n","display(max_iter_df.head())"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Using mesh_max_iter, get the cell coordinates and plot the max iterations as a map\n","import matplotlib.pyplot as plt\n","from ras_commander.HdfMesh import HdfMesh\n","from ras_commander.HdfResultsMesh import HdfResultsMesh\n","from shapely.geometry import Point\n","\n","# Get mesh max iterations\n","max_iter_df = HdfResultsMesh.mesh_max_iter(plan_hdf_path)\n","\n","# Get cell coordinates\n","cell_coords = HdfMesh.mesh_cell_points(plan_hdf_path)\n","\n","# Merge max iterations with cell coordinates\n","merged_df = pd.merge(max_iter_df, cell_coords, on=['mesh_name', 'cell_id'])\n","\n","# Extract x and y coordinates from the geometry column\n","merged_df['x'] = merged_df['geometry'].apply(lambda geom: geom.x)\n","merged_df['y'] = merged_df['geometry'].apply(lambda geom: geom.y)\n","\n","# Check if 'x' and 'y' columns exist in merged_df\n","if 'x' not in merged_df.columns or 'y' not in merged_df.columns:\n","    print(\"Error: 'x' or 'y' columns not found in the merged dataframe.\")\n","    print(\"Available columns:\", merged_df.columns.tolist())\n","else:\n","    # Create the plot\n","    fig, ax = plt.subplots(figsize=(12, 8))\n","    scatter = ax.scatter(merged_df['x'], merged_df['y'], c=merged_df['cell_last_iteration'], cmap='viridis', s=1)\n","\n","    # Customize the plot\n","    ax.set_title('Max Iterations per Cell')\n","    ax.set_xlabel('X Coordinate')\n","    ax.set_ylabel('Y Coordinate')\n","    plt.colorbar(scatter, label='Max Iterations')\n","\n","    # Show the plot\n","    plt.show()\n","\n","# Print the first few rows of the merged dataframe for verification\n","print(\"\\nFirst few rows of the merged dataframe:\")\n","display(merged_df.head())"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get mesh max water surface\n","max_ws_df = HdfResultsMesh.mesh_max_ws(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nMesh Max Water Surface:\")\n","print(max_ws_df.attrs)\n","display(max_ws_df.head())"]},{"cell_type":"code","execution_count":50,"metadata":{},"outputs":[],"source":["# Show some statistics for the max_ws_df dataframe\n","\n","\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Using mesh_max_ws, get the cell coordinates and plot the max water surface as a map\n","import matplotlib.pyplot as plt\n","from ras_commander.HdfMesh import HdfMesh\n","from ras_commander.HdfResultsMesh import HdfResultsMesh\n","from shapely.geometry import Point\n","\n","# Get mesh max water surface\n","max_ws_df = HdfResultsMesh.mesh_max_ws(plan_hdf_path, ras_object=bald_eagle)\n","\n","# Get cell coordinates\n","cell_coords = HdfMesh.mesh_cell_points(plan_hdf_path)\n","\n","# Merge max water surface with cell coordinates\n","merged_df = pd.merge(max_ws_df, cell_coords, on=['mesh_name', 'cell_id'])\n","\n","# Extract x and y coordinates from the geometry column\n","merged_df['x'] = merged_df['geometry'].apply(lambda geom: geom.x)\n","merged_df['y'] = merged_df['geometry'].apply(lambda geom: geom.y)\n","\n","# Check if 'x' and 'y' columns exist in merged_df\n","if 'x' not in merged_df.columns or 'y' not in merged_df.columns:\n","    print(\"Error: 'x' or 'y' columns not found in the merged dataframe.\")\n","    print(\"Available columns:\", merged_df.columns.tolist())\n","else:\n","    # Create the plot\n","    fig, ax = plt.subplots(figsize=(12, 8))\n","    scatter = ax.scatter(merged_df['x'], merged_df['y'], c=merged_df['maximum_water_surface'], cmap='viridis', s=10)\n","\n","    # Customize the plot\n","    ax.set_title('Max Water Surface per Cell')\n","    ax.set_xlabel('X Coordinate')\n","    ax.set_ylabel('Y Coordinate')\n","    plt.colorbar(scatter, label='Max Water Surface (ft)')\n","\n","    # Add grid lines\n","    ax.grid(True, linestyle='--', alpha=0.7)\n","\n","    # Increase font size for better readability\n","    plt.rcParams.update({'font.size': 12})\n","\n","    # Adjust layout to prevent cutting off labels\n","    plt.tight_layout()\n","\n","    # Show the plot\n","    plt.show()\n","\n","# Print the first few rows of the merged dataframe for verification\n","print(\"\\nFirst few rows of the merged dataframe:\")\n","display(merged_df.head())"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Plot the time of the max water surface elevation (WSEL)\n","\n","import matplotlib.pyplot as plt\n","import matplotlib.dates as mdates\n","from datetime import datetime\n","\n","# Convert the 'maximum_water_surface_time' to datetime objects first\n","merged_df['max_wsel_time'] = pd.to_datetime(merged_df['maximum_water_surface_time'])\n","\n","# Create the plot\n","fig, ax = plt.subplots(figsize=(12, 8))\n","\n","# Convert datetime to hours since the start for colormap\n","min_time = merged_df['max_wsel_time'].min()\n","color_values = (merged_df['max_wsel_time'] - min_time).dt.total_seconds() / 3600  # Convert to hours\n","\n","scatter = ax.scatter(merged_df['x'], merged_df['y'], \n","                     c=color_values, \n","                     cmap='viridis', \n","                     s=10)\n","\n","# Customize the plot\n","ax.set_title('Time of Maximum Water Surface Elevation per Cell')\n","ax.set_xlabel('X Coordinate')\n","ax.set_ylabel('Y Coordinate')\n","\n","# Set up the colorbar\n","cbar = plt.colorbar(scatter)\n","cbar.set_label('Hours since simulation start')\n","\n","# Format the colorbar ticks to show hours\n","cbar.set_ticks(range(0, int(color_values.max()) + 1, 6))  # Set ticks every 6 hours\n","cbar.set_ticklabels([f'{h}h' for h in range(0, int(color_values.max()) + 1, 6)])\n","\n","# Add grid lines\n","ax.grid(True, linestyle='--', alpha=0.7)\n","\n","# Increase font size for better readability\n","plt.rcParams.update({'font.size': 12})\n","\n","# Adjust layout to prevent cutting off labels\n","plt.tight_layout()\n","\n","# Show the plot\n","plt.show()\n","\n","\n","# Find the overall maximum WSEL and its time\n","max_wsel_row = merged_df.loc[merged_df['maximum_water_surface'].idxmax()]\n","hours_since_start = (max_wsel_row['max_wsel_time'] - min_time).total_seconds() / 3600\n","print(f\"\\nOverall Maximum WSEL: {max_wsel_row['maximum_water_surface']:.2f} ft\")\n","print(f\"Time of Overall Maximum WSEL: {max_wsel_row['max_wsel_time']}\")\n","print(f\"Hours since simulation start: {hours_since_start:.2f} hours\")\n","print(f\"Location of Overall Maximum WSEL: X={max_wsel_row['x']}, Y={max_wsel_row['y']}\")\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get mesh min water surface\n","min_ws_df = HdfResultsMesh.mesh_min_ws(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nMesh Min Water Surface:\")\n","display(min_ws_df.head())"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get mesh max face velocity\n","max_face_v_df = HdfResultsMesh.mesh_max_face_v(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nMesh Max Face Velocity:\")\n","display(max_face_v_df.head())"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Plot max face velocity\n","import matplotlib.pyplot as plt\n","from ras_commander.HdfMesh import HdfMesh\n","from ras_commander.HdfResultsMesh import HdfResultsMesh\n","from shapely.geometry import Point\n","\n","# Get mesh max face velocity\n","max_face_v_df = HdfResultsMesh.mesh_max_face_v(plan_hdf_path, ras_object=bald_eagle)\n","\n","# Get cell coordinates\n","cell_coords = HdfMesh.mesh_cell_points(plan_hdf_path)\n","\n","# Merge max face velocity with cell coordinates\n","merged_df = pd.merge(max_face_v_df, cell_coords, on=['mesh_name', 'cell_id'])\n","\n","# Extract x and y coordinates from the geometry column\n","merged_df['x'] = merged_df['geometry'].apply(lambda geom: geom.x)\n","merged_df['y'] = merged_df['geometry'].apply(lambda geom: geom.y)\n","\n","# Check if 'x' and 'y' columns exist in merged_df\n","if 'x' not in merged_df.columns or 'y' not in merged_df.columns:\n","    print(\"Error: 'x' or 'y' columns not found in the merged dataframe.\")\n","    print(\"Available columns:\", merged_df.columns.tolist())\n","else:\n","    # Create the plot\n","    fig, ax = plt.subplots(figsize=(12, 8))\n","    scatter = ax.scatter(merged_df['x'], merged_df['y'], c=merged_df['maximum_face_velocity'].abs(), cmap='viridis', s=10)\n","\n","    # Customize the plot\n","    ax.set_title('Max Face Velocity per Cell')\n","    ax.set_xlabel('X Coordinate')\n","    ax.set_ylabel('Y Coordinate')\n","    plt.colorbar(scatter, label='Max Face Velocity (ft/s)')\n","\n","    # Add grid lines\n","    ax.grid(True, linestyle='--', alpha=0.7)\n","\n","    # Increase font size for better readability\n","    plt.rcParams.update({'font.size': 12})\n","\n","    # Adjust layout to prevent cutting off labels\n","    plt.tight_layout()\n","\n","    # Show the plot\n","    plt.show()\n","\n","# Print the first few rows of the merged dataframe for verification\n","print(\"\\nFirst few rows of the merged dataframe:\")\n","display(merged_df.head())"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get mesh min face velocity\n","min_face_v_df = HdfResultsMesh.mesh_min_face_v(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nMesh Min Face Velocity:\")\n","display(min_face_v_df.head())"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get mesh max water surface error\n","try:\n","    max_ws_err_df = HdfResultsMesh.mesh_max_ws_err(plan_hdf_path, ras_object=bald_eagle)\n","    print(\"\\nMesh Max Water Surface Error:\")\n","    display(max_ws_err_df.head())\n","except Exception as e:\n","    print(f\"Error: {str(e)}\")\n","    logger.error(f\"Failed to get mesh max water surface error: {str(e)}\")"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Plot max water surface error\n","import matplotlib.pyplot as plt\n","from ras_commander.HdfMesh import HdfMesh\n","from ras_commander.HdfResultsMesh import HdfResultsMesh\n","from shapely.geometry import Point\n","\n","# Get mesh max water surface error\n","max_ws_err_df = HdfResultsMesh.mesh_max_ws_err(plan_hdf_path, ras_object=bald_eagle)\n","\n","# Get cell coordinates\n","cell_coords = HdfMesh.mesh_cell_points(plan_hdf_path)\n","\n","# Merge max water surface error with cell coordinates\n","merged_df = pd.merge(max_ws_err_df, cell_coords, on=['mesh_name', 'cell_id'])\n","\n","# Extract x and y coordinates from the geometry column\n","merged_df['x'] = merged_df['geometry'].apply(lambda geom: geom.x)\n","merged_df['y'] = merged_df['geometry'].apply(lambda geom: geom.y)\n","\n","# Check if 'x' and 'y' columns exist in merged_df\n","if 'x' not in merged_df.columns or 'y' not in merged_df.columns:\n","    print(\"Error: 'x' or 'y' columns not found in the merged dataframe.\")\n","    print(\"Available columns:\", merged_df.columns.tolist())\n","else:\n","    # Create the plot\n","    fig, ax = plt.subplots(figsize=(12, 8))\n","    scatter = ax.scatter(merged_df['x'], merged_df['y'], c=merged_df['cell_maximum_water_surface_error'], cmap='viridis', s=10)\n","\n","    # Customize the plot\n","    ax.set_title('Max Water Surface Error per Cell')\n","    ax.set_xlabel('X Coordinate')\n","    ax.set_ylabel('Y Coordinate')\n","    plt.colorbar(scatter, label='Max Water Surface Error (ft)')\n","\n","    # Add grid lines\n","    ax.grid(True, linestyle='--', alpha=0.7)\n","\n","    # Increase font size for better readability\n","    plt.rcParams.update({'font.size': 12})\n","\n","    # Adjust layout to prevent cutting off labels\n","    plt.tight_layout()\n","\n","    # Show the plot\n","    plt.show()\n","\n","# Print the first few rows of the merged dataframe for verification\n","print(\"\\nFirst few rows of the merged dataframe:\")\n","display(merged_df.head())"]},{"cell_type":"markdown","metadata":{},"source":["### Need to add this to the ras-commander library"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get mesh summary output for other Datasets (here we retrieve Maximum Face Courant)\n","try:\n","    max_courant_df = HdfResultsMesh.mesh_summary_output(plan_hdf_path, var=\"Maximum Face Courant\", ras_object=bald_eagle)\n","    print(\"\\nMesh Summary Output (Maximum Courant):\")\n","    print(max_courant_df.attrs)\n","    display(max_courant_df.head())\n","except Exception as e:\n","    print(f\"Error: {str(e)}\")\n","    logger.error(f\"Failed to get mesh summary output: {str(e)}\")\n","    # Additional error handling or logging can be added here"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Plot max Courant number\n","import matplotlib.pyplot as plt\n","from ras_commander.HdfMesh import HdfMesh\n","from ras_commander.HdfResultsMesh import HdfResultsMesh\n","from shapely.geometry import Point\n","\n","# Get mesh max Courant number\n","max_courant_df = HdfResultsMesh.mesh_summary_output(plan_hdf_path, var=\"Maximum Face Courant\", ras_object=bald_eagle)\n","\n","# Get cell coordinates\n","cell_coords = HdfMesh.mesh_cell_points(plan_hdf_path)\n","\n","# Merge max Courant number with cell coordinates\n","merged_df = pd.merge(max_courant_df, cell_coords, on=['mesh_name', 'cell_id'])\n","\n","# Extract x and y coordinates from the geometry column\n","merged_df['x'] = merged_df['geometry'].apply(lambda geom: geom.x)\n","merged_df['y'] = merged_df['geometry'].apply(lambda geom: geom.y)\n","\n","# Check if 'x' and 'y' columns exist in merged_df\n","if 'x' not in merged_df.columns or 'y' not in merged_df.columns:\n","    print(\"Error: 'x' or 'y' columns not found in the merged dataframe.\")\n","    print(\"Available columns:\", merged_df.columns.tolist())\n","else:\n","    # Create the plot\n","    fig, ax = plt.subplots(figsize=(12, 8))\n","    scatter = ax.scatter(merged_df['x'], merged_df['y'], c=merged_df['maximum_face_courant'], cmap='viridis', s=10)\n","\n","    # Customize the plot\n","    ax.set_title('Max Courant Number per Cell')\n","    ax.set_xlabel('X Coordinate')\n","    ax.set_ylabel('Y Coordinate')\n","    plt.colorbar(scatter, label='Max Courant Number')\n","\n","    # Add grid lines\n","    ax.grid(True, linestyle='--', alpha=0.7)\n","\n","    # Increase font size for better readability\n","    plt.rcParams.update({'font.size': 12})\n","\n","    # Adjust layout to prevent cutting off labels\n","    plt.tight_layout()\n","\n","    # Show the plot\n","    plt.show()\n","\n","# Print the first few rows of the merged dataframe for verification\n","print(\"\\nFirst few rows of the merged dataframe:\")\n","display(merged_df.head())\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get mesh summary output for other Datasets (here we retrieve Maximum Face Courant)\n","try:\n","    max_face_shear_df = HdfResultsMesh.mesh_summary_output(plan_hdf_path, var=\"Maximum Face Shear Stress\", ras_object=bald_eagle)\n","    print(\"\\nMesh Summary Output (Maximum Face Shear Stress:\")\n","    print(max_face_shear_df.attrs)\n","    display(max_face_shear_df.head())\n","except Exception as e:\n","    print(f\"Error: {str(e)}\")\n","    logger.error(f\"Failed to get mesh summary output: {str(e)}\")\n","    # Additional error handling or logging can be added here"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Plot max face shear stress\n","import matplotlib.pyplot as plt\n","from ras_commander.HdfMesh import HdfMesh\n","from ras_commander.HdfResultsMesh import HdfResultsMesh\n","from shapely.geometry import Point\n","\n","# Get mesh max face shear stress\n","max_shear_df = HdfResultsMesh.mesh_summary_output(plan_hdf_path, var=\"Maximum Face Shear Stress\", ras_object=bald_eagle)\n","\n","# Get cell coordinates\n","cell_coords = HdfMesh.mesh_cell_points(plan_hdf_path)\n","\n","# Merge max face shear stress with cell coordinates\n","merged_df = pd.merge(max_shear_df, cell_coords, on=['mesh_name', 'cell_id'])\n","\n","# Extract x and y coordinates from the geometry column\n","merged_df['x'] = merged_df['geometry'].apply(lambda geom: geom.x)\n","merged_df['y'] = merged_df['geometry'].apply(lambda geom: geom.y)\n","\n","# Check if 'x' and 'y' columns exist in merged_df\n","if 'x' not in merged_df.columns or 'y' not in merged_df.columns:\n","    print(\"Error: 'x' or 'y' columns not found in the merged dataframe.\")\n","    print(\"Available columns:\", merged_df.columns.tolist())\n","else:\n","    # Create the plot\n","    fig, ax = plt.subplots(figsize=(12, 8))\n","    scatter = ax.scatter(merged_df['x'], merged_df['y'], c=merged_df['maximum_face_shear_stress'], cmap='viridis', s=10)\n","\n","    # Customize the plot\n","    ax.set_title('Max Face Shear Stress per Cell')\n","    ax.set_xlabel('X Coordinate')\n","    ax.set_ylabel('Y Coordinate')\n","    plt.colorbar(scatter, label='Max Face Shear Stress (PSF)')\n","\n","    # Add grid lines\n","    ax.grid(True, linestyle='--', alpha=0.7)\n","\n","    # Increase font size for better readability\n","    plt.rcParams.update({'font.size': 12})\n","\n","    # Adjust layout to prevent cutting off labels\n","    plt.tight_layout()\n","\n","    # Show the plot\n","    plt.show()\n","\n","# Print the first few rows of the merged dataframe for verification\n","print(\"\\nFirst few rows of the merged dataframe:\")\n","display(merged_df.head())"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get mesh summary output for Minimum Water Surface\n","summary_df_min_ws = HdfResultsMesh.mesh_summary_output(plan_hdf_path, var=\"Minimum Water Surface\", ras_object=bald_eagle)\n","print(\"\\nMesh Summary Output (Minimum Water Surface):\")\n","display(summary_df_min_ws.head())\n","\n","# Example: Get mesh summary output for Minimum Face Velocity\n","summary_df_min_fv = HdfResultsMesh.mesh_summary_output(plan_hdf_path, var=\"Minimum Face Velocity\", ras_object=bald_eagle)\n","print(\"\\nMesh Summary Output (Minimum Face Velocity):\")\n","display(summary_df_min_fv.head())\n","\n","# Example: Get mesh summary output for Cell Cumulative Iteration\n","summary_df_cum_iter = HdfResultsMesh.mesh_summary_output(plan_hdf_path, var=\"Cell Cumulative Iteration\", ras_object=bald_eagle)\n","print(\"\\nMesh Summary Output (Cell Cumulative Iteration):\")\n","display(summary_df_cum_iter.head())\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get mesh faces summary output\n","faces_summary_df = HdfMesh.mesh_cell_faces(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nMesh Faces Summary Output:\")\n","display(faces_summary_df.head())\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get mesh cell polygons using the updated HdfMesh class\n","cell_polygons_gdf = HdfMesh.mesh_cell_polygons(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nMesh Cell Polygons:\")\n","display(cell_polygons_gdf.head())"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get mesh cell faces using the updated HdfMesh class\n","cell_faces_gdf = HdfMesh.mesh_cell_faces(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nMesh Cell Faces:\")\n","display(cell_faces_gdf.head())"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Plot Mesh Cell Faces\n","\n","import matplotlib.pyplot as plt\n","import logging\n","\n","def plot_mesh_cell_faces(gdf, title=\"Mesh Cell Faces\"):\n","    fig, ax = plt.subplots(figsize=(12, 8))\n","    \n","    # Plot the linestrings\n","    gdf.plot(ax=ax, color='blue', linewidth=0.5)\n","    \n","    # Customize the plot\n","    ax.set_title(title)\n","    ax.set_xlabel('Easting')\n","    ax.set_ylabel('Northing')\n","    ax.axis('equal')\n","    \n","    # Add grid lines\n","    ax.grid(True, linestyle='--', alpha=0.7)\n","    \n","    plt.tight_layout()\n","    plt.show()\n","\n","# Plot the mesh cell faces\n","plot_mesh_cell_faces(cell_faces_gdf)\n","\n","# Log the plotting action\n","logging.info(f\"Plotted {len(cell_faces_gdf)} mesh cell faces.\")"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get simulation start time\n","simulation_start_time = HdfPlan.get_simulation_start_time(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nSimulation Start Time:\")\n","print(simulation_start_time)\n","\n","# Get simulation end time\n","simulation_end_time = HdfPlan.get_simulation_end_time(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nSimulation End Time:\")\n","print(simulation_end_time)\n","\n","# Calculate simulation duration\n","simulation_duration = simulation_end_time - simulation_start_time\n","print(\"\\nSimulation Duration:\")\n","print(simulation_duration)"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get mesh timeseries output\n","\n","# Get mesh areas from previous code cell\n","mesh_areas = HdfMesh.mesh_area_names(geom_hdf_path, ras_object=bald_eagle)\n","\n","if mesh_areas:\n","    mesh_name = mesh_areas[0]  # Use the first 2D flow area name\n","    timeseries_da = HdfResultsMesh.mesh_timeseries_output(plan_hdf_path, mesh_name, \"Water Surface\", ras_object=bald_eagle)\n","    print(f\"\\nMesh Timeseries Output (Water Surface) for {mesh_name}:\")\n","    print(timeseries_da)\n","else:\n","    print(\"No mesh areas found in the geometry file.\")"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Create an animation of the water surface elevation over time\n","import matplotlib.pyplot as plt\n","import matplotlib.animation as animation\n","import numpy as np\n","from ras_commander.HdfMesh import HdfMesh\n","\n","# Extract data from the DataArray\n","time = timeseries_da.time.values\n","water_surface = timeseries_da.values\n","\n","# Get cell coordinates\n","cell_coords = HdfMesh.mesh_cell_points(plan_hdf_path)\n","\n","# Extract x and y coordinates from the geometry column\n","x = np.array([geom.x for geom in cell_coords['geometry']])\n","y = np.array([geom.y for geom in cell_coords['geometry']])\n","\n","# Ensure water_surface data matches the number of cells\n","if water_surface.shape[1] != len(x):\n","    print(f\"Warning: Number of cells in water_surface ({water_surface.shape[1]}) doesn't match number of coordinates ({len(x)})\")\n","    print(\"Attempting to reshape water_surface data...\")\n","    water_surface = water_surface[:, :len(x)]\n","\n","# Create the figure and axis\n","fig, ax = plt.subplots(figsize=(12, 8))\n","\n","# Initialize the scatter plot\n","scatter = ax.scatter(x, y, c=water_surface[0], cmap='viridis', s=10)\n","plt.colorbar(scatter, label='Water Surface Elevation (ft)')\n","\n","# Set title and labels\n","ax.set_title(f'Water Surface Elevation Over Time for {mesh_name}')\n","ax.set_xlabel('X Coordinate')\n","ax.set_ylabel('Y Coordinate')\n","\n","# Animation update function\n","def update(frame):\n","    scatter.set_array(water_surface[frame])\n","    ax.set_title(f'Water Surface Elevation at {time[frame]} for {mesh_name}')\n","    return scatter,\n","\n","# Create the animation\n","anim = animation.FuncAnimation(fig, update, frames=len(time), interval=200, blit=True)\n","\n","# Save the animation (optional)\n","# anim.save('water_surface_animation.gif', writer='pillow', fps=5)\n","\n","# Display the animation\n","plt.tight_layout()\n","plt.show()\n","\n","# Log the animation creation\n","logging.info(f\"Created water surface elevation animation for {mesh_name}\")\n","\n","# Print debug information\n","print(f\"Shape of water_surface array: {water_surface.shape}\")\n","print(f\"Number of x coordinates: {len(x)}\")\n","print(f\"Number of y coordinates: {len(y)}\")\n","print(f\"Number of time steps: {len(time)}\")"]},{"cell_type":"code","execution_count":71,"metadata":{},"outputs":[],"source":["# Time Series Output Variables for Cells\n","# \n","# Variable Name: Description\n","# Water Surface: Water surface elevation\n","# Depth: Water depth\n","# Velocity: Magnitude of velocity\n","# Velocity X: X-component of velocity\n","# Velocity Y: Y-component of velocity\n","# Froude Number: Froude number\n","# Courant Number: Courant number\n","# Shear Stress: Shear stress on the bed\n","# Bed Elevation: Elevation of the bed\n","# Precipitation Rate: Rate of precipitation\n","# Infiltration Rate: Rate of infiltration\n","# Evaporation Rate: Rate of evaporation\n","# Percolation Rate: Rate of percolation\n","# Groundwater Elevation: Elevation of groundwater\n","# Groundwater Depth: Depth to groundwater\n","# Groundwater Flow: Groundwater flow rate\n","# Groundwater Velocity: Magnitude of groundwater velocity\n","# Groundwater Velocity X: X-component of groundwater velocity\n","# Groundwater Velocity Y: Y-component of groundwater velocity\n","# \n","# These variables are available for time series output at the cell level in 2D flow areas.\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get mesh cells timeseries output\n","cells_timeseries_ds = HdfResultsMesh.mesh_cells_timeseries_output(plan_hdf_path, mesh_name, ras_object=bald_eagle)\n","print(\"\\nMesh Cells Timeseries Output:\")\n","print(cells_timeseries_ds)\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Plot Cell Time Series Data (Random Cell ID)\n","import matplotlib.pyplot as plt\n","import numpy as np\n","import random\n","\n","# Extract Water Surface data\n","water_surface = cells_timeseries_ds['BaldEagleCr']['Water Surface']\n","\n","# Get the time values\n","time_values = water_surface.coords['time'].values\n","\n","# Pick a random cell_id\n","random_cell_id = random.choice(water_surface.coords['cell_id'].values)\n","\n","# Extract the water surface elevation time series for the random cell\n","wsel_timeseries = water_surface.sel(cell_id=random_cell_id)\n","\n","# Find the peak value and its index\n","peak_value = wsel_timeseries.max().item()\n","peak_index = wsel_timeseries.argmax().item()\n","\n","# Create the plot\n","plt.figure(figsize=(12, 6))\n","plt.plot(time_values, wsel_timeseries, label=f'Cell ID: {random_cell_id}')\n","plt.scatter(time_values[peak_index], peak_value, color='red', s=100, zorder=5)\n","plt.annotate(f'Peak: {peak_value:.2f} ft', \n","             (time_values[peak_index], peak_value),\n","             xytext=(10, 10), textcoords='offset points',\n","             ha='left', va='bottom',\n","             bbox=dict(boxstyle='round,pad=0.5', fc='yellow', alpha=0.5),\n","             arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0'))\n","\n","plt.title(f'Water Surface Elevation Time Series for Random Cell (ID: {random_cell_id})')\n","plt.xlabel('Time')\n","plt.ylabel('Water Surface Elevation (ft)')\n","plt.legend()\n","plt.grid(True)\n","plt.tight_layout()\n","\n","# Log the plotting action\n","logging.info(f\"Plotted water surface elevation time series for random cell ID: {random_cell_id}\")\n","\n","# Display the plot\n","plt.show()\n","\n","# Print some statistics\n","print(f\"Statistics for Cell ID {random_cell_id}:\")\n","print(f\"Minimum WSEL: {wsel_timeseries.min().item():.2f} ft\")\n","print(f\"Maximum WSEL: {peak_value:.2f} ft\")\n","print(f\"Mean WSEL: {wsel_timeseries.mean().item():.2f} ft\")\n","print(f\"Time of peak: {time_values[peak_index]}\")\n","\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get mesh faces timeseries output\n","faces_timeseries_ds = HdfResultsMesh.mesh_faces_timeseries_output(plan_hdf_path, mesh_name, ras_object=bald_eagle)\n","print(\"\\nMesh Faces Timeseries Output:\")\n","print(faces_timeseries_ds)\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Plot Random Cell Results and Label Peak\n","\n","# Step 1: Import necessary libraries\n","import numpy as np\n","import matplotlib.pyplot as plt\n","\n","# Step 2: Select a random valid cell number\n","# Use .sizes instead of .dims to avoid FutureWarning\n","random_cell = np.random.randint(0, faces_timeseries_ds.sizes['cell'])\n","\n","# Step 3: Extract time series data for the selected cell\n","variable = 'face_velocity'  # We could also use 'face_flow'\n","cell_data = faces_timeseries_ds[variable].sel(cell=random_cell)\n","\n","# Step 4: Find peak value and its corresponding time\n","peak_value = cell_data.max().item()\n","peak_time = cell_data.idxmax().values\n","\n","# Step 5: Create the plot\n","plt.figure(figsize=(12, 6))\n","plt.plot(faces_timeseries_ds.time, cell_data)\n","plt.title(f'{variable.capitalize()} Time Series for Cell {random_cell}')\n","plt.xlabel('Time')\n","plt.ylabel(f'{variable.capitalize()} ({faces_timeseries_ds.attrs[\"units\"]})')\n","plt.grid(True)\n","\n","# Step 6: Annotate the peak point\n","plt.annotate(f'Peak: ({peak_time}, {peak_value:.2f})', \n","             (peak_time, peak_value),\n","             xytext=(10, 10), textcoords='offset points',\n","             arrowprops=dict(arrowstyle=\"->\"))\n","\n","# Step 7: Check for negative values and label the minimum if present\n","min_value = cell_data.min().item()\n","if min_value < 0:\n","    min_time = cell_data.idxmin().values\n","    plt.annotate(f'Min: ({min_time}, {min_value:.2f})', \n","                 (min_time, min_value),\n","                 xytext=(10, -10), textcoords='offset points',\n","                 arrowprops=dict(arrowstyle=\"->\"))\n","\n","# Step 8: Display the plot\n","plt.tight_layout()\n","plt.show()\n","\n","# Step 9: Print summary information\n","print(f\"Random Cell: {random_cell}\")\n","print(f\"Peak Value: {peak_value:.2f} {faces_timeseries_ds.attrs['units']} at {peak_time}\")\n","if min_value < 0:\n","    print(f\"Minimum Value: {min_value:.2f} {faces_timeseries_ds.attrs['units']} at {min_time}\")"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get reference lines\n","ref_lines_gdf = HdfBndry.reference_lines(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nReference Lines:\")\n","display(ref_lines_gdf.head())"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get reference points\n","ref_points_gdf = HdfBndry.reference_points(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nReference Points:\")\n","display(ref_points_gdf.head())"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get reference timeseries output\n","ref_timeseries_ds = HdfResultsPlan.reference_timeseries_output(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nReference Timeseries Output:\")\n","print(ref_timeseries_ds)"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get reference lines timeseries output\n","ref_lines_timeseries_ds = HdfResultsPlan.reference_lines_timeseries_output(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nReference Lines Timeseries Output:\")\n","print(ref_lines_timeseries_ds)"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get reference points timeseries output\n","ref_points_timeseries_ds = HdfResultsPlan.reference_points_timeseries_output(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nReference Points Timeseries Output:\")\n","print(ref_points_timeseries_ds)"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get reference summary output\n","ref_summary_df = HdfResultsPlan.reference_summary_output(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nReference Summary Output:\")\n","display(ref_summary_df.head())"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get meteorology precipitation attributes\n","meteo_precip_attrs = HdfPlan.get_meteorology_precip_attrs(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nMeteorology Precipitation Attributes:\")\n","for key, value in meteo_precip_attrs.items():\n","    print(f\"{key}: {value}\")"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get results unsteady attributes\n","results_unsteady_attrs = HdfResultsPlan.get_results_unsteady_attrs(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nResults Unsteady Attributes:\")\n","for key, value in results_unsteady_attrs.items():\n","    print(f\"{key}: {value}\")"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get results unsteady summary attributes\n","results_unsteady_summary_attrs = HdfResultsPlan.get_results_unsteady_summary_attrs(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nResults Unsteady Summary Attributes:\")\n","for key, value in results_unsteady_summary_attrs.items():\n","    print(f\"{key}: {value}\")\n","\n","# Get results volume accounting attributes\n","volume_accounting_attrs = HdfResultsPlan.get_results_volume_accounting_attrs(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nVolume Accounting Attributes:\")\n","for key, value in volume_accounting_attrs.items():\n","    print(f\"{key}: {value}\")"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get steady profile cross-section output\n","steady_xs_df = HdfResultsXsec.steady_profile_xs_output(plan_hdf_path, \"Water Surface\", ras_object=bald_eagle)\n","print(\"\\nSteady Profile Cross-Section Output (Water Surface):\")\n","display(steady_xs_df.head())"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get cross-sections water surface elevation\n","xs_wsel_df = HdfResultsXsec.cross_sections_wsel(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nCross-Sections Water Surface Elevation:\")\n","display(xs_wsel_df.head())"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get cross-sections flow\n","xs_flow_df = HdfResultsXsec.cross_sections_flow(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nCross-Sections Flow:\")\n","display(xs_flow_df.head())\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get cross-sections energy grade\n","xs_energy_grade_df = HdfResultsXsec.cross_sections_energy_grade(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nCross-Sections Energy Grade:\")\n","display(xs_energy_grade_df.head())"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get cross-sections additional encroachment station left\n","xs_enc_left_df = HdfResultsXsec.cross_sections_additional_enc_station_left(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nCross-Sections Additional Encroachment Station Left:\")\n","display(xs_enc_left_df.head())"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get cross-sections additional encroachment station right\n","xs_enc_right_df = HdfResultsXsec.cross_sections_additional_enc_station_right(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nCross-Sections Additional Encroachment Station Right:\")\n","display(xs_enc_right_df.head())"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get cross-sections additional area total\n","xs_area_total_df = HdfResultsXsec.cross_sections_additional_area_total(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nCross-Sections Additional Area Total:\")\n","display(xs_area_total_df.head())\n"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Get cross-sections additional velocity total\n","xs_velocity_total_df = HdfResultsXsec.cross_sections_additional_velocity_total(plan_hdf_path, ras_object=bald_eagle)\n","print(\"\\nCross-Sections Additional Velocity Total:\")\n","display(xs_velocity_total_df.head())"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# HdfUtils Examples\n","\n","# Example: Get attributes for a specific path\n","attrs = HdfUtils.get_attrs(plan_hdf_path, attr_path=\"/Results/Unsteady\")\n","print(\"\\nAttributes for /Results/Unsteady:\")\n","for key, value in attrs.items():\n","    print(f\"{key}: {value}\")"]},{"cell_type":"code","execution_count":null,"metadata":{},"outputs":[],"source":["# Example: Get root attributes\n","root_attrs = HdfUtils.get_root_attrs(plan_hdf_path)\n","print(\"\\nRoot Attributes:\")\n","for key, value in root_attrs.items():\n","    print(f\"{key}: {value}\")"]}],"metadata":{"kernelspec":{"display_name":"Python 3","language":"python","name":"python3"},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.11.9"}},"nbformat":4,"nbformat_minor":2}

==================================================

File: c:\GH\ras-commander\examples\19_benchmarking_version_6.6.ipynb
==================================================
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys\n",
    "from pathlib import Path\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from concurrent.futures import ThreadPoolExecutor, as_completed\n",
    "from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasHdf, RasUtils"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define versions to compare\n",
    "versions = ['6.6', '6.5', '6.4.1', '6.3.1', '6.2', '6.1', '5.0.7']\n",
    "\n",
    "# Extract BaldEagleCrkMulti2D project\n",
    "ras_examples = RasExamples()\n",
    "project_path = ras_examples.extract_project([\"BaldEagleCrkMulti2D\"])[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Get all plan numbers\n",
    "ras_project = init_ras_project(project_path, \"6.5\")\n",
    "print(ras_project)\n",
    "plan_numbers = ras_project.plan_df['plan_number'].tolist()\n",
    "print(plan_numbers)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import time\n",
    "from ras_commander import RasGeo\n",
    "\n",
    "def run_simulation(version, plan_number):\n",
    "    # Initialize project for the specific version\n",
    "    ras_project = init_ras_project(project_path, str(version))\n",
    "    \n",
    "    # Clear geometry preprocessor files\n",
    "    plan_path = RasPlan.get_plan_path(plan_number, ras_object=ras_project)\n",
    "    RasGeo.clear_geompre_files(plan_path, ras_object=ras_project)\n",
    "    \n",
    "    # Set number of cores to 6\n",
    "    RasPlan.set_num_cores(plan_number, \"6\", ras_object=ras_project)\n",
    "    \n",
    "    # Ensure geometry preprocessing is done\n",
    "    RasPlan.update_plan_value(plan_number, \"Run HTab\", 1, ras_object=ras_project)\n",
    "    \n",
    "    # Compute the plan\n",
    "    start_time = time.time()\n",
    "    success = RasCmdr.compute_plan(plan_number, ras_object=ras_project)\n",
    "    total_time = time.time() - start_time\n",
    "    \n",
    "    if success:\n",
    "        # Get HDF file path\n",
    "        hdf_path = RasPlan.get_results_path(plan_number, ras_object=ras_project)\n",
    "        \n",
    "        # Extract data from HDF file\n",
    "        runtime_data = RasHdf.get_runtime_data(hdf_path, ras_object=ras_project)\n",
    "        \n",
    "        # Extract required information\n",
    "        preprocessor_time = runtime_data['Preprocessing Geometry (hr)'].values[0]\n",
    "        unsteady_compute_time = runtime_data['Unsteady Flow Computations (hr)'].values[0]\n",
    "        \n",
    "        # Get volume accounting data\n",
    "        volume_accounting = RasHdf.get_group_attributes_as_df(hdf_path, \"Results/Unsteady/Summary/Volume Accounting/Volume Accounting 2D\", ras_object=ras_project)\n",
    "        volume_error = volume_accounting['Volume Error (%)'].values[0]\n",
    "        \n",
    "        return {\n",
    "            'Version': version,\n",
    "            'Plan': plan_number,\n",
    "            'Preprocessor Time (hr)': preprocessor_time,\n",
    "            'Unsteady Compute Time (hr)': unsteady_compute_time,\n",
    "            'Volume Error (%)': volume_error,\n",
    "            'Total Time (hr)': total_time / 3600  # Convert seconds to hours\n",
    "        }\n",
    "    else:\n",
    "        return None\n",
    "\n",
    "\n",
    "# Run simulations for all versions and plans sequentially\n",
    "results = []\n",
    "for version in versions:\n",
    "    for plan in plan_numbers:\n",
    "        print(f\"Running simulation for Version {version}, Plan {plan}\")\n",
    "        result = run_simulation(version, plan)\n",
    "        if result:\n",
    "            results.append(result)\n",
    "            print(f\"Completed: Version {version}, Plan {plan}\")\n",
    "        else:\n",
    "            print(f\"Failed: Version {version}, Plan {plan}\")\n",
    "\n",
    "# Create DataFrame from results\n",
    "df = pd.DataFrame(results)\n",
    "\n",
    "# Save initial results to CSV\n",
    "df.to_csv('save_initial_results.csv', index=False)\n",
    "\n",
    "print(\"Initial results saved to 'save_initial_results.csv'\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Calculate averages across plans for each version\n",
    "df_avg = df.groupby('Version').mean().reset_index()\n",
    "\n",
    "# Create line graphs\n",
    "plt.figure(figsize=(12, 6))\n",
    "\n",
    "# Unsteady Runtime vs Version\n",
    "plt.subplot(1, 2, 1)\n",
    "plt.plot(df_avg['Version'], df_avg['Unsteady Compute Time (hr)'], marker='o')\n",
    "plt.title('Average Unsteady Runtime vs HEC-RAS Version')\n",
    "plt.xlabel('HEC-RAS Version')\n",
    "plt.ylabel('Unsteady Runtime (hours)')\n",
    "\n",
    "# Volume Error vs Version\n",
    "plt.subplot(1, 2, 2)\n",
    "plt.plot(df_avg['Version'], df_avg['Volume Error (%)'], marker='o')\n",
    "plt.title('Average Volume Error vs HEC-RAS Version')\n",
    "plt.xlabel('HEC-RAS Version')\n",
    "plt.ylabel('Volume Error (%)')\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Save results to CSV\n",
    "df.to_csv('hecras_version_comparison.csv', index=False)\n",
    "df_avg.to_csv('hecras_version_comparison_averages.csv', index=False)\n",
    "\n",
    "print(\"Results saved to 'hecras_version_comparison.csv' and 'hecras_version_comparison_averages.csv'\")\n",
    "print(\"Graphs have been displayed. Please check the output.\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "fffff",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}

==================================================

File: c:\GH\ras-commander\examples\xx_edge_cases.py
==================================================
#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path
import shutil

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

example_projects_folder = Path(__file__).parent.parent / "example_projects"

# delete the folder if it exists
if example_projects_folder.exists():
    shutil.rmtree(example_projects_folder)


# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek"])

#### --- START OF SCRIPT --- ####

def main():
    # Initialize the project
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Balde Eagle Creek"
    init_ras_project(project_path, "6.5")

    print("Available plans:")
    print(ras.plan_df)
    print()

    # Example 1: Execute a single plan using compute_test_mode
    print("Example 1: Executing a single plan using compute_test_mode")
    single_plan = "01"
    dest_folder_suffix = "[SinglePlanTest]"
    compute_folder = project_path.parent / f"{project_path.name} {dest_folder_suffix}"
    
    # Delete the compute folder if it exists
    if compute_folder.exists():
        shutil.rmtree(compute_folder)
        print(f"Deleted existing compute folder: {compute_folder}")

    RasCmdr.compute_test_mode(
        plan_number=single_plan,
        dest_folder_suffix=dest_folder_suffix,
        clear_geompre=False,
        num_cores=2
    )
    print(f"Execution of plan {single_plan} completed using compute_test_mode")
    print()

    # Example 2: Execute a single plan using compute_parallel
    print("Example 2: Executing a single plan using compute_parallel")
    parallel_result_folder = project_path.parent / "parallel_single_plan_result"
    if parallel_result_folder.exists():
        shutil.rmtree(parallel_result_folder)
        print(f"Deleted existing result folder: {parallel_result_folder}")

    results = RasCmdr.compute_parallel(
        plan_number=single_plan,
        max_workers=1,
        num_cores=2,
        dest_folder=parallel_result_folder
    )
    print("Parallel execution of single plan results:")
    for plan_number, success in results.items():
        print(f"Plan {plan_number}: {'Successful' if success else 'Failed'}")
    print()

    # Example 3: Execute a single plan using compute_test_mode with a string input
    print("Example 3: Executing a single plan using compute_test_mode with a string input")
    dest_folder_suffix = "[SinglePlanTestString]"
    compute_folder = project_path.parent / f"{project_path.name} {dest_folder_suffix}"
    
    # Delete the compute folder if it exists
    if compute_folder.exists():
        shutil.rmtree(compute_folder)
        print(f"Deleted existing compute folder: {compute_folder}")

    RasCmdr.compute_test_mode(
        plan_number="02",
        dest_folder_suffix=dest_folder_suffix,
        clear_geompre=False,
        num_cores=2
    )
    print("Execution of plan 02 completed using compute_test_mode with string input")
    print()

    # Example 4: Execute a single plan using compute_parallel with a string input
    print("Example 4: Executing a single plan using compute_parallel with a string input")
    parallel_result_folder = project_path.parent / "parallel_single_plan_string_result"
    if parallel_result_folder.exists():
        shutil.rmtree(parallel_result_folder)
        print(f"Deleted existing result folder: {parallel_result_folder}")

    results = RasCmdr.compute_parallel(
        plan_number="01",  # Changed from "03" to "01"
        max_workers=1,
        num_cores=2,
        dest_folder=parallel_result_folder
    )
    print("Parallel execution of single plan (string input) results:")
    for plan_number, success in results.items():
        print(f"Plan {plan_number}: {'Successful' if success else 'Failed'}")
    print()

    # Example 5: Attempt to execute with an empty plan list
    print("Example 5: Attempting to execute with an empty plan list")
    dest_folder_suffix = "[EmptyPlanList]"
    compute_folder = project_path.parent / f"{project_path.name} {dest_folder_suffix}"
    
    if compute_folder.exists():
        shutil.rmtree(compute_folder)
        print(f"Deleted existing compute folder: {compute_folder}")

    try:
        RasCmdr.compute_test_mode(plan_number=[], dest_folder_suffix=dest_folder_suffix)
    except ValueError as e:
        print(f"Error caught: {e}")
    print()

    # Example 6: Attempt to execute with a non-existent plan number
    print("Example 6: Attempting to execute with a non-existent plan number")
    non_existent_plan = "99"
    dest_folder_suffix = "[NonExistentPlan]"
    compute_folder = project_path.parent / f"{project_path.name} {dest_folder_suffix}"
    
    if compute_folder.exists():
        shutil.rmtree(compute_folder)
        print(f"Deleted existing compute folder: {compute_folder}")

    try:
        RasCmdr.compute_test_mode(plan_number=non_existent_plan, dest_folder_suffix=dest_folder_suffix)
    except ValueError as e:
        print(f"Error caught: {e}")
    print()

if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\ras_commander\Decorators.py
==================================================
from functools import wraps
from pathlib import Path
from typing import Union
import logging
import h5py
import inspect


def log_call(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        logger = logging.getLogger(func.__module__)
        logger.info(f"Calling {func.__name__}")
        result = func(*args, **kwargs)
        logger.info(f"Finished {func.__name__}")
        return result
    return wrapper


def standardize_input(file_type: str = 'plan_hdf'):
    """
    Decorator to standardize input for HDF file operations.
    
    This decorator processes various input types and converts them to a Path object
    pointing to the correct HDF file. It handles the following input types:
    - h5py.File objects
    - pathlib.Path objects
    - Strings (file paths or plan/geom numbers)
    - Integers (interpreted as plan/geom numbers)
    
    The decorator also manages RAS object references and logging.
    
    Args:
        file_type (str): Specifies whether to look for 'plan_hdf' or 'geom_hdf' files.
    
    Returns:
        A decorator that wraps the function to standardize its input to a Path object.
    """
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            logger = logging.getLogger(func.__module__)
            
            # Handle both static method calls and regular function calls
            if args and isinstance(args[0], type):
                # Static method call, remove the class argument
                args = args[1:]
            
            hdf_input = kwargs.pop('hdf_path', None) or kwargs.pop('hdf_input', None) or (args[0] if args else None)
            ras_object = kwargs.pop('ras_object', None) or (args[1] if len(args) > 1 else None)

            hdf_path = None

            # If hdf_input is already an h5py.File object, use its filename
            if isinstance(hdf_input, h5py.File):
                hdf_path = Path(hdf_input.filename)
            # Handle Path objects
            elif isinstance(hdf_input, Path):
                if hdf_input.is_file():
                    hdf_path = hdf_input
            # Handle string inputs
            elif isinstance(hdf_input, str):
                # Check if it's a file path
                if Path(hdf_input).is_file():
                    hdf_path = Path(hdf_input)
                # Check if it's a number (with or without 'p' prefix)
                elif hdf_input.isdigit() or (len(hdf_input) == 3 and hdf_input[0] == 'p' and hdf_input[1:].isdigit()):
                    if ras_object is None:
                        raise ValueError("RAS object is required when using plan or geom numbers.")
                    number = hdf_input if hdf_input.isdigit() else hdf_input[1:]
                    
                    if file_type == 'plan_hdf':
                        plan_info = ras_object.plan_df[ras_object.plan_df['plan_number'] == number]
                        if not plan_info.empty:
                            hdf_path = Path(plan_info.iloc[0]['HDF_Results_Path'])
                    elif file_type == 'geom_hdf':
                        geom_info = ras_object.geom_df[ras_object.geom_df['geom_number'] == number]
                        if not geom_info.empty:
                            hdf_path = Path(geom_info.iloc[0]['HDF_Path'])
                    else:
                        raise ValueError(f"Invalid file type: {file_type}")
            # Handle integer inputs (assuming they're plan or geom numbers)
            elif isinstance(hdf_input, int):
                if ras_object is None:
                    raise ValueError("RAS object is required when using plan or geom numbers.")
                number = f"{hdf_input:02d}"
                
                if file_type == 'plan_hdf':
                    plan_info = ras_object.plan_df[ras_object.plan_df['plan_number'] == number]
                    if not plan_info.empty:
                        hdf_path = Path(plan_info.iloc[0]['HDF_Results_Path'])
                elif file_type == 'geom_hdf':
                    geom_info = ras_object.geom_df[ras_object.geom_df['geom_number'] == number]
                    if not geom_info.empty:
                        hdf_path = Path(geom_info.iloc[0]['HDF_Path'])
                else:
                    raise ValueError(f"Invalid file type: {file_type}")

            if hdf_path is None or not hdf_path.is_file():
                error_msg = f"HDF file not found: {hdf_input}"
                logger.error(error_msg)
                raise FileNotFoundError(error_msg)

            logger.info(f"Using HDF file: {hdf_path}")
            
            # Pass all original arguments and keywords, replacing hdf_input with standardized hdf_path
            new_args = (hdf_path,) + args[1:]
            return func(*new_args, **kwargs)

        return wrapper
    return decorator
==================================================

File: c:\GH\ras-commander\ras_commander\HdfBase.py
==================================================
"""
Class: HdfBase

Attribution: A substantial amount of code in this file is sourced or derived 
from the https://github.com/fema-ffrd/rashdf library, 
released under MIT license and Copyright (c) 2024 fema-ffrd

The file has been forked and modified for use in RAS Commander.
"""
import re
from datetime import datetime, timedelta
import h5py
import numpy as np
import pandas as pd
import xarray as xr  # Added import for xarray
from typing import List, Tuple, Union, Optional, Dict
from pathlib import Path
import logging

from .HdfUtils import HdfUtils
from .Decorators import standardize_input, log_call
from .LoggingConfig import setup_logging, get_logger

logger = get_logger(__name__)

class HdfBase:
    """
    Base class for HEC-RAS HDF file operations.

    This class provides fundamental methods for interacting with HEC-RAS HDF files,
    including time-related operations and mesh data retrieval. It serves as a foundation
    for more specialized HDF classes.

    The methods in this class are designed to work with both plan and geometry HDF files,
    providing low-level access to file structure and content.

    Note:
    - All methods in this class are static, allowing for use without instantiation.
    - This class is not meant to be used directly in most cases, but rather as a base
      for more specialized HDF classes.
    """

    @staticmethod
    def _get_simulation_start_time(hdf_file: h5py.File) -> datetime:
        """
        Get the simulation start time from the HDF file.

        Args:
            hdf_file (h5py.File): Open HDF file object.

        Returns:
            datetime: The simulation start time.

        Raises:
            ValueError: If Plan Information is not found in the HDF file.
        """
        plan_info = hdf_file.get("Plan Data/Plan Information")
        if plan_info is None:
            raise ValueError("Plan Information not found in HDF file")
        time_str = plan_info.attrs.get('Simulation Start Time')
        return datetime.strptime(time_str.decode('utf-8'), "%d%b%Y %H:%M:%S")

    @staticmethod
    def _get_unsteady_datetimes(hdf_file: h5py.File) -> List[datetime]:
        """
        Get the list of unsteady datetimes from the HDF file.

        Args:
            hdf_file (h5py.File): Open HDF file object.

        Returns:
            List[datetime]: A list of datetime objects representing the unsteady timestamps.
        """
        group_path = "Results/Unsteady/Output/Output Blocks/Base Output/Unsteady Time Series/Time Date Stamp (ms)"
        raw_datetimes = hdf_file[group_path][:]
        return [HdfBase._parse_ras_datetime_ms(x.decode("utf-8")) for x in raw_datetimes]
    

    @staticmethod
    def _get_2d_flow_area_names_and_counts(hdf_file: h5py.File) -> List[Tuple[str, int]]:
        """
        Get the names and cell counts of 2D flow areas from the HDF file.

        Args:
            hdf_file (h5py.File): Open HDF file object.

        Returns:
            List[Tuple[str, int]]: A list of tuples containing the name and cell count of each 2D flow area.
        """
        d2_flow_areas = hdf_file.get("Geometry/2D Flow Areas/Attributes")
        if d2_flow_areas is None:
            return []
        return [(HdfBase._convert_ras_hdf_string(d2_flow_area[0]), d2_flow_area[-1]) for d2_flow_area in d2_flow_areas[:]]

    @staticmethod
    def _parse_ras_datetime(datetime_str: str) -> datetime:
        """
        Parse a datetime string from a RAS file into a datetime object.

        Args:
            datetime_str (str): The datetime string to parse.

        Returns:
            datetime: The parsed datetime object.
        """
        return datetime.strptime(datetime_str, "%d%b%Y %H:%M:%S")

    @staticmethod
    def _parse_ras_simulation_window_datetime(datetime_str: str) -> datetime:
        """
        Parse a datetime string from a RAS simulation window into a datetime object.

        Args:
            datetime_str (str): The datetime string to parse.

        Returns:
            datetime: The parsed datetime object.
        """
        return datetime.strptime(datetime_str, "%d%b%Y %H%M")

    @staticmethod
    def _parse_duration(duration_str: str) -> timedelta:
        """
        Parse a duration string into a timedelta object.

        Args:
            duration_str (str): The duration string to parse.

        Returns:
            timedelta: The parsed duration as a timedelta object.
        """
        hours, minutes, seconds = map(int, duration_str.split(':'))
        return timedelta(hours=hours, minutes=minutes, seconds=seconds)

    @staticmethod
    def _parse_ras_datetime_ms(datetime_str: str) -> datetime:
        """
        Parse a datetime string with milliseconds from a RAS file.

        Args:
            datetime_str (str): The datetime string to parse.

        Returns:
            datetime: The parsed datetime object.
        """
        milliseconds = int(datetime_str[-3:])
        microseconds = milliseconds * 1000
        parsed_dt = HdfBase._parse_ras_datetime(datetime_str[:-4]).replace(microsecond=microseconds)
        return parsed_dt

    @staticmethod
    def _convert_ras_hdf_string(value: Union[str, bytes]) -> Union[bool, datetime, List[datetime], timedelta, str]:
        """
        Convert a string value from an HEC-RAS HDF file into a Python object.

        Args:
            value (Union[str, bytes]): The value to convert.

        Returns:
            Union[bool, datetime, List[datetime], timedelta, str]: The converted value.
        """
        if isinstance(value, bytes):
            s = value.decode("utf-8")
        else:
            s = value

        if s == "True":
            return True
        elif s == "False":
            return False
        
        ras_datetime_format1_re = r"\d{2}\w{3}\d{4} \d{2}:\d{2}:\d{2}"
        ras_datetime_format2_re = r"\d{2}\w{3}\d{4} \d{2}\d{2}"
        ras_duration_format_re = r"\d{2}:\d{2}:\d{2}"

        if re.match(rf"^{ras_datetime_format1_re}", s):
            if re.match(rf"^{ras_datetime_format1_re} to {ras_datetime_format1_re}$", s):
                split = s.split(" to ")
                return [
                    HdfBase._parse_ras_datetime(split[0]),
                    HdfBase._parse_ras_datetime(split[1]),
                ]
            return HdfBase._parse_ras_datetime(s)
        elif re.match(rf"^{ras_datetime_format2_re}", s):
            if re.match(rf"^{ras_datetime_format2_re} to {ras_datetime_format2_re}$", s):
                split = s.split(" to ")
                return [
                    HdfBase._parse_ras_simulation_window_datetime(split[0]),
                    HdfBase._parse_ras_simulation_window_datetime(split[1]),
                ]
            return HdfBase._parse_ras_simulation_window_datetime(s)
        elif re.match(rf"^{ras_duration_format_re}$", s):
            return HdfBase._parse_duration(s)
        return s




==================================================

File: c:\GH\ras-commander\ras_commander\HdfBndry.py
==================================================
"""
Class: HdfBndry

Attribution: A substantial amount of code in this file is sourced or derived 
from the https://github.com/fema-ffrd/rashdf library, 
released under MIT license and Copyright (c) 2024 fema-ffrd

The file has been forked and modified for use in RAS Commander.
"""
from pathlib import Path
from typing import Dict, List, Optional, Union, Any
import h5py
import numpy as np
import pandas as pd
import geopandas as gpd
from shapely.geometry import LineString, MultiLineString, Polygon, MultiPolygon, Point
from .HdfBase import HdfBase
from .HdfUtils import HdfUtils
from .HdfMesh import HdfMesh
from .Decorators import standardize_input, log_call
from .LoggingConfig import setup_logging, get_logger

logger = get_logger(__name__)


class HdfBndry:
    """
    A class for handling boundary-related data from HEC-RAS HDF files.

    This class provides methods to extract and process various boundary elements
    such as boundary condition lines, breaklines, refinement regions, and reference
    lines/points from HEC-RAS geometry HDF files.

    Methods in this class return data primarily as GeoDataFrames, making it easy
    to work with spatial data in a geospatial context.

    Note:
        This class relies on the HdfBase and HdfUtils classes for some of its
        functionality. Ensure these classes are available in the same package.
    """

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def bc_lines(hdf_path: Path) -> gpd.GeoDataFrame:
        """
        Return 2D mesh area boundary condition lines.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.

        Returns
        -------
        gpd.GeoDataFrame
            A GeoDataFrame containing the boundary condition lines.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                bc_lines_path = "Geometry/Boundary Condition Lines"
                if bc_lines_path not in hdf_file:
                    return gpd.GeoDataFrame()
                bc_line_data = hdf_file[bc_lines_path]
                bc_line_ids = range(bc_line_data["Attributes"][()].shape[0])
                v_conv_str = np.vectorize(HdfUtils.convert_ras_hdf_string)
                names = v_conv_str(bc_line_data["Attributes"][()]["Name"])
                mesh_names = v_conv_str(bc_line_data["Attributes"][()]["SA-2D"])
                types = v_conv_str(bc_line_data["Attributes"][()]["Type"])
                geoms = HdfBndry._get_polylines(hdf_file, bc_lines_path)
                return gpd.GeoDataFrame(
                    {
                        "bc_line_id": bc_line_ids,
                        "name": names,
                        "mesh_name": mesh_names,
                        "type": types,
                        "geometry": geoms,
                    },
                    geometry="geometry",
                    crs=HdfUtils.projection(hdf_file),
                )
        except Exception as e:
            print(f"Error reading boundary condition lines: {str(e)}")
            return gpd.GeoDataFrame()

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def breaklines(hdf_path: Path) -> gpd.GeoDataFrame:
        """
        Return 2D mesh area breaklines.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.

        Returns
        -------
        gpd.GeoDataFrame
            A GeoDataFrame containing the breaklines.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                breaklines_path = "Geometry/2D Flow Area Break Lines"
                if breaklines_path not in hdf_file:
                    return gpd.GeoDataFrame()
                bl_line_data = hdf_file[breaklines_path]
                bl_line_ids = range(bl_line_data["Attributes"][()].shape[0])
                names = np.vectorize(HdfUtils.convert_ras_hdf_string)(
                    bl_line_data["Attributes"][()]["Name"]
                )
                geoms = HdfBndry._get_polylines(hdf_file, breaklines_path)
                return gpd.GeoDataFrame(
                    {"bl_id": bl_line_ids, "name": names, "geometry": geoms},
                    geometry="geometry",
                    crs=HdfUtils.projection(hdf_file),
                )
        except Exception as e:
            print(f"Error reading breaklines: {str(e)}")
            return gpd.GeoDataFrame()

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def refinement_regions(hdf_path: Path) -> gpd.GeoDataFrame:
        """
        Return 2D mesh area refinement regions.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.

        Returns
        -------
        gpd.GeoDataFrame
            A GeoDataFrame containing the refinement regions.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                refinement_regions_path = "/Geometry/2D Flow Area Refinement Regions"
                if refinement_regions_path not in hdf_file:
                    return gpd.GeoDataFrame()
                rr_data = hdf_file[refinement_regions_path]
                rr_ids = range(rr_data["Attributes"][()].shape[0])
                names = np.vectorize(HdfUtils.convert_ras_hdf_string)(rr_data["Attributes"][()]["Name"])
                geoms = list()
                for pnt_start, pnt_cnt, part_start, part_cnt in rr_data["Polygon Info"][()]:
                    points = rr_data["Polygon Points"][()][pnt_start : pnt_start + pnt_cnt]
                    if part_cnt == 1:
                        geoms.append(Polygon(points))
                    else:
                        parts = rr_data["Polygon Parts"][()][part_start : part_start + part_cnt]
                        geoms.append(
                            MultiPolygon(
                                list(
                                    points[part_pnt_start : part_pnt_start + part_pnt_cnt]
                                    for part_pnt_start, part_pnt_cnt in parts
                                )
                            )
                        )
                return gpd.GeoDataFrame(
                    {"rr_id": rr_ids, "name": names, "geometry": geoms},
                    geometry="geometry",
                    crs=HdfUtils.projection(hdf_file),
                )
        except Exception as e:
            print(f"Error reading refinement regions: {str(e)}")
            return gpd.GeoDataFrame()

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def reference_lines_names(hdf_path: Path, mesh_name: Optional[str] = None) -> Union[Dict[str, List[str]], List[str]]:
        """
        Return reference line names.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.
        mesh_name : Optional[str], optional
            Name of the mesh to filter by. Default is None.

        Returns
        -------
        Union[Dict[str, List[str]], List[str]]
            A dictionary of mesh names to reference line names, or a list of reference line names if mesh_name is provided.
        """
        return HdfBndry._get_reference_lines_points_names(hdf_path, "lines", mesh_name)

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def reference_points_names(hdf_path: Path, mesh_name: Optional[str] = None) -> Union[Dict[str, List[str]], List[str]]:
        """
        Return reference point names.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.
        mesh_name : Optional[str], optional
            Name of the mesh to filter by. Default is None.

        Returns
        -------
        Union[Dict[str, List[str]], List[str]]
            A dictionary of mesh names to reference point names, or a list of reference point names if mesh_name is provided.
        """
        return HdfBndry._get_reference_lines_points_names(hdf_path, "points", mesh_name)

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def reference_lines(hdf_path: Path) -> gpd.GeoDataFrame:
        """
        Return the reference lines geometry and attributes.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.

        Returns
        -------
        gpd.GeoDataFrame
            A GeoDataFrame containing the reference lines.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                reference_lines_path = "Geometry/Reference Lines"
                attributes_path = f"{reference_lines_path}/Attributes"
                if attributes_path not in hdf_file:
                    return gpd.GeoDataFrame()
                attributes = hdf_file[attributes_path][()]
                refline_ids = range(attributes.shape[0])
                v_conv_str = np.vectorize(HdfUtils.convert_ras_hdf_string)
                names = v_conv_str(attributes["Name"])
                mesh_names = v_conv_str(attributes["SA-2D"])
                try:
                    types = v_conv_str(attributes["Type"])
                except ValueError:
                    # "Type" field doesn't exist -- observed in some RAS HDF files
                    types = np.array([""] * attributes.shape[0])
                geoms = HdfBndry._get_polylines(hdf_file, reference_lines_path)
                return gpd.GeoDataFrame(
                    {
                        "refln_id": refline_ids,
                        "refln_name": names,
                        "mesh_name": mesh_names,
                        "type": types,
                        "geometry": geoms,
                    },
                    geometry="geometry",
                    crs=HdfUtils.projection(hdf_file),
                )
        except Exception as e:
            print(f"Error reading reference lines: {str(e)}")
            return gpd.GeoDataFrame()

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def reference_points(hdf_path: Path) -> gpd.GeoDataFrame:
        """
        Return the reference points geometry and attributes.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.

        Returns
        -------
        gpd.GeoDataFrame
            A GeoDataFrame containing the reference points.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                reference_points_path = "Geometry/Reference Points"
                attributes_path = f"{reference_points_path}/Attributes"
                if attributes_path not in hdf_file:
                    return gpd.GeoDataFrame()
                ref_points_group = hdf_file[reference_points_path]
                attributes = ref_points_group["Attributes"][:]
                v_conv_str = np.vectorize(HdfUtils.convert_ras_hdf_string)
                names = v_conv_str(attributes["Name"])
                mesh_names = v_conv_str(attributes["SA/2D"])
                cell_id = attributes["Cell Index"]
                points = ref_points_group["Points"][()]
                return gpd.GeoDataFrame(
                    {
                        "refpt_id": range(attributes.shape[0]),
                        "refpt_name": names,
                        "mesh_name": mesh_names,
                        "cell_id": cell_id,
                        "geometry": list(map(Point, points)),
                    },
                    geometry="geometry",
                    crs=HdfUtils.projection(hdf_file),
                )
        except Exception as e:
            print(f"Error reading reference points: {str(e)}")
            return gpd.GeoDataFrame()

    @staticmethod
    def _get_reference_lines_points_names(hdf_path: Path, reftype: str = "lines", mesh_name: Optional[str] = None) -> Union[Dict[str, List[str]], List[str]]:
        """
        Get the names of reference lines or points.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.
        reftype : str, optional
            Type of reference, either "lines" or "points" (default "lines").
        mesh_name : Optional[str], optional
            Name of the mesh to filter by. Default is None.

        Returns
        -------
        Union[Dict[str, List[str]], List[str]]
            A dictionary of mesh names to reference names, or a list of reference names if mesh_name is provided.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                if reftype == "lines":
                    path = "Geometry/Reference Lines"
                    sa_2d_field = "SA-2D"
                elif reftype == "points":
                    path = "Geometry/Reference Points"
                    sa_2d_field = "SA/2D"
                else:
                    raise ValueError(
                        f"Invalid reference type: {reftype} -- must be 'lines' or 'points'."
                    )
                attributes_path = f"{path}/Attributes"
                if mesh_name is None and attributes_path not in hdf_file:
                    return {m: [] for m in HdfMesh.mesh_area_names(hdf_file)}
                if mesh_name is not None and attributes_path not in hdf_file:
                    return []
                attributes = hdf_file[attributes_path][()]
                v_conv_str = np.vectorize(HdfUtils.convert_ras_hdf_string)
                names = v_conv_str(attributes["Name"])
                if mesh_name is not None:
                    return names[v_conv_str(attributes[sa_2d_field]) == mesh_name].tolist()
                mesh_names = v_conv_str(attributes[sa_2d_field])
                return {m: names[mesh_names == m].tolist() for m in np.unique(mesh_names)}
        except Exception as e:
            print(f"Error reading reference lines/points names: {str(e)}")
            return {} if mesh_name is None else []

    @staticmethod
    def _get_polylines(hdf_file: h5py.File, path: str, info_name: str = "Polyline Info", parts_name: str = "Polyline Parts", points_name: str = "Polyline Points") -> List[Union[LineString, MultiLineString]]:
        """
        Get polyline geometries from HDF file.

        Parameters
        ----------
        hdf_file : h5py.File
            Open HDF file object.
        path : str
            Path to the polyline data in the HDF file.
        info_name : str, optional
            Name of the info dataset (default "Polyline Info").
        parts_name : str, optional
            Name of the parts dataset (default "Polyline Parts").
        points_name : str, optional
            Name of the points dataset (default "Polyline Points").

        Returns
        -------
        List[Union[LineString, MultiLineString]]
            A list of polyline geometries.
        """
        polyline_info_path = f"{path}/{info_name}"
        polyline_parts_path = f"{path}/{parts_name}"
        polyline_points_path = f"{path}/{points_name}"

        polyline_info = hdf_file[polyline_info_path][()]
        polyline_parts = hdf_file[polyline_parts_path][()]
        polyline_points = hdf_file[polyline_points_path][()]

        geoms = []
        for pnt_start, pnt_cnt, part_start, part_cnt in polyline_info:
            points = polyline_points[pnt_start : pnt_start + pnt_cnt]
            if part_cnt == 1:
                geoms.append(LineString(points))
            else:
                parts = polyline_parts[part_start : part_start + part_cnt]
                geoms.append(
                    MultiLineString(
                        list(
                            points[part_pnt_start : part_pnt_start + part_pnt_cnt]
                            for part_pnt_start, part_pnt_cnt in parts
                        )
                    )
                )
        return geoms
    
    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def get_boundary_attributes(hdf_path: Path, boundary_type: str) -> pd.DataFrame:
        """
        Get attributes of boundary elements.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.
        boundary_type : str
            Type of boundary element ('bc_lines', 'breaklines', 'refinement_regions', 'reference_lines', 'reference_points').

        Returns
        -------
        pd.DataFrame
            A DataFrame containing the attributes of the specified boundary element.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                if boundary_type == 'bc_lines':
                    path = "Geometry/Boundary Condition Lines/Attributes"
                elif boundary_type == 'breaklines':
                    path = "Geometry/2D Flow Area Break Lines/Attributes"
                elif boundary_type == 'refinement_regions':
                    path = "Geometry/2D Flow Area Refinement Regions/Attributes"
                elif boundary_type == 'reference_lines':
                    path = "Geometry/Reference Lines/Attributes"
                elif boundary_type == 'reference_points':
                    path = "Geometry/Reference Points/Attributes"
                else:
                    raise ValueError(f"Invalid boundary type: {boundary_type}")

                if path not in hdf_file:
                    return pd.DataFrame()

                attributes = hdf_file[path][()]
                return pd.DataFrame(attributes)
        except Exception as e:
            print(f"Error reading {boundary_type} attributes: {str(e)}")
            return pd.DataFrame()

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def get_boundary_count(hdf_path: Path, boundary_type: str) -> int:
        """
        Get the count of boundary elements.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.
        boundary_type : str
            Type of boundary element ('bc_lines', 'breaklines', 'refinement_regions', 'reference_lines', 'reference_points').

        Returns
        -------
        int
            The count of the specified boundary element.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                if boundary_type == 'bc_lines':
                    path = "Geometry/Boundary Condition Lines/Attributes"
                elif boundary_type == 'breaklines':
                    path = "Geometry/2D Flow Area Break Lines/Attributes"
                elif boundary_type == 'refinement_regions':
                    path = "Geometry/2D Flow Area Refinement Regions/Attributes"
                elif boundary_type == 'reference_lines':
                    path = "Geometry/Reference Lines/Attributes"
                elif boundary_type == 'reference_points':
                    path = "Geometry/Reference Points/Attributes"
                else:
                    raise ValueError(f"Invalid boundary type: {boundary_type}")

                if path not in hdf_file:
                    return 0

                return hdf_file[path].shape[0]
        except Exception as e:
            print(f"Error getting {boundary_type} count: {str(e)}")
            return 0

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def get_boundary_names(hdf_path: Path, boundary_type: str) -> List[str]:
        """
        Get the names of boundary elements.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.
        boundary_type : str
            Type of boundary element ('bc_lines', 'breaklines', 'refinement_regions', 'reference_lines', 'reference_points').

        Returns
        -------
        List[str]
            A list of names for the specified boundary element.
        """
        try:
            df = HdfBndry.get_boundary_attributes(hdf_path, boundary_type)
            if 'Name' in df.columns:
                return df['Name'].tolist()
            else:
                return []
        except Exception as e:
            print(f"Error getting {boundary_type} names: {str(e)}")
            return []
==================================================

File: c:\GH\ras-commander\ras_commander\HdfMesh.py
==================================================
"""
Class: HdfMesh

Attribution: A substantial amount of code in this file is sourced or derived 
from the https://github.com/fema-ffrd/rashdf library, 
released under MIT license and Copyright (c) 2024 fema-ffrd

The file has been forked and modified for use in RAS Commander.
"""
from pathlib import Path
import h5py
import numpy as np
import pandas as pd
from geopandas import GeoDataFrame
from shapely.geometry import Polygon, Point, LineString, MultiLineString, MultiPolygon
from shapely.ops import polygonize  # Importing polygonize to resolve the undefined name error
from typing import List, Tuple, Optional, Dict, Any
import logging
from .HdfBase import HdfBase
from .HdfUtils import HdfUtils
from .Decorators import standardize_input, log_call
from .LoggingConfig import setup_logging, get_logger

logger = get_logger(__name__)


class HdfMesh:
    """
    A class for handling mesh-related operations on HEC-RAS HDF files.

    This class provides methods to extract and analyze mesh data from HEC-RAS HDF files,
    including mesh area names, mesh areas, cell polygons, cell points, cell faces, and
    2D flow area attributes.

    Methods in this class are designed to work with the mesh geometry data stored in
    HEC-RAS HDF files, providing functionality to retrieve and process various aspects
    of the 2D flow areas and their associated mesh structures.

    Note: This class relies on HdfBase and HdfUtils for some underlying operations.
    """

    FLOW_AREA_2D_PATH = "Geometry/2D Flow Areas"

    def __init__(self):
        self.logger = logging.getLogger(__name__)

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def mesh_area_names(hdf_path: Path) -> List[str]:
        """
        Return a list of the 2D mesh area names of the RAS geometry.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.

        Returns
        -------
        List[str]
            A list of the 2D mesh area names (str) within the RAS geometry if 2D areas exist.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                if HdfMesh.FLOW_AREA_2D_PATH not in hdf_file:
                    return list()
                return list(
                    [
                        HdfUtils.convert_ras_hdf_string(n)
                        for n in hdf_file[f"{HdfMesh.FLOW_AREA_2D_PATH}/Attributes"][()]["Name"]
                    ]
                )
        except Exception as e:
            self.logger.error(f"Error reading mesh area names from {hdf_path}: {str(e)}")
            return list()

    @staticmethod
    @standardize_input(file_type='geom_hdf')
    def mesh_areas(hdf_path: Path) -> GeoDataFrame:
        """
        Return 2D flow area perimeter polygons.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.

        Returns
        -------
        GeoDataFrame
            A GeoDataFrame containing the 2D flow area perimeter polygons if 2D areas exist.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                mesh_area_names = HdfMesh.mesh_area_names(hdf_path)
                if not mesh_area_names:
                    return GeoDataFrame()
                mesh_area_polygons = [
                    Polygon(hdf_file[f"{HdfMesh.FLOW_AREA_2D_PATH}/{n}/Perimeter"][()])
                    for n in mesh_area_names
                ]
                return GeoDataFrame(
                    {"mesh_name": mesh_area_names, "geometry": mesh_area_polygons},
                    geometry="geometry",
                    crs=HdfUtils.projection(hdf_file),  # Pass the h5py.File object instead of the path
                )
        except Exception as e:
            logger.error(f"Error reading mesh areas from {hdf_path}: {str(e)}")
            return GeoDataFrame()

    @staticmethod
    @standardize_input(file_type='geom_hdf')
    def mesh_cell_polygons(hdf_path: Path) -> GeoDataFrame:
        """
        Return 2D flow mesh cell polygons.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.

        Returns
        -------
        GeoDataFrame
            A GeoDataFrame containing the 2D flow mesh cell polygons.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                mesh_area_names = HdfMesh.mesh_area_names(hdf_path)
                if not mesh_area_names:
                    return GeoDataFrame()

                face_gdf = HdfMesh.mesh_cell_faces(hdf_path)

                cell_dict = {"mesh_name": [], "cell_id": [], "geometry": []}
                for i, mesh_name in enumerate(mesh_area_names):
                    cell_cnt = hdf_file[f"{HdfMesh.FLOW_AREA_2D_PATH}/Cell Info"][()][i][1]
                    cell_ids = list(range(cell_cnt))
                    cell_face_info = hdf_file[
                        f"{HdfMesh.FLOW_AREA_2D_PATH}/{mesh_name}/Cells Face and Orientation Info"
                    ][()]
                    cell_face_values = hdf_file[
                        f"{HdfMesh.FLOW_AREA_2D_PATH}/{mesh_name}/Cells Face and Orientation Values"
                    ][()][:, 0]
                    face_id_lists = list(
                        np.vectorize(
                            lambda cell_id: str(
                                cell_face_values[
                                    cell_face_info[cell_id][0] : cell_face_info[cell_id][0]
                                    + cell_face_info[cell_id][1]
                                ]
                            )
                        )(cell_ids)
                    )
                    mesh_faces = (
                        face_gdf[face_gdf.mesh_name == mesh_name][["face_id", "geometry"]]
                        .set_index("face_id")
                        .to_numpy()
                    )
                    cell_dict["mesh_name"] += [mesh_name] * cell_cnt
                    cell_dict["cell_id"] += cell_ids
                    cell_dict["geometry"] += list(
                        np.vectorize(
                            lambda face_id_list: (
                                lambda geom_col: Polygon(list(polygonize(geom_col))[0])
                            )(
                                np.ravel(
                                    mesh_faces[
                                        np.array(face_id_list.strip("[]").split()).astype(int)
                                    ]
                                )
                            )
                        )(face_id_lists)
                    )
                return GeoDataFrame(cell_dict, geometry="geometry", crs=HdfUtils.projection(hdf_file))
        except Exception as e:
            logger.error(f"Error reading mesh cell polygons from {hdf_path}: {str(e)}")
            return GeoDataFrame()

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def mesh_cell_points(hdf_path: Path) -> GeoDataFrame:
        """
        Return 2D flow mesh cell points.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.

        Returns
        -------
        GeoDataFrame
            A GeoDataFrame containing the 2D flow mesh cell points.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                mesh_area_names = HdfMesh.mesh_area_names(hdf_path)
                if not mesh_area_names:
                    return GeoDataFrame()
                pnt_dict = {"mesh_name": [], "cell_id": [], "geometry": []}
                for i, mesh_name in enumerate(mesh_area_names):
                    starting_row, count = hdf_file[f"{HdfMesh.FLOW_AREA_2D_PATH}/Cell Info"][()][i]
                    cell_pnt_coords = hdf_file[f"{HdfMesh.FLOW_AREA_2D_PATH}/Cell Points"][()][
                        starting_row : starting_row + count
                    ]
                    pnt_dict["mesh_name"] += [mesh_name] * cell_pnt_coords.shape[0]
                    pnt_dict["cell_id"] += range(count)
                    pnt_dict["geometry"] += list(
                        np.vectorize(lambda coords: Point(coords), signature="(n)->()")(
                            cell_pnt_coords
                        )
                    )
                return GeoDataFrame(pnt_dict, geometry="geometry", crs=HdfUtils.projection(hdf_path))
        except Exception as e:
            self.logger.error(f"Error reading mesh cell points from {hdf_path}: {str(e)}")
            return GeoDataFrame()

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def mesh_cell_faces(hdf_path: Path) -> GeoDataFrame:
        """
        Return 2D flow mesh cell faces.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.

        Returns
        -------
        GeoDataFrame
            A GeoDataFrame containing the 2D flow mesh cell faces.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                mesh_area_names = HdfMesh.mesh_area_names(hdf_path)
                if not mesh_area_names:
                    return GeoDataFrame()
                face_dict = {"mesh_name": [], "face_id": [], "geometry": []}
                for mesh_name in mesh_area_names:
                    facepoints_index = hdf_file[
                        f"{HdfMesh.FLOW_AREA_2D_PATH}/{mesh_name}/Faces FacePoint Indexes"
                    ][()]
                    facepoints_coordinates = hdf_file[
                        f"{HdfMesh.FLOW_AREA_2D_PATH}/{mesh_name}/FacePoints Coordinate"
                    ][()]
                    faces_perimeter_info = hdf_file[
                        f"{HdfMesh.FLOW_AREA_2D_PATH}/{mesh_name}/Faces Perimeter Info"
                    ][()]
                    faces_perimeter_values = hdf_file[
                        f"{HdfMesh.FLOW_AREA_2D_PATH}/{mesh_name}/Faces Perimeter Values"
                    ][()]
                    face_id = -1
                    for pnt_a_index, pnt_b_index in facepoints_index:
                        face_id += 1
                        face_dict["mesh_name"].append(mesh_name)
                        face_dict["face_id"].append(face_id)
                        coordinates = list()
                        coordinates.append(facepoints_coordinates[pnt_a_index])
                        starting_row, count = faces_perimeter_info[face_id]
                        if count > 0:
                            coordinates += list(
                                faces_perimeter_values[starting_row : starting_row + count]
                            )
                        coordinates.append(facepoints_coordinates[pnt_b_index])
                        face_dict["geometry"].append(LineString(coordinates))
                return GeoDataFrame(face_dict, geometry="geometry", crs=HdfUtils.projection(hdf_path))
        except Exception as e:
            self.logger.error(f"Error reading mesh cell faces from {hdf_path}: {str(e)}")
            return GeoDataFrame()

    @staticmethod
    @standardize_input(file_type='geom_hdf')
    def get_geom_2d_flow_area_attrs(hdf_path: Path) -> Dict[str, Any]:
        """
        Return geometry 2D flow area attributes from a HEC-RAS HDF file.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.

        Returns
        -------
        Dict[str, Any]
            A dictionary containing the 2D flow area attributes.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                d2_flow_area = hdf_file.get(f"{HdfMesh.FLOW_AREA_2D_PATH}/Attributes")
                if d2_flow_area is not None and isinstance(d2_flow_area, h5py.Dataset):
                    result = {}
                    for name in d2_flow_area.dtype.names:
                        try:
                            value = d2_flow_area[name][()]
                            if isinstance(value, bytes):
                                value = value.decode('utf-8')
                            result[name] = value
                        except Exception as e:
                            logger.warning(f"Error converting attribute '{name}': {str(e)}")
                    return result
                else:
                    logger.info("No 2D Flow Area attributes found or invalid dataset.")
                    return {}
        except Exception as e:
            logger.error(f"Error reading 2D flow area attributes from {hdf_path}: {str(e)}")
            return {}

==================================================

File: c:\GH\ras-commander\ras_commander\HdfPlan.py
==================================================
"""
Class: HdfPlan

Attribution: A substantial amount of code in this file is sourced or derived 
from the https://github.com/fema-ffrd/rashdf library, 
released under MIT license and Copyright (c) 2024 fema-ffrd

The file has been forked and modified for use in RAS Commander.
"""

import h5py
import pandas as pd
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

from .HdfBase import HdfBase
from .HdfUtils import HdfUtils
from .Decorators import standardize_input, log_call
from .LoggingConfig import setup_logging, get_logger

logger = get_logger(__name__)


class HdfPlan:
    """
    A class for handling operations on HEC-RAS plan HDF files.

    This class provides methods for extracting and analyzing data from HEC-RAS plan HDF files,
    including simulation times, plan information, and geometry attributes.

    Methods in this class use the @standardize_input decorator to handle different input types
    (e.g., plan number, file path) and the @log_call decorator for logging method calls.

    Attributes:
        None

    Methods:
        get_simulation_start_time: Get the simulation start time.
        get_simulation_end_time: Get the simulation end time.
        get_unsteady_datetimes: Get a list of unsteady datetimes.
        get_plan_info_attrs: Get plan information attributes.
        get_plan_param_attrs: Get plan parameter attributes.
        get_meteorology_precip_attrs: Get precipitation attributes.
        get_geom_attrs: Get geometry attributes.
    """

    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def get_simulation_start_time(hdf_path: Path) -> datetime:
        """
        Get the simulation start time from the plan file.

        Args:
            hdf_path (Path): Path to the HEC-RAS plan HDF file.

        Returns:
            datetime: The simulation start time.

        Raises:
            ValueError: If there's an error reading the simulation start time.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                return HdfBase._get_simulation_start_time(hdf_file)
        except Exception as e:
            raise ValueError(f"Failed to get simulation start time: {str(e)}")

    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def get_simulation_end_time(hdf_path: Path) -> datetime:
        """
        Get the simulation end time from the plan file.

        Args:
            hdf_path (Path): Path to the HEC-RAS plan HDF file.

        Returns:
            datetime: The simulation end time.

        Raises:
            ValueError: If there's an error reading the simulation end time.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                plan_info = hdf_file.get('Plan Data/Plan Information')
                if plan_info is None:
                    raise ValueError("Plan Information not found in HDF file")
                time_str = plan_info.attrs.get('Simulation End Time')
                return datetime.strptime(time_str.decode('utf-8'), "%d%b%Y %H:%M:%S")
        except Exception as e:
            raise ValueError(f"Failed to get simulation end time: {str(e)}")

    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def get_unsteady_datetimes(hdf_path: Path) -> List[datetime]:
        """
        Get the list of unsteady datetimes from the HDF file.

        Args:
            hdf_path (Path): Path to the HEC-RAS plan HDF file.

        Returns:
            List[datetime]: A list of datetime objects representing the unsteady timestamps.

        Raises:
            ValueError: If there's an error retrieving the unsteady datetimes.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                return HdfBase._get_unsteady_datetimes(hdf_file)
        except Exception as e:
            raise ValueError(f"Failed to get unsteady datetimes: {str(e)}")

    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def get_plan_info_attrs(hdf_path: Path) -> Dict:
        """
        Get plan information attributes from a HEC-RAS HDF plan file.

        Args:
            hdf_path (Path): Path to the HEC-RAS plan HDF file.

        Returns:
            Dict: A dictionary containing the plan information attributes.

        Raises:
            ValueError: If there's an error retrieving the plan information attributes.
        """
        try:
            return HdfUtils.get_attrs(hdf_path, "Plan Data/Plan Information")
        except Exception as e:
            raise ValueError(f"Failed to get plan information attributes: {str(e)}")

    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def get_plan_param_attrs(hdf_path: Path) -> Dict:
        """
        Get plan parameter attributes from a HEC-RAS HDF plan file.

        Args:
            hdf_path (Path): Path to the HEC-RAS plan HDF file.

        Returns:
            Dict: A dictionary containing the plan parameter attributes.

        Raises:
            ValueError: If there's an error retrieving the plan parameter attributes.
        """
        try:
            return HdfUtils.get_attrs(hdf_path, "Plan Data/Plan Parameters")
        except Exception as e:
            raise ValueError(f"Failed to get plan parameter attributes: {str(e)}")

    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def get_meteorology_precip_attrs(hdf_path: Path) -> Dict:
        """
        Get precipitation attributes from a HEC-RAS HDF plan file.

        Args:
            hdf_path (Path): Path to the HEC-RAS plan HDF file.

        Returns:
            Dict: A dictionary containing the precipitation attributes.

        Raises:
            ValueError: If there's an error retrieving the precipitation attributes.
        """
        try:
            return HdfUtils.get_attrs(hdf_path, "Event Conditions/Meteorology/Precipitation")
        except Exception as e:
            raise ValueError(f"Failed to get precipitation attributes: {str(e)}")

    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def get_geom_attrs(hdf_path: Path) -> Dict:
        """
        Get geometry attributes from a HEC-RAS HDF plan file.

        Args:
            hdf_path (Path): Path to the HEC-RAS plan HDF file.

        Returns:
            Dict: A dictionary containing the geometry attributes.

        Raises:
            ValueError: If there's an error retrieving the geometry attributes.
        """
        try:
            return HdfUtils.get_attrs(hdf_path, "Geometry")
        except Exception as e:
            raise ValueError(f"Failed to get geometry attributes: {str(e)}")

==================================================

File: c:\GH\ras-commander\ras_commander\HdfResultsMesh.py
==================================================
"""
Class: HdfResultsMesh

Attribution: A substantial amount of code in this file is sourced or derived 
from the https://github.com/fema-ffrd/rashdf library, 
released under MIT license and Copyright (c) 2024 fema-ffrd

The file has been forked and modified for use in RAS Commander.
"""

import numpy as np
import pandas as pd
import xarray as xr
from pathlib import Path
import h5py
from typing import Union, List, Optional, Dict, Any, Tuple

from .HdfBase import HdfBase
from .HdfUtils import HdfUtils
from .Decorators import log_call, standardize_input
from .LoggingConfig import setup_logging, get_logger

logger = get_logger(__name__)

class HdfResultsMesh:
    """
    A class for handling mesh-related results from HEC-RAS HDF files.

    This class provides methods to extract and analyze mesh summary outputs,
    timeseries data, and various mesh-specific results such as water surface
    elevations, velocities, and errors.

    The class works with HEC-RAS plan HDF files and uses HdfBase and HdfUtils
    for common operations and utilities.

    Methods in this class use the @log_call decorator for logging and the
    @standardize_input decorator to handle different input types (e.g., 
    plan number, file path).

    Attributes:
        None

    Note:
        This class is designed to work with HEC-RAS version 6.0 and later.
    """

    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def mesh_summary_output(hdf_path: Path, var: str, round_to: str = "100ms") -> pd.DataFrame:
        """
        Return the summary output data for a given variable.

        Args:
            hdf_path (Path): Path to the HEC-RAS plan HDF file.
            var (str): The summary output variable to retrieve.
            round_to (str): The time unit to round the datetimes to. Default: "100ms" (100 milliseconds).

        Returns:
            pd.DataFrame: DataFrame containing the summary output data.

        Raises:
            ValueError: If there's an error processing the summary output data.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                return HdfResultsMesh._get_mesh_summary_output(hdf_file, var, round_to)
        except Exception as e:
            logger.error(f"Error in mesh_summary_output: {str(e)}")
            logger.error(f"Variable: {var}")
            raise ValueError(f"Failed to get summary output: {str(e)}")

    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def mesh_timeseries_output(hdf_path: Path, mesh_name: str, var: str, truncate: bool = True) -> xr.DataArray:
        """
        Get timeseries output for a specific mesh and variable.

        Args:
            hdf_path (Path): Path to the HDF file.
            mesh_name (str): Name of the mesh.
            var (str): Variable to retrieve. Valid options include:
                "Water Surface", "Face Velocity", "Cell Velocity X", "Cell Velocity Y",
                "Face Flow", "Face Water Surface", "Cell Volume", "Cell Volume Error",
                "Cell Water Surface Error", "Cell Courant", "Face Courant",
                "Cell Hydraulic Depth", "Cell Invert Depth",
                "Cell Cumulative Precipitation Depth", "Cell Divergence Term",
                "Cell Eddy Viscosity X", "Cell Eddy Viscosity Y", "Cell Flow Balance",
                "Cell Storage Term", "Cell Water Source Term", "Face Cumulative Volume",
                "Face Eddy Viscosity", "Face Flow Period Average", "Face Friction Term",
                "Face Pressure Gradient Term", "Face Shear Stress", "Face Tangential Velocity"
            truncate (bool): Whether to truncate the output (default True).

        Returns:
            xr.DataArray: DataArray containing the timeseries output.
        """
        with h5py.File(hdf_path, 'r') as hdf_file:
            return HdfResultsMesh._get_mesh_timeseries_output(hdf_file, mesh_name, var, truncate)

    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def mesh_faces_timeseries_output(hdf_path: Path, mesh_name: str) -> xr.Dataset:
        """
        Get timeseries output for all face-based variables of a specific mesh.

        Args:
            hdf_path (Path): Path to the HDF file.
            mesh_name (str): Name of the mesh.

        Returns:
            xr.Dataset: Dataset containing the timeseries output for all face-based variables.
        """
        face_vars = ["Face Velocity", "Face Flow"]
        datasets = []
        
        for var in face_vars:
            try:
                da = HdfResultsMesh.mesh_timeseries_output(hdf_path, mesh_name, var)
                # Assign the variable name as the DataArray name
                da.name = var.lower().replace(' ', '_')
                datasets.append(da)
            except Exception as e:
                logger.warning(f"Failed to process {var} for mesh {mesh_name}: {str(e)}")
        
        if not datasets:
            logger.error(f"No valid data found for mesh {mesh_name}")
            return xr.Dataset()
        
        try:
            return xr.merge(datasets)
        except Exception as e:
            logger.error(f"Failed to merge datasets: {str(e)}")
            return xr.Dataset()

    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def mesh_cells_timeseries_output(hdf_path: Path, mesh_names: Optional[Union[str, List[str]]] = None, var: Optional[str] = None, truncate: bool = False, ras_object: Optional[Any] = None) -> Dict[str, xr.Dataset]:
        """
        Get mesh cells timeseries output for specified meshes and variables.

        Args:
            hdf_path (Union[str, Path]): Path to the HDF file.
            mesh_names (Optional[Union[str, List[str]]]): Name(s) of the mesh(es). If None, processes all available meshes.
            var (Optional[str]): Name of the variable to retrieve. If None, retrieves all variables.
            truncate (bool): If True, truncates the output to remove trailing zeros.
            ras_object (Optional[Any]): RAS object, if available.

        Returns:
            Dict[str, xr.Dataset]: A dictionary of xarray Datasets, one for each mesh, containing the mesh cells timeseries output.

        Raises:
            ValueError: If there's an error processing the timeseries output data.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                return HdfResultsMesh._mesh_cells_timeseries_output(hdf_file, mesh_names, var, truncate)
        except Exception as e:
            logger.error(f"Error in mesh_cells_timeseries_output: {str(e)}")
            raise ValueError(f"Error processing timeseries output data: {e}")

    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def mesh_last_iter(hdf_path: Path) -> pd.DataFrame:
        """
        Get last iteration count for each mesh cell.

        Args:
            hdf_path (Path): Path to the HDF file.

        Returns:
            pd.DataFrame: DataFrame containing last iteration counts.
        """
        return HdfResultsMesh._get_mesh_summary_output(hdf_path, "Cell Last Iteration")


    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def mesh_max_ws(hdf_path: Path, round_to: str = "100ms") -> pd.DataFrame:
        """
        Get maximum iteration count for each mesh cell.

        Args:
            hdf_path (Path): Path to the HDF file.
            round_to (str): Time rounding specification (default "100ms").

        Returns:
            pd.DataFrame: DataFrame containing maximum iteration counts.

        Raises:
            ValueError: If there's an error processing the maximum iteration data.
            
        Note: The Maximum Iteration is labeled as "Cell Last Iteration" in the HDF file 
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                return HdfResultsMesh._get_mesh_summary_output(hdf_file, "Maximum Water Surface", round_to)
        except Exception as e:
            logger.error(f"Error in mesh_max_ws: {str(e)}")
            raise ValueError(f"Failed to get maximum water surface: {str(e)}")
        




    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def mesh_min_ws(hdf_path: Path, round_to: str = "100ms") -> pd.DataFrame:
        """
        Get minimum water surface elevation for each mesh cell.

        Args:
            hdf_path (Path): Path to the HDF file.
            round_to (str): Time rounding specification (default "100ms").

        Returns:
            pd.DataFrame: DataFrame containing minimum water surface elevations.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                return HdfResultsMesh._get_mesh_summary_output(hdf_file, "Minimum Water Surface", round_to)
        except Exception as e:
            logger.error(f"Error in mesh_min_ws: {str(e)}")
            raise ValueError(f"Failed to get minimum water surface: {str(e)}")

    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def mesh_max_face_v(hdf_path: Path, round_to: str = "100ms") -> pd.DataFrame:
        """
        Get maximum face velocity for each mesh cell.

        Args:
            hdf_path (Path): Path to the HDF file.
            round_to (str): Time rounding specification (default "100ms").

        Returns:
            pd.DataFrame: DataFrame containing maximum face velocities.

        Raises:
            ValueError: If there's an error processing the maximum face velocity data.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                return HdfResultsMesh._get_mesh_summary_output(hdf_file, "Maximum Face Velocity", round_to)
        except Exception as e:
            logger.error(f"Error in mesh_max_face_v: {str(e)}")
            raise ValueError(f"Failed to get maximum face velocity: {str(e)}")

    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def mesh_min_face_v(hdf_path: Path, round_to: str = "100ms") -> pd.DataFrame:
        """
        Get minimum face velocity for each mesh cell.

        Args:
            hdf_path (Path): Path to the HDF file.
            round_to (str): Time rounding specification (default "100ms").

        Returns:
            pd.DataFrame: DataFrame containing minimum face velocities.

        Raises:
            ValueError: If there's an error processing the minimum face velocity data.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                return HdfResultsMesh._get_mesh_summary_output(hdf_file, "Minimum Face Velocity", round_to)
        except Exception as e:
            logger.error(f"Error in mesh_min_face_v: {str(e)}")
            raise ValueError(f"Failed to get minimum face velocity: {str(e)}")

    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def mesh_max_ws_err(hdf_path: Path, round_to: str = "100ms") -> pd.DataFrame:
        """
        Get maximum water surface error for each mesh cell.

        Args:
            hdf_path (Path): Path to the HDF file.
            round_to (str): Time rounding specification (default "100ms").

        Returns:
            pd.DataFrame: DataFrame containing maximum water surface errors.

        Raises:
            ValueError: If there's an error processing the maximum water surface error data.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                return HdfResultsMesh._get_mesh_summary_output(hdf_file, "Cell Maximum Water Surface Error", round_to)
        except Exception as e:
            logger.error(f"Error in mesh_max_ws_err: {str(e)}")
            raise ValueError(f"Failed to get maximum water surface error: {str(e)}")


    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def mesh_max_iter(hdf_path: Path, round_to: str = "100ms") -> pd.DataFrame:
        """
        Get maximum iteration count for each mesh cell.

        Args:
            hdf_path (Path): Path to the HDF file.
            round_to (str): Time rounding specification (default "100ms").

        Returns:
            pd.DataFrame: DataFrame containing maximum iteration counts.

        Raises:
            ValueError: If there's an error processing the maximum iteration data.
            
        Note: The Maximum Iteration is labeled as "Cell Last Iteration" in the HDF file 
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                return HdfResultsMesh._get_mesh_summary_output(hdf_file, "Cell Last Iteration", round_to)
        except Exception as e:
            logger.error(f"Error in mesh_max_iter: {str(e)}")
            raise ValueError(f"Failed to get maximum iteration count: {str(e)}")
        
        
        


    @staticmethod
    def _get_mesh_timeseries_output_path(mesh_name: str, var_name: str) -> str:
        """
        Get the HDF path for mesh timeseries output.

        Args:
            mesh_name (str): Name of the mesh.
            var_name (str): Name of the variable.

        Returns:
            str: The HDF path for the specified mesh and variable.
        """
        return f"Results/Unsteady/Output/Output Blocks/Base Output/Unsteady Time Series/2D Flow Areas/{mesh_name}/{var_name}"


    @staticmethod
    def _mesh_cells_timeseries_output(hdf_file: h5py.File, mesh_names: Optional[Union[str, List[str]]] = None, var: Optional[str] = None, truncate: bool = False) -> Dict[str, xr.Dataset]:
        """
        Get mesh cells timeseries output for specified meshes and variables.

        Args:
            hdf_file (h5py.File): Open HDF file object.
            mesh_names (Optional[Union[str, List[str]]]): Name(s) of the mesh(es). If None, processes all available meshes.
            var (Optional[str]): Name of the variable to retrieve. If None, retrieves all variables.
            truncate (bool): If True, truncates the output to remove trailing zeros.

        Returns:
            Dict[str, xr.Dataset]: A dictionary of xarray Datasets, one for each mesh, containing the mesh cells timeseries output.

        Raises:
            ValueError: If there's an error processing the timeseries output data.
        """
        TIME_SERIES_OUTPUT_VARS_CELLS = [
            "Water Surface",
            "Depth",
            "Velocity",
            "Velocity X",
            "Velocity Y",
            "Froude Number",
            "Courant Number",
            "Shear Stress",
            "Bed Elevation",
            "Precipitation Rate",
            "Infiltration Rate",
            "Evaporation Rate",
            "Percolation Rate",
            "Groundwater Elevation",
            "Groundwater Depth",
            "Groundwater Flow",
            "Groundwater Velocity",
            "Groundwater Velocity X",
            "Groundwater Velocity Y",
        ]

        try:
            start_time = HdfBase._get_simulation_start_time(hdf_file)
            time_stamps = HdfBase._get_unsteady_datetimes(hdf_file)

            if mesh_names is None:
                mesh_names = HdfResultsMesh._get_available_meshes(hdf_file)
            elif isinstance(mesh_names, str):
                mesh_names = [mesh_names]

            if var:
                variables = [var]
            else:
                variables = TIME_SERIES_OUTPUT_VARS_CELLS

            datasets = {}
            for mesh_name in mesh_names:
                data_vars = {}
                for variable in variables:
                    try:
                        path = HdfResultsMesh._get_mesh_timeseries_output_path(mesh_name, variable)
                        dataset = hdf_file[path]
                        values = dataset[:]
                        units = dataset.attrs.get("Units", "").decode("utf-8")

                        if truncate:
                            last_nonzero = np.max(np.nonzero(values)[1]) + 1 if values.size > 0 else 0
                            values = values[:, :last_nonzero]
                            truncated_time_stamps = time_stamps[:last_nonzero]
                        else:
                            truncated_time_stamps = time_stamps

                        if values.shape[0] != len(truncated_time_stamps):
                            logger.warning(f"Mismatch between number of time steps ({len(truncated_time_stamps)}) and data shape ({values.shape}) for variable {variable}")
                            continue

                        data_vars[variable] = xr.DataArray(
                            data=values,
                            dims=['time', 'cell_id'],
                            coords={'time': truncated_time_stamps, 'cell_id': np.arange(values.shape[1])},
                            attrs={'units': units}
                        )
                    except KeyError:
                        logger.warning(f"Variable '{variable}' not found in the HDF file for mesh '{mesh_name}'. Skipping.")
                    except Exception as e:
                        logger.error(f"Error processing variable '{variable}' for mesh '{mesh_name}': {str(e)}")

                if data_vars:
                    datasets[mesh_name] = xr.Dataset(
                        data_vars=data_vars,
                        attrs={'mesh_name': mesh_name, 'start_time': start_time}
                    )
                else:
                    logger.warning(f"No valid data variables found for mesh '{mesh_name}'")

            return datasets
        except Exception as e:
            logger.error(f"Error in _mesh_cells_timeseries_output: {str(e)}")
            raise ValueError(f"Error processing timeseries output data: {e}")



    @staticmethod
    def _get_mesh_timeseries_output(hdf_file: h5py.File, mesh_name: str, var: str, truncate: bool = True) -> xr.DataArray:
        """
        Get timeseries output for a specific mesh and variable.

        Args:
            hdf_file (h5py.File): Open HDF file object.
            mesh_name (str): Name of the mesh.
            var (str): Variable name to retrieve. Valid options include:
                "Water Surface", "Face Velocity", "Cell Velocity X", "Cell Velocity Y",
                "Face Flow", "Face Water Surface", "Cell Volume", "Cell Volume Error",
                "Cell Water Surface Error", "Cell Courant", "Face Courant",
                "Cell Hydraulic Depth", "Cell Invert Depth",
                "Cell Cumulative Precipitation Depth", "Cell Divergence Term",
                "Cell Eddy Viscosity X", "Cell Eddy Viscosity Y", "Cell Flow Balance",
                "Cell Storage Term", "Cell Water Source Term", "Face Cumulative Volume",
                "Face Eddy Viscosity", "Face Flow Period Average", "Face Friction Term",
                "Face Pressure Gradient Term", "Face Shear Stress", "Face Tangential Velocity"
            truncate (bool): Whether to truncate the output to remove trailing zeros (default True).

        Returns:
            xr.DataArray: DataArray containing the timeseries output.

        Raises:
            ValueError: If the specified path is not found in the HDF file or if there's an error processing the data.
        """
        try:
            path = HdfResultsMesh._get_mesh_timeseries_output_path(mesh_name, var)
            
            if path not in hdf_file:
                raise ValueError(f"Path {path} not found in HDF file")

            # Use h5py to get the dataset
            dataset = hdf_file[path]
            values = dataset[:]
            units = dataset.attrs.get("Units", "").decode("utf-8")
            times = HdfBase._get_unsteady_datetimes(hdf_file)

            if truncate:
                non_zero = np.nonzero(values)[0]
                if len(non_zero) > 0:
                    start, end = non_zero[0], non_zero[-1] + 1
                    values = values[start:end]
                    times = times[start:end]

            # Create xarray DataArray
            dims = ["time", "cell"] if values.ndim == 2 else ["time"]
            coords = {"time": times}
            if values.ndim == 2:
                coords["cell"] = np.arange(values.shape[1])

            return xr.DataArray(
                values,
                coords=coords,
                dims=dims,
                attrs={"units": units, "mesh_name": mesh_name, "variable": var},
            )
        except Exception as e:
            logger.error(f"Error in get_mesh_timeseries_output: {str(e)}")
            raise ValueError(f"Failed to get timeseries output: {str(e)}")


    @staticmethod
    def _get_mesh_timeseries_output_values_units(hdf_file: h5py.File, mesh_name: str, var: str) -> Tuple[np.ndarray, str]:
        """
        Get the mesh timeseries output values and units for a specific variable from the HDF file.

        Args:
            hdf_file (h5py.File): Open HDF file object.
            mesh_name (str): Name of the mesh.
            var (str): Variable name to retrieve.

        Returns:
            Tuple[np.ndarray, str]: A tuple containing the output values and units.
        """
        path = HdfResultsMesh._get_mesh_timeseries_output_path(mesh_name, var)
        group = hdf_file[path]
        values = group[:]
        units = group.attrs.get("Units")
        if units is not None:
            units = units.decode("utf-8")
        return values, units


    @staticmethod
    def _get_available_meshes(hdf_file: h5py.File) -> List[str]:
        """
        Get the names of all available meshes in the HDF file.

        Args:
            hdf_file (h5py.File): Open HDF file object.

        Returns:
            List[str]: A list of mesh names.
        """
        mesh_names = []
        base_path = "Geometry/2D Flow Areas"
        if base_path in hdf_file:
            for name in hdf_file[base_path]:
                if isinstance(hdf_file[f"{base_path}/{name}"], h5py.Group):
                    mesh_names.append(name)
        return mesh_names

    @staticmethod
    def _get_mesh_summary_output(hdf_file: h5py.File, var: str, round_to: str = "100ms") -> pd.DataFrame:
        """
        Get the summary output data for a given variable from the HDF file.

        This method retrieves summary output data for all 2D flow areas (meshes) in the HDF file
        for a specified variable. It handles both 1D and 2D datasets.
        Group attributes are added as metadata to the DataFrame.

        Args:
            hdf_file (h5py.File): Open HDF file object.
            var (str): The summary output variable to retrieve.
            round_to (str): The time unit to round the datetimes to. Default is "100ms".

        Returns:
            pd.DataFrame: A DataFrame containing the summary output data with attributes as metadata.

        Raises:
            ValueError: If the HDF file cannot be opened or read, or if the requested data is not found.
        """
        try:
            dfs = []
            start_time = HdfBase._get_simulation_start_time(hdf_file)
            
            logger.info(f"Processing summary output for variable: {var}")
            for mesh_name, cell_count in HdfBase._get_2d_flow_area_names_and_counts(hdf_file):
                logger.debug(f"Processing mesh: {mesh_name} with {cell_count} cells")
                group = HdfResultsMesh._get_mesh_summary_output_group(hdf_file, mesh_name, var)
                
                data = group[:]
                logger.debug(f"Data shape for {var} in {mesh_name}: {data.shape}")
                logger.debug(f"Data type: {data.dtype}")
                logger.debug(f"Attributes: {dict(group.attrs)}")
                
                if data.ndim == 2 and data.shape[0] == 2:
                    # This is the case for "Maximum Water Surface"
                    row_variables = group.attrs.get('Row Variables', [b'Value', b'Time'])
                    row_variables = [v.decode('utf-8').strip() for v in row_variables]
                    
                    df = pd.DataFrame({
                        "mesh_name": [mesh_name] * data.shape[1],
                        "cell_id": range(data.shape[1]),
                        f"{var.lower().replace(' ', '_')}": data[0, :],
                        f"{var.lower().replace(' ', '_')}_time": HdfUtils._ras_timesteps_to_datetimes(
                            data[1, :], start_time, time_unit="days", round_to=round_to
                        )
                    })
                elif data.ndim == 1:
                    # Handle 1D datasets (like Cell Last Iteration)
                    df = pd.DataFrame({
                        "mesh_name": [mesh_name] * len(data),
                        "cell_id": range(len(data)),
                        var.lower().replace(' ', '_'): data
                    })
                else:
                    raise ValueError(f"Unexpected data shape for {var} in {mesh_name}. "
                                     f"Got shape {data.shape}")
                
                # Add group attributes as metadata
                df.attrs['mesh_name'] = mesh_name
                for attr_name, attr_value in group.attrs.items():
                    if isinstance(attr_value, bytes):
                        attr_value = attr_value.decode('utf-8')
                    elif isinstance(attr_value, np.ndarray):
                        attr_value = attr_value.tolist()
                    df.attrs[attr_name] = attr_value
                
                dfs.append(df)
            
            result = pd.concat(dfs, ignore_index=True)
            
            # Combine attributes from all meshes
            combined_attrs = {}
            for df in dfs:
                for key, value in df.attrs.items():
                    if key not in combined_attrs:
                        combined_attrs[key] = value
                    elif combined_attrs[key] != value:
                        combined_attrs[key] = f"Multiple values: {combined_attrs[key]}, {value}"
            
            result.attrs.update(combined_attrs)
            
            logger.info(f"Processed {len(result)} rows of summary output data")
            return result
        
        except (KeyError, ValueError, AttributeError) as e:
            logger.error(f"Error processing summary output data: {e}")
            raise ValueError(f"Error processing summary output data: {e}")
        

    @staticmethod
    def _get_mesh_summary_output_group(hdf_file: h5py.File, mesh_name: str, var: str) -> Union[h5py.Group, h5py.Dataset]:
        """
        Return the HDF group for a given mesh and summary output variable.

        Args:
            hdf_file (h5py.File): Open HDF file object.
            mesh_name (str): Name of the mesh.
            var (str): Name of the summary output variable.

        Returns:
            Union[h5py.Group, h5py.Dataset]: The HDF group or dataset for the specified mesh and variable.

        Raises:
            ValueError: If the specified group or dataset is not found in the HDF file.
        """
        output_path = f"Results/Unsteady/Output/Output Blocks/Base Output/Summary Output/2D Flow Areas/{mesh_name}/{var}"
        output_item = hdf_file.get(output_path)
        if output_item is None:
            raise ValueError(f"Could not find HDF group or dataset at path '{output_path}'")
        return output_item

==================================================

File: c:\GH\ras-commander\ras_commander\HdfResultsPlan.py
==================================================
"""
Class: HdfResultsPlan

Attribution: A substantial amount of code in this file is sourced or derived 
from the https://github.com/fema-ffrd/rashdf library, 
released under MIT license and Copyright (c) 2024 fema-ffrd

The file has been forked and modified for use in RAS Commander.
"""

from typing import Dict, List, Union, Optional
from pathlib import Path
import h5py
import pandas as pd
import xarray as xr
from .Decorators import standardize_input, log_call
from .HdfBase import HdfBase
from .HdfResultsXsec import HdfResultsXsec
from .LoggingConfig import get_logger
import numpy as np
from datetime import datetime

logger = get_logger(__name__)


class HdfResultsPlan:
    """
    A class for handling HEC-RAS plan HDF file results related to unsteady flow and reference line/point outputs.

    This class provides methods for extracting and analyzing data from HEC-RAS plan HDF files,
    focusing on unsteady flow results, volume accounting, and reference line/point time series outputs.

    Methods in this class use the @standardize_input decorator to handle different input types
    (e.g., plan number, file path) and the @log_call decorator for logging method calls.

    Attributes:
        None

    Note:
        This class is designed to work with HEC-RAS plan HDF files and requires the HdfBase class
        for some of its operations.
    """

    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def get_results_unsteady_attrs(hdf_path: Path) -> Dict:
        """
        Get unsteady attributes from a HEC-RAS HDF plan file.

        Args:
            hdf_path (Path): Path to the HEC-RAS plan HDF file.

        Returns:
            Dict: A dictionary containing the unsteady attributes.

        Raises:
            FileNotFoundError: If the specified HDF file is not found.
            KeyError: If the "Results/Unsteady" group is not found in the HDF file.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                if "Results/Unsteady" not in hdf_file:
                    raise KeyError("Results/Unsteady group not found in the HDF file.")
                return dict(hdf_file["Results/Unsteady"].attrs)
        except FileNotFoundError:
            raise FileNotFoundError(f"HDF file not found: {hdf_path}")
        except Exception as e:
            raise RuntimeError(f"Error reading unsteady attributes: {str(e)}")

    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def get_results_unsteady_summary_attrs(hdf_path: Path) -> Dict:
        """
        Get results unsteady summary attributes from a HEC-RAS HDF plan file.

        Args:
            hdf_path (Path): Path to the HEC-RAS plan HDF file.

        Returns:
            Dict: A dictionary containing the results unsteady summary attributes.

        Raises:
            FileNotFoundError: If the specified HDF file is not found.
            KeyError: If the "Results/Unsteady/Summary" group is not found in the HDF file.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                if "Results/Unsteady/Summary" not in hdf_file:
                    raise KeyError("Results/Unsteady/Summary group not found in the HDF file.")
                return dict(hdf_file["Results/Unsteady/Summary"].attrs)
        except FileNotFoundError:
            raise FileNotFoundError(f"HDF file not found: {hdf_path}")
        except Exception as e:
            raise RuntimeError(f"Error reading unsteady summary attributes: {str(e)}")

    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def get_results_volume_accounting_attrs(hdf_path: Path) -> Dict:
        """
        Get volume accounting attributes from a HEC-RAS HDF plan file.

        Args:
            hdf_path (Path): Path to the HEC-RAS plan HDF file.

        Returns:
            Dict: A dictionary containing the volume accounting attributes.

        Raises:
            FileNotFoundError: If the specified HDF file is not found.
            KeyError: If the "Results/Unsteady/Summary/Volume Accounting" group is not found in the HDF file.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                if "Results/Unsteady/Summary/Volume Accounting" not in hdf_file:
                    raise KeyError("Results/Unsteady/Summary/Volume Accounting group not found in the HDF file.")
                return dict(hdf_file["Results/Unsteady/Summary/Volume Accounting"].attrs)
        except FileNotFoundError:
            raise FileNotFoundError(f"HDF file not found: {hdf_path}")
        except Exception as e:
            raise RuntimeError(f"Error reading volume accounting attributes: {str(e)}")

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def get_runtime_data(hdf_path: Path) -> Optional[pd.DataFrame]:
        """
        Extract runtime and compute time data from a single HDF file.

        Args:
            hdf_path (Path): The full path to the HDF file.

        Returns:
            Optional[pd.DataFrame]: DataFrame containing runtime and compute time data, or None if data extraction fails.
        """
        if hdf_path is None:
            logger.error(f"Could not find HDF file for input")
            return None

        with h5py.File(hdf_path, 'r') as hdf_file:
            logger.info(f"Extracting Plan Information from: {Path(hdf_file.filename).name}")
            plan_info = hdf_file.get('/Plan Data/Plan Information')
            if plan_info is None:
                logger.warning("Group '/Plan Data/Plan Information' not found.")
                return None

            plan_name = plan_info.attrs.get('Plan Name', 'Unknown')
            plan_name = plan_name.decode('utf-8') if isinstance(plan_name, bytes) else plan_name
            logger.info(f"Plan Name: {plan_name}")

            start_time_str = plan_info.attrs.get('Simulation Start Time', 'Unknown')
            end_time_str = plan_info.attrs.get('Simulation End Time', 'Unknown')
            start_time_str = start_time_str.decode('utf-8') if isinstance(start_time_str, bytes) else start_time_str
            end_time_str = end_time_str.decode('utf-8') if isinstance(end_time_str, bytes) else end_time_str

            start_time = datetime.strptime(start_time_str, "%d%b%Y %H:%M:%S")
            end_time = datetime.strptime(end_time_str, "%d%b%Y %H:%M:%S")
            simulation_duration = end_time - start_time
            simulation_hours = simulation_duration.total_seconds() / 3600

            logger.info(f"Simulation Start Time: {start_time_str}")
            logger.info(f"Simulation End Time: {end_time_str}")
            logger.info(f"Simulation Duration (hours): {simulation_hours}")

            compute_processes = hdf_file.get('/Results/Summary/Compute Processes')
            if compute_processes is None:
                logger.warning("Dataset '/Results/Summary/Compute Processes' not found.")
                return None

            process_names = [name.decode('utf-8') for name in compute_processes['Process'][:]]
            filenames = [filename.decode('utf-8') for filename in compute_processes['Filename'][:]]
            completion_times = compute_processes['Compute Time (ms)'][:]

            compute_processes_df = pd.DataFrame({
                'Process': process_names,
                'Filename': filenames,
                'Compute Time (ms)': completion_times,
                'Compute Time (s)': completion_times / 1000,
                'Compute Time (hours)': completion_times / (1000 * 3600)
            })

            logger.debug("Compute processes DataFrame:")
            logger.debug(compute_processes_df)

            compute_processes_summary = {
                'Plan Name': [plan_name],
                'File Name': [Path(hdf_file.filename).name],
                'Simulation Start Time': [start_time_str],
                'Simulation End Time': [end_time_str],
                'Simulation Duration (s)': [simulation_duration.total_seconds()],
                'Simulation Time (hr)': [simulation_hours],
                'Completing Geometry (hr)': [compute_processes_df[compute_processes_df['Process'] == 'Completing Geometry']['Compute Time (hours)'].values[0] if 'Completing Geometry' in compute_processes_df['Process'].values else 'N/A'],
                'Preprocessing Geometry (hr)': [compute_processes_df[compute_processes_df['Process'] == 'Preprocessing Geometry']['Compute Time (hours)'].values[0] if 'Preprocessing Geometry' in compute_processes_df['Process'].values else 'N/A'],
                'Completing Event Conditions (hr)': [compute_processes_df[compute_processes_df['Process'] == 'Completing Event Conditions']['Compute Time (hours)'].values[0] if 'Completing Event Conditions' in compute_processes_df['Process'].values else 'N/A'],
                'Unsteady Flow Computations (hr)': [compute_processes_df[compute_processes_df['Process'] == 'Unsteady Flow Computations']['Compute Time (hours)'].values[0] if 'Unsteady Flow Computations' in compute_processes_df['Process'].values else 'N/A'],
                'Complete Process (hr)': [compute_processes_df['Compute Time (hours)'].sum()]
            }

            compute_processes_summary['Unsteady Flow Speed (hr/hr)'] = [simulation_hours / compute_processes_summary['Unsteady Flow Computations (hr)'][0] if compute_processes_summary['Unsteady Flow Computations (hr)'][0] != 'N/A' else 'N/A']
            compute_processes_summary['Complete Process Speed (hr/hr)'] = [simulation_hours / compute_processes_summary['Complete Process (hr)'][0] if compute_processes_summary['Complete Process (hr)'][0] != 'N/A' else 'N/A']

            compute_summary_df = pd.DataFrame(compute_processes_summary)
            logger.debug("Compute summary DataFrame:")
            logger.debug(compute_summary_df)

            return compute_summary_df



    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def reference_timeseries_output(hdf_path: Path, reftype: str = "lines") -> xr.Dataset:
        """
        Get timeseries output for reference lines or points.

        Args:
            hdf_path (Path): Path to the HDF file.
            reftype (str): Type of reference, either "lines" or "points" (default "lines").

        Returns:
            xr.Dataset: Dataset containing the timeseries output for reference lines or points.

        Raises:
            FileNotFoundError: If the specified HDF file is not found.
            ValueError: If an invalid reftype is provided.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                return HdfResultsPlan._reference_timeseries_output(hdf_file, reftype)
        except FileNotFoundError:
            raise FileNotFoundError(f"HDF file not found: {hdf_path}")
        except ValueError as ve:
            raise ValueError(f"Invalid reftype: {str(ve)}")
        except Exception as e:
            raise RuntimeError(f"Error getting reference timeseries output: {str(e)}")


    @staticmethod
    def _reference_timeseries_output(hdf_file: h5py.File, reftype: str = "lines") -> xr.Dataset:
        """
        Private method to return timeseries output data for reference lines or points from a HEC-RAS HDF plan file.

        Parameters
        ----------
        hdf_file : h5py.File
            Open HDF file object.
        reftype : str, optional
            The type of reference data to retrieve. Must be either "lines" or "points".
            (default: "lines")

        Returns
        -------
        xr.Dataset
            An xarray Dataset with reference line or point timeseries data.
            Returns an empty Dataset if the reference output data is not found.

        Raises
        ------
        ValueError
            If reftype is not "lines" or "points".
        """
        if reftype == "lines":
            output_path = "Results/Unsteady/Output/Output Blocks/Base Output/Unsteady Time Series/Reference Lines"
            abbrev = "refln"
        elif reftype == "points":
            output_path = "Results/Unsteady/Output/Output Blocks/Base Output/Unsteady Time Series/Reference Points"
            abbrev = "refpt"
        else:
            raise ValueError('reftype must be either "lines" or "points".')

        try:
            reference_group = hdf_file[output_path]
        except KeyError:
            logger.error(f"Could not find HDF group at path '{output_path}'. "
                         f"The Plan HDF file may not contain reference {reftype[:-1]} output data.")
            return xr.Dataset()

        reference_names = reference_group["Name"][:]
        names = []
        mesh_areas = []
        for s in reference_names:
            name, mesh_area = s.decode("utf-8").split("|")
            names.append(name)
            mesh_areas.append(mesh_area)

        times = HdfBase._get_unsteady_datetimes(hdf_file)

        das = {}
        for var in ["Flow", "Velocity", "Water Surface"]:
            group = reference_group.get(var)
            if group is None:
                continue
            values = group[:]
            units = group.attrs["Units"].decode("utf-8")
            da = xr.DataArray(
                values,
                name=var,
                dims=["time", f"{abbrev}_id"],
                coords={
                    "time": times,
                    f"{abbrev}_id": range(values.shape[1]),
                    f"{abbrev}_name": (f"{abbrev}_id", names),
                    "mesh_name": (f"{abbrev}_id", mesh_areas),
                },
                attrs={"units": units, "hdf_path": f"{output_path}/{var}"},
            )
            das[var] = da
        return xr.Dataset(das)

        


    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def reference_lines_timeseries_output(hdf_path: Path) -> xr.Dataset:
        """
        Get timeseries output for reference lines.

        Args:
            hdf_path (Path): Path to the HDF file.

        Returns:
            xr.Dataset: Dataset containing the timeseries output for reference lines.

        Raises:
            FileNotFoundError: If the specified HDF file is not found.
        """
        return HdfResultsPlan.reference_timeseries_output(hdf_path, reftype="lines")

    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def reference_points_timeseries_output(hdf_path: Path) -> xr.Dataset:
        """
        Get timeseries output for reference points.

        Args:
            hdf_path (Path): Path to the HDF file.

        Returns:
            xr.Dataset: Dataset containing the timeseries output for reference points.

        Raises:
            FileNotFoundError: If the specified HDF file is not found.
        """
        return HdfResultsPlan.reference_timeseries_output(hdf_path, reftype="points")
    
    @staticmethod
    @log_call
    @standardize_input(file_type='plan_hdf')
    def reference_summary_output(hdf_path: Path, reftype: str = "lines") -> pd.DataFrame:
        """
        Get summary output for reference lines or points.

        Args:
            hdf_path (Path): Path to the HDF file.
            reftype (str): Type of reference, either "lines" or "points" (default "lines").

        Returns:
            pd.DataFrame: DataFrame containing the summary output for reference lines or points.

        Raises:
            ValueError: If an invalid reftype is provided.
        """
        if not hdf_path.exists():
            logger.error(f"HDF file not found: {hdf_path}")
            return pd.DataFrame()  # Return an empty DataFrame if the path doesn't exist

        try:
            # Get the timeseries output
            ds = HdfResultsPlan.reference_timeseries_output(hdf_path, reftype)
            
            if 'station' not in ds.dims:
                logger.error("No 'station' dimension found in the dataset.")
                return pd.DataFrame()  # Return an empty DataFrame if 'station' dimension is missing
            
            # Calculate summary statistics
            summary = ds.groupby('station').agg({
                'WSE': ['min', 'max', 'mean'],
                'Q': ['min', 'max', 'mean']
            })
            
            # Flatten column names
            summary.columns = ['_'.join(col).strip() for col in summary.columns.values]
            
            # Reset index to make 'station' a column
            summary = summary.reset_index()
            
            return summary
        except ValueError as ve:
            logger.error(f"Invalid reftype: {str(ve)}")
            return pd.DataFrame()  # Return an empty DataFrame on ValueError
        except Exception as e:
            logger.error(f"Error in reference_summary_output: {str(e)}")
            return pd.DataFrame()  # Return an empty DataFrame on general error

==================================================

File: c:\GH\ras-commander\ras_commander\HdfResultsXsec.py
==================================================
"""
Class: HdfResultsXsec

Attribution: A substantial amount of code in this file is sourced or derived 
from the https://github.com/fema-ffrd/rashdf library, 
released under MIT license and Copyright (c) 2024 fema-ffrd

The file has been forked and modified for use in RAS Commander.
"""

import h5py
import numpy as np
import pandas as pd
from pathlib import Path
from typing import Union, Optional, List
from .HdfBase import HdfBase
from .HdfUtils import HdfUtils
from .Decorators import standardize_input, log_call
from .LoggingConfig import setup_logging, get_logger
import xarray as xr

logger = get_logger(__name__)


class HdfResultsXsec:
    """
    A class for handling cross-section results from HEC-RAS HDF files.

    This class provides methods to extract and process steady flow simulation results
    for cross-sections, including water surface elevations, flow rates, energy grades,
    and additional parameters such as encroachment stations and velocities.

    The class relies on the HdfBase and HdfUtils classes for core HDF file operations
    and utility functions.

    Attributes:
        None

    Methods:
        steady_profile_xs_output: Extract steady profile cross-section output for a specified variable.
        cross_sections_wsel: Get water surface elevation data for cross-sections.
        cross_sections_flow: Get flow data for cross-sections.
        cross_sections_energy_grade: Get energy grade data for cross-sections.
        cross_sections_additional_enc_station_left: Get left encroachment station data for cross-sections.
        cross_sections_additional_enc_station_right: Get right encroachment station data for cross-sections.
        cross_sections_additional_area_total: Get total ineffective area data for cross-sections.
        cross_sections_additional_velocity_total: Get total velocity data for cross-sections.
    """

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def steady_profile_xs_output(hdf_path: Path, var: str, round_to: int = 2) -> pd.DataFrame:
        """
        Create a DataFrame from steady cross section results based on the specified variable.

        Parameters:
        ----------
        hdf_path : Path
            Path to the HEC-RAS plan HDF file.
        var : str
            The variable to extract from the steady cross section results.
        round_to : int, optional
            Number of decimal places to round the results to (default is 2).

        Returns:
        -------
        pd.DataFrame
            DataFrame containing the steady cross section results for the specified variable.
        """
        XS_STEADY_OUTPUT_ADDITIONAL = [
            "Additional Encroachment Station Left",
            "Additional Encroachment Station Right",
            "Additional Area Ineffective Total",
            "Additional Velocity Total",
        ]
                
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                # Determine the correct path based on the variable
                if var in XS_STEADY_OUTPUT_ADDITIONAL:
                    path = f"/Results/Steady/Cross Sections/Additional Output/{var}"
                else:
                    path = f"/Results/Steady/Cross Sections/{var}"
                
                # Check if the path exists in the HDF file
                if path not in hdf_file:
                    return pd.DataFrame()

                # Get the profile names
                profiles = HdfBase.steady_flow_names(hdf_path)
                
                # Extract the steady data
                steady_data = hdf_file[path]
                
                # Create a DataFrame with profiles as index
                df = pd.DataFrame(steady_data, index=profiles)
                
                # Transpose the DataFrame and round values
                df_t = df.T.copy()
                for p in profiles:
                    df_t[p] = df_t[p].apply(lambda x: round(x, round_to))

                return df_t
        except Exception as e:
            HdfUtils.logger.error(f"Failed to get steady profile cross section output: {str(e)}")
            return pd.DataFrame()

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def cross_sections_wsel(hdf_path: Path) -> pd.DataFrame:
        """
        Return the water surface elevation information for each 1D Cross Section.

        Parameters:
        ----------
        hdf_path : Path
            Path to the HEC-RAS plan HDF file.

        Returns:
        -------
        pd.DataFrame
            A DataFrame containing the water surface elevations for each cross section and event.
        """
        return HdfResultsXsec.steady_profile_xs_output(hdf_path, "Water Surface")

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def cross_sections_flow(hdf_path: Path) -> pd.DataFrame:
        """
        Return the Flow information for each 1D Cross Section.

        Parameters:
        ----------
        hdf_path : Path
            Path to the HEC-RAS plan HDF file.

        Returns:
        -------
        pd.DataFrame
            A DataFrame containing the flow for each cross section and event.
        """
        return HdfResultsXsec.steady_profile_xs_output(hdf_path, "Flow")

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def cross_sections_energy_grade(hdf_path: Path) -> pd.DataFrame:
        """
        Return the energy grade information for each 1D Cross Section.

        Parameters:
        ----------
        hdf_path : Path
            Path to the HEC-RAS plan HDF file.

        Returns:
        -------
        pd.DataFrame
            A DataFrame containing the energy grade for each cross section and event.
        """
        return HdfResultsXsec.steady_profile_xs_output(hdf_path, "Energy Grade")

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def cross_sections_additional_enc_station_left(hdf_path: Path) -> pd.DataFrame:
        """
        Return the left side encroachment information for a floodway plan hdf.

        Parameters:
        ----------
        hdf_path : Path
            Path to the HEC-RAS plan HDF file.

        Returns:
        -------
        pd.DataFrame
            A DataFrame containing the cross sections left side encroachment stations.
        """
        return HdfResultsXsec.steady_profile_xs_output(
            hdf_path, "Encroachment Station Left"
        )

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def cross_sections_additional_enc_station_right(hdf_path: Path) -> pd.DataFrame:
        """
        Return the right side encroachment information for a floodway plan hdf.

        Parameters:
        ----------
        hdf_path : Path
            Path to the HEC-RAS plan HDF file.

        Returns:
        -------
        pd.DataFrame
            A DataFrame containing the cross sections right side encroachment stations.
        """
        return HdfResultsXsec.steady_profile_xs_output(
            hdf_path, "Encroachment Station Right"
        )

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def cross_sections_additional_area_total(hdf_path: Path) -> pd.DataFrame:
        """
        Return the 1D cross section area for each profile.

        Parameters:
        ----------
        hdf_path : Path
            Path to the HEC-RAS plan HDF file.

        Returns:
        -------
        pd.DataFrame
            A DataFrame containing the wet area inside the cross sections.
        """
        return HdfResultsXsec.steady_profile_xs_output(hdf_path, "Area Ineffective Total")

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def cross_sections_additional_velocity_total(hdf_path: Path) -> pd.DataFrame:
        """
        Return the 1D cross section velocity for each profile.

        Parameters:
        ----------
        hdf_path : Path
            Path to the HEC-RAS plan HDF file.

        Returns:
        -------
        pd.DataFrame
            A DataFrame containing the velocity inside the cross sections.
        """
        return HdfResultsXsec.steady_profile_xs_output(hdf_path, "Velocity Total")


==================================================

File: c:\GH\ras-commander\ras_commander\HdfStruc.py
==================================================
"""
Class: HdfStruc

Attribution: A substantial amount of code in this file is sourced or derived 
from the https://github.com/fema-ffrd/rashdf library, 
released under MIT license and Copyright (c) 2024 fema-ffrd

The file has been forked and modified for use in RAS Commander.
"""
from typing import Dict, Any, List, Union
from pathlib import Path
import h5py
import numpy as np
import pandas as pd
from geopandas import GeoDataFrame
from shapely.geometry import LineString, MultiLineString, Polygon, MultiPolygon, Point, GeometryCollection
from .HdfUtils import HdfUtils
from .HdfXsec import HdfXsec
from .HdfBase import HdfBase
from .Decorators import standardize_input, log_call
from .LoggingConfig import setup_logging, get_logger

logger = get_logger(__name__)

class HdfStruc:
    """
    HEC-RAS HDF Structures class for handling operations related to structures in HDF files.

    This class provides methods for extracting and analyzing data about structures
    from HEC-RAS HDF files. It includes functionality to retrieve structure geometries
    and attributes.

    Methods in this class use the @standardize_input decorator to handle different
    input types (file path, etc.) and the @log_call decorator for logging method calls.

    Attributes:
        GEOM_STRUCTURES_PATH (str): Constant for the HDF path to structures data.

    Note: This class contains static methods and does not require instantiation.
    """

    GEOM_STRUCTURES_PATH = "Geometry/Structures"

    @staticmethod
    @log_call
    @standardize_input(file_type='geom_hdf')
    def structures(hdf_path: Path, datetime_to_str: bool = False) -> GeoDataFrame:
        """
        Return the model structures.

        This method extracts structure data from the HDF file, including geometry
        and attributes, and returns it as a GeoDataFrame.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.
        datetime_to_str : bool, optional
            If True, convert datetime objects to strings. Default is False.

        Returns
        -------
        GeoDataFrame
            A GeoDataFrame containing the structures, with columns for attributes
            and geometry.

        Raises
        ------
        Exception
            If there's an error reading the structures data from the HDF file.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                # Check if the structures path exists in the HDF file
                if HdfStruc.GEOM_STRUCTURES_PATH not in hdf_file:
                    logger.info(f"No structures found in the geometry file: {hdf_path}")
                    return GeoDataFrame()
                
                struct_data = hdf_file[HdfStruc.GEOM_STRUCTURES_PATH]
                v_conv_val = np.vectorize(HdfUtils._convert_ras_hdf_value)
                sd_attrs = struct_data["Attributes"][()]
                
                # Create a dictionary to store structure data
                struct_dict = {"struct_id": range(sd_attrs.shape[0])}
                struct_dict.update(
                    {name: v_conv_val(sd_attrs[name]) for name in sd_attrs.dtype.names}
                )
                
                # Get structure geometries
                geoms = HdfXsec._get_polylines(
                    hdf_path,
                    HdfStruc.GEOM_STRUCTURES_PATH,
                    info_name="Centerline Info",
                    parts_name="Centerline Parts",
                    points_name="Centerline Points"
                )
                
                # Create GeoDataFrame
                struct_gdf = GeoDataFrame(
                    struct_dict,
                    geometry=geoms,
                    crs=HdfUtils.projection(hdf_path),
                )
                
                # Convert datetime to string if requested
                if datetime_to_str:
                    struct_gdf["Last Edited"] = struct_gdf["Last Edited"].apply(
                        lambda x: pd.Timestamp.isoformat(x) if pd.notnull(x) else None
                    )
                
                return struct_gdf
        except Exception as e:
            logger.error(f"Error reading structures: {str(e)}")
            raise

    @staticmethod
    @log_call
    @standardize_input(file_type='geom_hdf')
    def get_geom_structures_attrs(hdf_path: Path) -> Dict[str, Any]:
        """
        Return geometry structures attributes from a HEC-RAS HDF file.

        This method extracts attributes related to geometry structures from the HDF file.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.

        Returns
        -------
        Dict[str, Any]
            A dictionary containing the geometry structures attributes.

        Notes
        -----
        If no structures are found in the geometry file, an empty dictionary is returned.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                if HdfStruc.GEOM_STRUCTURES_PATH not in hdf_file:
                    logger.info(f"No structures found in the geometry file: {hdf_path}")
                    return {}
                return HdfUtils.get_attrs(hdf_file, HdfStruc.GEOM_STRUCTURES_PATH)
        except Exception as e:
            logger.error(f"Error reading geometry structures attributes: {str(e)}")
            return {}

==================================================

File: c:\GH\ras-commander\ras_commander\HdfUtils.py
==================================================
"""
Class: HdfUtils

Attribution: A substantial amount of code in this file is sourced or derived 
from the https://github.com/fema-ffrd/rashdf library, 
released under MIT license and Copyright (c) 2024 fema-ffrd

The file has been forked and modified for use in RAS Commander.
"""
import logging
from pathlib import Path
import h5py
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from typing import Union, Optional, Dict, List, Tuple, Any
from scipy.spatial import KDTree
import re

from .Decorators import standardize_input, log_call 
from .LoggingConfig import setup_logging, get_logger

logger = get_logger(__name__)

class HdfUtils:
    """
    Utility class for working with HEC-RAS HDF files.

    This class provides general utility functions for HDF file operations,
    including attribute extraction, data conversion, and common HDF queries.
    It also includes spatial operations and helper methods for working with
    HEC-RAS specific data structures.

    Note:
    - Use this class for general HDF utility functions that are not specific to plan or geometry files.
    - All methods in this class are static and can be called without instantiating the class.
    """

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def get_hdf_filename(hdf_input: Union[str, Path, h5py.File], ras_object=None) -> Optional[Path]:
        """
        Get the HDF filename from various input types.

        Args:
            hdf_input (Union[str, Path, h5py.File]): The plan number, full path to the HDF file, or an open HDF file object.
            ras_object (RasPrj, optional): The RAS project object. If None, uses the global ras instance.

        Returns:
            Optional[Path]: Path to the HDF file, or None if not found.
        """
        if isinstance(hdf_input, h5py.File):
            return Path(hdf_input.filename)

        if isinstance(hdf_input, str):
            hdf_input = Path(hdf_input)

        if isinstance(hdf_input, Path) and hdf_input.is_file():
            return hdf_input

        if ras_object is None:
            logger.critical("RAS object is not provided. It is required when hdf_input is not a direct file path.")
            return None

        plan_info = ras_object.plan_df[ras_object.plan_df['plan_number'] == str(hdf_input)]
        if plan_info.empty:
            logger.critical(f"No HDF file found for plan number {hdf_input}")
            return None

        hdf_filename = plan_info.iloc[0]['HDF_Results_Path']
        if hdf_filename is None:
            logger.critical(f"HDF_Results_Path is None for plan number {hdf_input}")
            return None

        hdf_path = Path(hdf_filename)
        if not hdf_path.is_file():
            logger.critical(f"HDF file not found: {hdf_path}")
            return None

        return hdf_path

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def get_root_attrs(hdf_path: Path) -> dict:
        """
        Return attributes at root level of HEC-RAS HDF file.

        Args:
            hdf_path (Path): Path to the HDF file.

        Returns:
            dict: Dictionary filled with HEC-RAS HDF root attributes.
        """
        with h5py.File(hdf_path, 'r') as hdf_file:
            return HdfUtils.get_attrs(hdf_file, "/")

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def get_attrs(hdf_path: Path, attr_path: str) -> dict:
        """
        Get attributes from a HEC-RAS HDF file for a given attribute path.

        Args:
            hdf_path (Path): The path to the HDF file.
            attr_path (str): The path to the attributes within the HDF file.

        Returns:
            dict: A dictionary of attributes.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                attr_object = hdf_file.get(attr_path)
                if attr_object is None:
                    logger.warning(f"Attribute path '{attr_path}' not found in HDF file.")
                    return {}
                return HdfUtils._hdf5_attrs_to_dict(attr_object.attrs)
        except Exception as e:
            logger.error(f"Error getting attributes from '{attr_path}': {str(e)}")
            return {}

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def get_hdf_paths_with_properties(hdf_path: Path) -> pd.DataFrame:
        """
        Get all paths in the HDF file with their properties.

        Args:
            hdf_path (Path): Path to the HDF file.

        Returns:
            pd.DataFrame: DataFrame containing paths and their properties.
        """
        def get_item_properties(item):
            return {
                'name': item.name,
                'type': type(item).__name__,
                'shape': item.shape if hasattr(item, 'shape') else None,
                'dtype': item.dtype if hasattr(item, 'dtype') else None
            }

        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                items = []
                hdf_file.visititems(lambda name, item: items.append(get_item_properties(item)))

            return pd.DataFrame(items)
        except Exception as e:
            logger.error(f"Error reading HDF file: {e}")
            return pd.DataFrame()

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def get_group_attributes_as_df(hdf_path: Path, group_path: str) -> pd.DataFrame:
        """
        Get attributes of a group in the HDF file as a DataFrame.

        Args:
            hdf_path (Path): Path to the HDF file.
            group_path (str): Path to the group within the HDF file.

        Returns:
            pd.DataFrame: DataFrame containing the group's attributes.
        """
        with h5py.File(hdf_path, 'r') as hdf_file:
            group = hdf_file[group_path]
            attributes = {key: group.attrs[key] for key in group.attrs.keys()}
            return pd.DataFrame([attributes])


    @staticmethod
    def convert_ras_hdf_string(value: Union[str, bytes]) -> Union[bool, datetime, List[datetime], timedelta, str]:
        """
        Convert a string value from an HEC-RAS HDF file into a Python object.

        Args:
            value (Union[str, bytes]): The value to convert.

        Returns:
            Union[bool, datetime, List[datetime], timedelta, str]: The converted value.
        """
        return HdfUtils._convert_ras_hdf_string(value)

    @staticmethod
    def df_datetimes_to_str(df: pd.DataFrame) -> pd.DataFrame:
        """
        Convert any datetime64 columns in a DataFrame to strings.

        Args:
            df (pd.DataFrame): The DataFrame to convert.

        Returns:
            pd.DataFrame: The DataFrame with datetime columns converted to strings.
        """
        for col in df.select_dtypes(include=['datetime64']).columns:
            df[col] = df[col].dt.strftime('%Y-%m-%d %H:%M:%S')
        return df

    @staticmethod
    def perform_kdtree_query(
        reference_points: np.ndarray,
        query_points: np.ndarray,
        max_distance: float = 2.0
    ) -> np.ndarray:
        """
        Performs a KDTree query between two datasets and returns indices with distances exceeding max_distance set to -1.

        Args:
            reference_points (np.ndarray): The reference dataset for KDTree.
            query_points (np.ndarray): The query dataset to search against KDTree of reference_points.
            max_distance (float, optional): The maximum distance threshold. Indices with distances greater than this are set to -1. Defaults to 2.0.

        Returns:
            np.ndarray: Array of indices from reference_points that are nearest to each point in query_points. 
                        Indices with distances > max_distance are set to -1.

        Example:
            >>> ref_points = np.array([[0, 0], [1, 1], [2, 2]])
            >>> query_points = np.array([[0.5, 0.5], [3, 3]])
            >>> result = HdfUtils.perform_kdtree_query(ref_points, query_points)
            >>> print(result)
            array([ 0, -1])
        """
        dist, snap = KDTree(reference_points).query(query_points, distance_upper_bound=max_distance)
        snap[dist > max_distance] = -1
        return snap

    @staticmethod
    def find_nearest_neighbors(points: np.ndarray, max_distance: float = 2.0) -> np.ndarray:
        """
        Creates a self KDTree for dataset points and finds nearest neighbors excluding self, 
        with distances above max_distance set to -1.

        Args:
            points (np.ndarray): The dataset to build the KDTree from and query against itself.
            max_distance (float, optional): The maximum distance threshold. Indices with distances 
                                            greater than max_distance are set to -1. Defaults to 2.0.

        Returns:
            np.ndarray: Array of indices representing the nearest neighbor in points for each point in points. 
                        Indices with distances > max_distance or self-matches are set to -1.

        Example:
            >>> points = np.array([[0, 0], [1, 1], [2, 2], [10, 10]])
            >>> result = HdfUtils.find_nearest_neighbors(points)
            >>> print(result)
            array([1, 0, 1, -1])
        """
        dist, snap = KDTree(points).query(points, k=2, distance_upper_bound=max_distance)
        snap[dist > max_distance] = -1
        
        snp = pd.DataFrame(snap, index=np.arange(len(snap)))
        snp = snp.replace(-1, np.nan)
        snp.loc[snp[0] == snp.index, 0] = np.nan
        snp.loc[snp[1] == snp.index, 1] = np.nan
        filled = snp[0].fillna(snp[1])
        snapped = filled.fillna(-1).astype(np.int64).to_numpy()
        return snapped

    @staticmethod
    def _convert_ras_hdf_string(value: Union[str, bytes]) -> Union[bool, datetime, List[datetime], timedelta, str]:
        """
        Private method to convert a string value from an HEC-RAS HDF file into a Python object.

        Args:
            value (Union[str, bytes]): The value to convert.

        Returns:
            Union[bool, datetime, List[datetime], timedelta, str]: The converted value.
        """
        if isinstance(value, bytes):
            s = value.decode("utf-8")
        else:
            s = value

        if s == "True":
            return True
        elif s == "False":
            return False
        
        ras_datetime_format1_re = r"\d{2}\w{3}\d{4} \d{2}:\d{2}:\d{2}"
        ras_datetime_format2_re = r"\d{2}\w{3}\d{4} \d{2}\d{2}"
        ras_duration_format_re = r"\d{2}:\d{2}:\d{2}"

        if re.match(rf"^{ras_datetime_format1_re}", s):
            if re.match(rf"^{ras_datetime_format1_re} to {ras_datetime_format1_re}$", s):
                split = s.split(" to ")
                return [
                    HdfBase._parse_ras_datetime(split[0]),
                    HdfBase._parse_ras_datetime(split[1]),
                ]
            return HdfBase._parse_ras_datetime(s)
        elif re.match(rf"^{ras_datetime_format2_re}", s):
            if re.match(rf"^{ras_datetime_format2_re} to {ras_datetime_format2_re}$", s):
                split = s.split(" to ")
                return [
                    HdfBase._parse_ras_simulation_window_datetime(split[0]),
                    HdfBase._parse_ras_simulation_window_datetime(split[1]),
                ]
            return HdfBase._parse_ras_simulation_window_datetime(s)
        elif re.match(rf"^{ras_duration_format_re}$", s):
            return HdfBase._parse_duration(s)
        return s

    @staticmethod
    def _convert_ras_hdf_value(value: Any) -> Union[None, bool, str, List[str], int, float, List[int], List[float]]:
        """
        Convert a value from a HEC-RAS HDF file into a Python object.

        Args:
            value (Any): The value to convert.

        Returns:
            Union[None, bool, str, List[str], int, float, List[int], List[float]]: The converted value.
        """
        if isinstance(value, np.floating) and np.isnan(value):
            return None
        elif isinstance(value, (bytes, np.bytes_)):
            return value.decode('utf-8')
        elif isinstance(value, np.integer):
            return int(value)
        elif isinstance(value, np.floating):
            return float(value)
        elif isinstance(value, (int, float)):
            return value
        elif isinstance(value, (list, tuple, np.ndarray)):
            if len(value) > 1:
                return [HdfUtils._convert_ras_hdf_value(v) for v in value]
            else:
                return HdfUtils._convert_ras_hdf_value(value[0])
        else:
            return str(value)

    @staticmethod
    def _parse_ras_datetime_ms(datetime_str: str) -> datetime:
        """
        Private method to parse a datetime string with milliseconds from a RAS file.

        Args:
            datetime_str (str): The datetime string to parse.

        Returns:
            datetime: The parsed datetime object.
        """
        milliseconds = int(datetime_str[-3:])
        microseconds = milliseconds * 1000
        parsed_dt = HdfBase._parse_ras_datetime(datetime_str[:-4]).replace(microsecond=microseconds)
        return parsed_dt

    @staticmethod
    def _ras_timesteps_to_datetimes(timesteps: np.ndarray, start_time: datetime, time_unit: str = "days", round_to: str = "100ms") -> pd.DatetimeIndex:
        """
        Convert RAS timesteps to datetime objects.

        Args:
            timesteps (np.ndarray): Array of timesteps.
            start_time (datetime): Start time of the simulation.
            time_unit (str): Unit of the timesteps. Default is "days".
            round_to (str): Frequency string to round the times to. Default is "100ms" (100 milliseconds).

        Returns:
            pd.DatetimeIndex: DatetimeIndex of converted and rounded datetimes.
        """
        if time_unit == "days":
            datetimes = start_time + pd.to_timedelta(timesteps, unit='D')
        elif time_unit == "hours":
            datetimes = start_time + pd.to_timedelta(timesteps, unit='H')
        else:
            raise ValueError(f"Unsupported time unit: {time_unit}")

        return pd.DatetimeIndex(datetimes).round(round_to)

    @staticmethod
    def _hdf5_attrs_to_dict(attrs: Union[h5py.AttributeManager, Dict], prefix: Optional[str] = None) -> Dict:
        """
        Private method to convert HDF5 attributes to a Python dictionary.

        Args:
            attrs (Union[h5py.AttributeManager, Dict]): The attributes to convert.
            prefix (Optional[str]): A prefix to add to the attribute keys.

        Returns:
            Dict: A dictionary of converted attributes.
        """
        result = {}
        for key, value in attrs.items():
            if prefix:
                key = f"{prefix}/{key}"
            if isinstance(value, (np.ndarray, list)):
                result[key] = [HdfUtils._convert_ras_hdf_value(v) for v in value]
            else:
                result[key] = HdfUtils._convert_ras_hdf_value(value)
        return result

    @staticmethod
    def parse_run_time_window(window: str) -> Tuple[datetime, datetime]:
        """
        Parse a run time window string into a tuple of datetime objects.

        Args:
            window (str): The run time window string to be parsed.

        Returns:
            Tuple[datetime, datetime]: A tuple containing two datetime objects representing the start and end of the run
            time window.
        """
        split = window.split(" to ")
        begin = HdfBase._parse_ras_datetime(split[0])
        end = HdfBase._parse_ras_datetime(split[1])
        return begin, end

    

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def get_2d_flow_area_names_and_counts(hdf_path: Path) -> List[Tuple[str, int]]:
        """
        Get the names and cell counts of 2D flow areas from the HDF file.

        Args:
            hdf_path (Path): Path to the HDF file.

        Returns:
            List[Tuple[str, int]]: A list of tuples containing the name and cell count of each 2D flow area.

        Raises:
            ValueError: If there's an error reading the HDF file or accessing the required data.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                flow_area_2d_path = "Geometry/2D Flow Areas"
                if flow_area_2d_path not in hdf_file:
                    return []
                
                attributes = hdf_file[f"{flow_area_2d_path}/Attributes"][()]
                names = [HdfUtils._convert_ras_hdf_string(name) for name in attributes["Name"]]
                
                cell_info = hdf_file[f"{flow_area_2d_path}/Cell Info"][()]
                cell_counts = [info[1] for info in cell_info]
                
                return list(zip(names, cell_counts))
        except Exception as e:
            logger.error(f"Error reading 2D flow area names and counts from {hdf_path}: {str(e)}")
            raise ValueError(f"Failed to get 2D flow area names and counts: {str(e)}")

    @staticmethod
    @standardize_input(file_type='plan_hdf')
    def projection(hdf_path: Path) -> Optional[str]:
        """
        Get the projection information from the HDF file.

        Args:
            hdf_path (Path): Path to the HDF file.

        Returns:
            Optional[str]: The projection information as a string, or None if not found.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                proj_wkt = hdf_file.attrs.get("Projection")
                if proj_wkt is None:
                    return None
                if isinstance(proj_wkt, bytes) or isinstance(proj_wkt, np.bytes_):
                    proj_wkt = proj_wkt.decode("utf-8")
                return proj_wkt
        except Exception as e:
            logger.error(f"Error reading projection from {hdf_path}: {str(e)}")
            return None

==================================================

File: c:\GH\ras-commander\ras_commander\HdfXsec.py
==================================================
"""
Class: HdfXsec

Attribution: A substantial amount of code in this file is sourced or derived 
from the https://github.com/fema-ffrd/rashdf library, 
released under MIT license and Copyright (c) 2024 fema-ffrd

The file has been forked and modified for use in RAS Commander.
"""

from pathlib import Path
import h5py
import numpy as np
import pandas as pd
from geopandas import GeoDataFrame
from shapely.geometry import LineString, MultiLineString
from typing import List  # Import List to avoid NameError
from .Decorators import standardize_input, log_call
from .HdfBase import HdfBase
from .HdfUtils import HdfUtils
from .LoggingConfig import get_logger

logger = get_logger(__name__)

class HdfXsec:
    """
    HdfXsec class for handling cross-section related operations on HEC-RAS HDF files.

    This class provides methods to extract and process cross-section data, elevation information,
    and river reach data from HEC-RAS HDF geometry files. It includes functionality to retrieve
    cross-section attributes, elevation profiles, and river reach geometries.

    The class uses static methods, allowing for direct calls without instantiation. It relies on
    utility functions from HdfBase and HdfUtils classes for various operations such as projection
    handling and data conversion.

    Note:
        This class is designed to work with HEC-RAS geometry HDF files and requires them to have
        a specific structure and naming convention for the data groups and attributes.
    """

    @staticmethod
    @log_call
    @standardize_input(file_type='geom_hdf')
    def cross_sections(hdf_path: Path, datetime_to_str: bool = False) -> GeoDataFrame:
        """
        Return the model 1D cross sections.

        This method extracts cross-section data from the HEC-RAS geometry HDF file,
        including attributes and geometry information.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.
        datetime_to_str : bool, optional
            If True, convert datetime objects to strings. Default is False.

        Returns
        -------
        GeoDataFrame
            A GeoDataFrame containing the cross sections with their attributes and geometries.

        Raises
        ------
        KeyError
            If the required datasets are not found in the HDF file.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                xs_data = hdf_file["Geometry/Cross Sections"]
                
                if "Attributes" not in xs_data:
                    logger.warning(f"No 'Attributes' dataset group in {hdf_path}")
                    return GeoDataFrame()

                # Convert attribute values
                v_conv_val = np.vectorize(HdfUtils._convert_ras_hdf_value)
                xs_attrs = xs_data["Attributes"][()]
                xs_dict = {"xs_id": range(xs_attrs.shape[0])}
                xs_dict.update(
                    {name: v_conv_val(xs_attrs[name]) for name in xs_attrs.dtype.names}
                )

                xs_df = pd.DataFrame(xs_dict)
                
                # Create geometry from coordinate pairs
                xs_df['geometry'] = xs_df.apply(lambda row: LineString([
                    (row['XS_X_Coord_1'], row['XS_Y_Coord_1']),
                    (row['XS_X_Coord_2'], row['XS_Y_Coord_2'])
                ]), axis=1)
                
                # Convert to GeoDataFrame
                gdf = GeoDataFrame(xs_df, geometry='geometry', crs=HdfUtils.projection(hdf_path))
                
                # Convert datetime columns to strings if requested
                if datetime_to_str:
                    gdf = HdfUtils.df_datetimes_to_str(gdf)
                
                return gdf

        except KeyError as e:
            logger.error(f"Error accessing cross-section data in {hdf_path}: {str(e)}")
            return GeoDataFrame()

    @staticmethod
    @log_call
    @standardize_input(file_type='geom_hdf')
    def cross_sections_elevations(hdf_path: Path, round_to: int = 2) -> pd.DataFrame:
        """
        Return the model cross section elevation information.

        This method extracts cross-section elevation data from the HEC-RAS geometry HDF file,
        including station-elevation pairs for each cross-section.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.
        round_to : int, optional
            Number of decimal places to round to. Default is 2.

        Returns
        -------
        pd.DataFrame
            A DataFrame containing the cross section elevation information.

        Raises
        ------
        KeyError
            If the required datasets are not found in the HDF file.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                path = "/Geometry/Cross Sections"
                if path not in hdf_file:
                    logger.warning(f"No 'Cross Sections' group found in {hdf_path}")
                    return pd.DataFrame()

                xselev_data = hdf_file[path]
                
                if "Station Elevation Info" not in xselev_data or "Station Elevation Values" not in xselev_data:
                    logger.warning(f"Required datasets not found in Cross Sections group in {hdf_path}")
                    return pd.DataFrame()

                # Get cross-section data
                xs_df = HdfXsec.cross_sections(hdf_path)
                if xs_df.empty:
                    return pd.DataFrame()

                # Extract elevation data
                elevations = []
                for part_start, part_cnt in xselev_data["Station Elevation Info"][()]:
                    xzdata = xselev_data["Station Elevation Values"][()][
                        part_start : part_start + part_cnt
                    ]
                    elevations.append(xzdata)

                # Create DataFrame with elevation info
                xs_elev_df = xs_df[
                    ["xs_id", "River", "Reach", "RS", "Left Bank", "Right Bank"]
                ].copy()
                xs_elev_df["Left Bank"] = xs_elev_df["Left Bank"].round(round_to).astype(str)
                xs_elev_df["Right Bank"] = xs_elev_df["Right Bank"].round(round_to).astype(str)
                xs_elev_df["elevation info"] = elevations

                return xs_elev_df

        except KeyError as e:
            logger.error(f"Error accessing cross-section elevation data in {hdf_path}: {str(e)}")
            return pd.DataFrame()
        except Exception as e:
            logger.error(f"Unexpected error in cross_sections_elevations: {str(e)}")
            return pd.DataFrame()

    @staticmethod
    @log_call
    @standardize_input(file_type='geom_hdf')
    def river_reaches(hdf_path: Path, datetime_to_str: bool = False) -> GeoDataFrame:
        """
        Return the model 1D river reach lines.

        This method extracts river reach data from the HEC-RAS geometry HDF file,
        including attributes and geometry information.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.
        datetime_to_str : bool, optional
            If True, convert datetime objects to strings. Default is False.

        Returns
        -------
        GeoDataFrame
            A GeoDataFrame containing the river reaches with their attributes and geometries.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                if "Geometry/River Centerlines" not in hdf_file:
                    return GeoDataFrame()

                river_data = hdf_file["Geometry/River Centerlines"]
                v_conv_val = np.vectorize(HdfUtils._convert_ras_hdf_value)
                river_attrs = river_data["Attributes"][()]
                river_dict = {"river_id": range(river_attrs.shape[0])}
                river_dict.update(
                    {name: v_conv_val(river_attrs[name]) for name in river_attrs.dtype.names}
                )
                
                # Get polylines for river reaches
                geoms = HdfXsec._get_polylines(hdf_path, "Geometry/River Centerlines")
                
                river_gdf = GeoDataFrame(
                    river_dict,
                    geometry=geoms,
                    crs=HdfUtils.projection(hdf_path),
                )
                if datetime_to_str:
                    river_gdf["Last Edited"] = river_gdf["Last Edited"].apply(
                        lambda x: pd.Timestamp.isoformat(x)
                    )
                return river_gdf
        except Exception as e:
            logger.error(f"Error reading river reaches: {str(e)}")
            return GeoDataFrame()

    @staticmethod
    def _get_polylines(hdf_path: Path, path: str, info_name: str = "Polyline Info", parts_name: str = "Polyline Parts", points_name: str = "Polyline Points") -> List[LineString]:
        """
        Helper method to extract polylines from HDF file.

        This method is used internally to extract polyline geometries for various features
        such as river reaches.

        Parameters
        ----------
        hdf_path : Path
            Path to the HEC-RAS geometry HDF file.
        path : str
            Path within the HDF file to the polyline data.
        info_name : str, optional
            Name of the dataset containing polyline info. Default is "Polyline Info".
        parts_name : str, optional
            Name of the dataset containing polyline parts. Default is "Polyline Parts".
        points_name : str, optional
            Name of the dataset containing polyline points. Default is "Polyline Points".

        Returns
        -------
        List[LineString]
            A list of LineString geometries representing the polylines.
        """
        try:
            with h5py.File(hdf_path, 'r') as hdf_file:
                polyline_info_path = f"{path}/{info_name}"
                polyline_parts_path = f"{path}/{parts_name}"
                polyline_points_path = f"{path}/{points_name}"

                polyline_info = hdf_file[polyline_info_path][()]
                polyline_parts = hdf_file[polyline_parts_path][()]
                polyline_points = hdf_file[polyline_points_path][()]

                geoms = []
                for pnt_start, pnt_cnt, part_start, part_cnt in polyline_info:
                    points = polyline_points[pnt_start : pnt_start + pnt_cnt]
                    if part_cnt == 1:
                        geoms.append(LineString(points))
                    else:
                        parts = polyline_parts[part_start : part_start + part_cnt]
                        geoms.append(
                            MultiLineString(
                                list(
                                    points[part_pnt_start : part_pnt_start + part_pnt_cnt]
                                    for part_pnt_start, part_pnt_cnt in parts
                                )
                            )
                        )
                return geoms
        except Exception as e:
            logger.error(f"Error getting polylines: {str(e)}")
            return []

==================================================

File: c:\GH\ras-commander\ras_commander\LoggingConfig.py
==================================================
# logging_config.py

import logging
import logging.handlers
from pathlib import Path
import functools

# Define log levels
DEBUG = logging.DEBUG
INFO = logging.INFO
WARNING = logging.WARNING
ERROR = logging.ERROR
CRITICAL = logging.CRITICAL


_logging_setup_done = False

def setup_logging(log_file=None, log_level=logging.INFO):
    """Set up logging configuration for the ras-commander library."""
    global _logging_setup_done
    if _logging_setup_done:
        return
    
    # Define log format
    log_format = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )

    # Configure console handler
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(log_format)

    # Set up root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(log_level)
    root_logger.addHandler(console_handler)

    # Configure file handler if log_file is provided
    if log_file:
        log_dir = Path('logs')
        log_dir.mkdir(exist_ok=True)
        log_file_path = log_dir / log_file

        file_handler = logging.handlers.RotatingFileHandler(
            log_file_path, maxBytes=10*1024*1024, backupCount=5
        )
        file_handler.setFormatter(log_format)
        root_logger.addHandler(file_handler)
    
    _logging_setup_done = True

def get_logger(name):
    """Get a logger for a specific module."""
    return logging.getLogger(name)

def log_call(logger=None):
    """Decorator to log function calls."""
    def get_logger():
        # Check if logger is None or doesn't have a debug method
        if logger is None or not hasattr(logger, 'debug'):
            return logging.getLogger(__name__)
        return logger

    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            log = get_logger()
            log.debug(f"Calling {func.__name__}")
            result = func(*args, **kwargs)
            log.debug(f"Finished {func.__name__}")
            return result
        return wrapper
    
    # Check if we're being called as @log_call or @log_call()
    if callable(logger):
        return decorator(logger)
    return decorator

# Set up logging when this module is imported
setup_logging()
==================================================

File: c:\GH\ras-commander\ras_commander\RasCmdr.py
==================================================
"""
RasCmdr - Execution operations for running HEC-RAS simulations

This module is part of the ras-commander library and uses a centralized logging configuration.

Logging Configuration:
- The logging is set up in the logging_config.py file.
- A @log_call decorator is available to automatically log function calls.
- Log levels: DEBUG, INFO, WARNING, ERROR, CRITICAL
- Logs are written to both console and a rotating file handler.
- The default log file is 'ras_commander.log' in the 'logs' directory.
- The default log level is INFO.

To use logging in this module:
1. Use the @log_call decorator for automatic function call logging.
2. For additional logging, use logger.[level]() calls (e.g., logger.info(), logger.debug()).

Example:
    @log_call
    def my_function():
        
        logger.debug("Additional debug information")
        # Function logic here
"""
import os
import subprocess
import shutil
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, as_completed
from .RasPrj import ras, RasPrj, init_ras_project, get_ras_exe
from .RasPlan import RasPlan
from .RasGeo import RasGeo
from .RasUtils import RasUtils
import logging
import time
import queue
from threading import Thread, Lock
from typing import Union, List, Optional, Dict
from pathlib import Path
import shutil
import logging
from concurrent.futures import ThreadPoolExecutor, as_completed
from threading import Lock, Thread
from itertools import cycle
from ras_commander.RasPrj import RasPrj  # Ensure RasPrj is imported
from threading import Lock, Thread, current_thread
from concurrent.futures import ThreadPoolExecutor, as_completed
from itertools import cycle
from typing import Union, List, Optional, Dict
from .LoggingConfig import get_logger
from .Decorators import log_call

logger = get_logger(__name__)

# Module code starts here

# TODO: Future Enhancements
# 1. Alternate Run Mode for compute_plan and compute_parallel:
#    - Use Powershell to execute HEC-RAS command
#    - Hide RAS window and all child windows
#    - Note: This mode may prevent execution if the plan has a popup
#    - Intended for background runs or popup-free scenarios
#    - Limit to non-commercial use
#
# 2. Implement compute_plan_remote:
#    - Execute compute_plan on a remote machine via psexec
#    - Use keyring package for secure credential storage
#    - Implement psexec command for remote HEC-RAS execution
#    - Create remote_worker objects to store machine details:
#      (machine name, username, password, ras_exe_path, local folder path, etc.)
#    - Develop RasRemote class for remote_worker management and abstractions
#    - Implement compute_plan_remote in RasCmdr as a thin wrapper around RasRemote
#      (similar to existing compute_plan functions but for remote execution)


class RasCmdr:
    
    @staticmethod
    @log_call
    def compute_plan(
        plan_number,
        dest_folder=None, 
        ras_object=None,
        clear_geompre=False,
        num_cores=None,
        overwrite_dest=False
    ):
        """
        Execute a HEC-RAS plan.

        Args:
            plan_number (str, Path): The plan number to execute (e.g., "01", "02") or the full path to the plan file.
            dest_folder (str, Path, optional): Name of the folder or full path for computation.
                If a string is provided, it will be created in the same parent directory as the project folder.
                If a full path is provided, it will be used as is.
            ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
            clear_geompre (bool, optional): Whether to clear geometry preprocessor files. Defaults to False.
            num_cores (int, optional): Number of cores to use for the plan execution. If None, the current setting is not changed.
            overwrite_dest (bool, optional): If True, overwrite the destination folder if it exists. Defaults to False.

        Returns:
            bool: True if the execution was successful, False otherwise.

        Raises:
            ValueError: If the specified dest_folder already exists and is not empty, and overwrite_dest is False.
        """
        try:
            ras_obj = ras_object if ras_object is not None else ras
            logger.info(f"Using ras_object with project folder: {ras_obj.project_folder}")
            ras_obj.check_initialized()
            
            if dest_folder is not None:
                dest_folder = Path(ras_obj.project_folder).parent / dest_folder if isinstance(dest_folder, str) else Path(dest_folder)
                
                if dest_folder.exists():
                    if overwrite_dest:
                        shutil.rmtree(dest_folder)
                        logger.info(f"Destination folder '{dest_folder}' exists. Overwriting as per overwrite_dest=True.")
                    elif any(dest_folder.iterdir()):
                        error_msg = f"Destination folder '{dest_folder}' exists and is not empty. Use overwrite_dest=True to overwrite."
                        logger.error(error_msg)
                        raise ValueError(error_msg)
                
                dest_folder.mkdir(parents=True, exist_ok=True)
                shutil.copytree(ras_obj.project_folder, dest_folder, dirs_exist_ok=True)
                logger.info(f"Copied project folder to destination: {dest_folder}")
                
                compute_ras = RasPrj()
                compute_ras.initialize(dest_folder, ras_obj.ras_exe_path)
                compute_prj_path = compute_ras.prj_file
            else:
                compute_ras = ras_obj
                compute_prj_path = ras_obj.prj_file

            # Determine the plan path
            compute_plan_path = Path(plan_number) if isinstance(plan_number, (str, Path)) and Path(plan_number).is_file() else RasPlan.get_plan_path(plan_number, compute_ras)

            if not compute_prj_path or not compute_plan_path:
                logger.error(f"Could not find project file or plan file for plan {plan_number}")
                return False

            # Clear geometry preprocessor files if requested
            if clear_geompre:
                try:
                    RasGeo.clear_geompre_files(compute_plan_path, ras_object=compute_ras)
                    logger.info(f"Cleared geometry preprocessor files for plan: {plan_number}")
                except Exception as e:
                    logger.error(f"Error clearing geometry preprocessor files for plan {plan_number}: {str(e)}")

            # Set the number of cores if specified
            if num_cores is not None:
                try:
                    RasPlan.set_num_cores(compute_plan_path, num_cores=num_cores, ras_object=compute_ras)
                    logger.info(f"Set number of cores to {num_cores} for plan: {plan_number}")
                except Exception as e:
                    logger.error(f"Error setting number of cores for plan {plan_number}: {str(e)}")

            # Prepare the command for HEC-RAS execution
            cmd = f'"{compute_ras.ras_exe_path}" -c "{compute_prj_path}" "{compute_plan_path}"'
            logger.info("Running HEC-RAS from the Command Line:")
            logger.info(f"Running command: {cmd}")

            # Execute the HEC-RAS command
            start_time = time.time()
            try:
                subprocess.run(cmd, check=True, shell=True, capture_output=True, text=True)
                end_time = time.time()
                run_time = end_time - start_time
                logger.info(f"HEC-RAS execution completed for plan: {plan_number}")
                logger.info(f"Total run time for plan {plan_number}: {run_time:.2f} seconds")
                return True
            except subprocess.CalledProcessError as e:
                end_time = time.time()
                run_time = end_time - start_time
                logger.error(f"Error running plan: {plan_number}")
                logger.error(f"Error message: {e.output}")
                logger.info(f"Total run time for plan {plan_number}: {run_time:.2f} seconds")
                return False
        except Exception as e:
            logger.critical(f"Error in compute_plan: {str(e)}")
            return False
        finally:
            # Update the RAS object's dataframes
            if ras_obj:
                ras_obj.plan_df = ras_obj.get_plan_entries()
                ras_obj.geom_df = ras_obj.get_geom_entries()
                ras_obj.flow_df = ras_obj.get_flow_entries()
                ras_obj.unsteady_df = ras_obj.get_unsteady_entries()
    


    @staticmethod
    @log_call
    @staticmethod
    @log_call
    def compute_parallel(
        plan_number: Union[str, List[str], None] = None,
        max_workers: int = 2,
        num_cores: int = 2,
        clear_geompre: bool = False,
        ras_object: Optional['RasPrj'] = None,
        dest_folder: Union[str, Path, None] = None,
        overwrite_dest: bool = False
    ) -> Dict[str, bool]:
        """
        Compute multiple HEC-RAS plans in parallel.

        Args:
            plan_number (Union[str, List[str], None]): Plan number(s) to compute. If None, all plans are computed.
            max_workers (int): Maximum number of parallel workers.
            num_cores (int): Number of cores to use per plan computation.
            clear_geompre (bool): Whether to clear geometry preprocessor files.
            ras_object (Optional[RasPrj]): RAS project object. If None, uses global instance.
            dest_folder (Union[str, Path, None]): Destination folder for computed results.
            overwrite_dest (bool): Whether to overwrite existing destination folder.

        Returns:
            Dict[str, bool]: Dictionary of plan numbers and their execution success status.
        """
        try:
            ras_obj = ras_object or ras
            ras_obj.check_initialized()

            project_folder = Path(ras_obj.project_folder)

            if dest_folder is not None:
                dest_folder_path = Path(dest_folder)
                if dest_folder_path.exists():
                    if overwrite_dest:
                        shutil.rmtree(dest_folder_path)
                        logger.info(f"Destination folder '{dest_folder_path}' exists. Overwriting as per overwrite_dest=True.")
                    elif any(dest_folder_path.iterdir()):
                        error_msg = f"Destination folder '{dest_folder_path}' exists and is not empty. Use overwrite_dest=True to overwrite."
                        logger.error(error_msg)
                        raise ValueError(error_msg)
                dest_folder_path.mkdir(parents=True, exist_ok=True)
                shutil.copytree(project_folder, dest_folder_path, dirs_exist_ok=True)
                logger.info(f"Copied project folder to destination: {dest_folder_path}")
                project_folder = dest_folder_path

            if plan_number:
                if isinstance(plan_number, str):
                    plan_number = [plan_number]
                ras_obj.plan_df = ras_obj.plan_df[ras_obj.plan_df['plan_number'].isin(plan_number)]
                logger.info(f"Filtered plans to execute: {plan_number}")

            num_plans = len(ras_obj.plan_df)
            max_workers = min(max_workers, num_plans) if num_plans > 0 else 1
            logger.info(f"Adjusted max_workers to {max_workers} based on the number of plans: {num_plans}")

            worker_ras_objects = {}
            for worker_id in range(1, max_workers + 1):
                worker_folder = project_folder.parent / f"{project_folder.name} [Worker {worker_id}]"
                if worker_folder.exists():
                    shutil.rmtree(worker_folder)
                    logger.info(f"Removed existing worker folder: {worker_folder}")
                shutil.copytree(project_folder, worker_folder)
                logger.info(f"Created worker folder: {worker_folder}")

                try:
                    ras_instance = RasPrj()
                    worker_ras_instance = init_ras_project(
                        ras_project_folder=worker_folder,
                        ras_version=ras_obj.ras_exe_path,
                        ras_instance=ras_instance
                    )
                    worker_ras_objects[worker_id] = worker_ras_instance
                except Exception as e:
                    logger.critical(f"Failed to initialize RAS project for worker {worker_id}: {str(e)}")
                    worker_ras_objects[worker_id] = None

            worker_cycle = cycle(range(1, max_workers + 1))
            plan_assignments = [(next(worker_cycle), plan_num) for plan_num in ras_obj.plan_df['plan_number']]

            execution_results: Dict[str, bool] = {}

            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                futures = [
                    executor.submit(
                        RasCmdr.compute_plan,
                        plan_num, 
                        ras_object=worker_ras_objects[worker_id], 
                        clear_geompre=clear_geompre,
                        num_cores=num_cores
                    )
                    for worker_id, plan_num in plan_assignments
                ]

                for future, (worker_id, plan_num) in zip(as_completed(futures), plan_assignments):
                    try:
                        success = future.result()
                        execution_results[plan_num] = success
                        logger.info(f"Plan {plan_num} executed in worker {worker_id}: {'Successful' if success else 'Failed'}")
                    except Exception as e:
                        execution_results[plan_num] = False
                        logger.error(f"Plan {plan_num} failed in worker {worker_id}: {str(e)}")

            final_dest_folder = dest_folder_path if dest_folder is not None else project_folder.parent / f"{project_folder.name} [Computed]"
            final_dest_folder.mkdir(parents=True, exist_ok=True)
            logger.info(f"Final destination for computed results: {final_dest_folder}")

            for worker_ras in worker_ras_objects.values():
                if worker_ras is None:
                    continue
                worker_folder = Path(worker_ras.project_folder)
                try:
                    for item in worker_folder.iterdir():
                        dest_path = final_dest_folder / item.name
                        if dest_path.exists():
                            if dest_path.is_dir():
                                shutil.rmtree(dest_path)
                                logger.debug(f"Removed existing directory at {dest_path}")
                            else:
                                dest_path.unlink()
                                logger.debug(f"Removed existing file at {dest_path}")
                        shutil.move(str(item), final_dest_folder)
                        logger.debug(f"Moved {item} to {final_dest_folder}")
                    shutil.rmtree(worker_folder)
                    logger.info(f"Removed worker folder: {worker_folder}")
                except Exception as e:
                    logger.error(f"Error moving results from {worker_folder} to {final_dest_folder}: {str(e)}")

            try:
                final_dest_folder_ras_obj = RasPrj()
                final_dest_folder_ras_obj = init_ras_project(
                    ras_project_folder=final_dest_folder, 
                    ras_version=ras_obj.ras_exe_path,
                    ras_instance=final_dest_folder_ras_obj
                )
                final_dest_folder_ras_obj.check_initialized()
            except Exception as e:
                logger.critical(f"Failed to initialize RasPrj for final destination: {str(e)}")

            logger.info("\nExecution Results:")
            for plan_num, success in execution_results.items():
                status = 'Successful' if success else 'Failed'
                logger.info(f"Plan {plan_num}: {status}")

            ras_obj = ras_object or ras
            ras_obj.plan_df = ras_obj.get_plan_entries()
            ras_obj.geom_df = ras_obj.get_geom_entries()
            ras_obj.flow_df = ras_obj.get_flow_entries()
            ras_obj.unsteady_df = ras_obj.get_unsteady_entries()

            return execution_results

        except Exception as e:
            logger.critical(f"Error in compute_parallel: {str(e)}")
            return {}

    @staticmethod
    @log_call
    def compute_test_mode(
        plan_number=None, 
        dest_folder_suffix="[Test]", 
        clear_geompre=False, 
        num_cores=None, 
        ras_object=None,
        overwrite_dest=False
    ):
        """
        Execute HEC-RAS plans in test mode. This is a re-creation of the HEC-RAS command line -test flag, 
        which does not work in recent versions of HEC-RAS.
        
        As a special-purpose function that emulates the original -test flag, it operates differently than the 
        other two compute_ functions. Per the original HEC-RAS test flag, it creates a separate test folder,
        copies the project there, and executes the specified plans in sequential order.
        
        For most purposes, just copying a the project folder, initing that new folder, then running each plan 
        with compute_plan is a simpler and more flexible approach.  This is shown in the examples provided
        in the ras-commander library.

        Args:
            plan_number (str, list[str], optional): Plan number or list of plan numbers to execute. 
                If None, all plans will be executed. Default is None.
            dest_folder_suffix (str, optional): Suffix to append to the test folder name to create dest_folder. 
                Defaults to "[Test]".
                dest_folder is always created in the project folder's parent directory.
            clear_geompre (bool, optional): Whether to clear geometry preprocessor files.
                Defaults to False.
            num_cores (int, optional): Maximum number of cores to use for each plan.
                If None, the current setting is not changed. Default is None.
            ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
            overwrite_dest (bool, optional): If True, overwrite the destination folder if it exists. Defaults to False.

        Returns:
            Dict[str, bool]: Dictionary of plan numbers and their execution success status.

        Example:
            Run all plans: RasCommander.compute_test_mode()
            Run a specific plan: RasCommander.compute_test_mode(plan_number="01")
            Run multiple plans: RasCommander.compute_test_mode(plan_number=["01", "03", "05"])
            Run plans with a custom folder suffix: RasCommander.compute_test_mode(dest_folder_suffix="[TestRun]")
            Run plans and clear geometry preprocessor files: RasCommander.compute_test_mode(clear_geompre=True)
            Run plans with a specific number of cores: RasCommander.compute_test_mode(num_cores=4)
            
        Notes:
            - This function executes plans in a separate folder for isolated testing.
            - If plan_number is not provided, all plans in the project will be executed.
            - The function does not change the geometry preprocessor and IB tables settings.  
                - To force recomputing of geometry preprocessor and IB tables, use the clear_geompre=True option.
            - Plans are executed sequentially.
            - Because copying the project is implicit, only a dest_folder_suffix option is provided.
            - For more flexible run management, use the compute_parallel or compute_sequential functions.
        """
        try:
            ras_obj = ras_object or ras
            ras_obj.check_initialized()
            
            logger.info("Starting the compute_test_mode...")
               
            project_folder = Path(ras_obj.project_folder)

            if not project_folder.exists():
                logger.error(f"Project folder '{project_folder}' does not exist.")
                return {}

            compute_folder = project_folder.parent / f"{project_folder.name} {dest_folder_suffix}"
            logger.info(f"Creating the test folder: {compute_folder}...")

            if compute_folder.exists():
                if overwrite_dest:
                    shutil.rmtree(compute_folder)
                    logger.info(f"Compute folder '{compute_folder}' exists. Overwriting as per overwrite_dest=True.")
                elif any(compute_folder.iterdir()):
                    error_msg = (
                        f"Compute folder '{compute_folder}' exists and is not empty. "
                        "Use overwrite_dest=True to overwrite."
                    )
                    logger.error(error_msg)
                    raise ValueError(error_msg)

            try:
                shutil.copytree(project_folder, compute_folder)
                logger.info(f"Copied project folder to compute folder: {compute_folder}")
            except Exception as e:
                logger.critical(f"Error occurred while copying project folder: {str(e)}")
                return {}

            try:
                compute_ras = RasPrj()
                compute_ras.initialize(compute_folder, ras_obj.ras_exe_path)
                compute_prj_path = compute_ras.prj_file
                logger.info(f"Initialized RAS project in compute folder: {compute_prj_path}")
            except Exception as e:
                logger.critical(f"Error initializing RAS project in compute folder: {str(e)}")
                return {}

            if not compute_prj_path:
                logger.error("Project file not found.")
                return {}

            logger.info("Getting plan entries...")
            try:
                ras_compute_plan_entries = compute_ras.plan_df
                logger.info("Retrieved plan entries successfully.")
            except Exception as e:
                logger.critical(f"Error retrieving plan entries: {str(e)}")
                return {}

            if plan_number:
                if isinstance(plan_number, str):
                    plan_number = [plan_number]
                ras_compute_plan_entries = ras_compute_plan_entries[
                    ras_compute_plan_entries['plan_number'].isin(plan_number)
                ]
                logger.info(f"Filtered plans to execute: {plan_number}")

            execution_results = {}
            logger.info("Running selected plans sequentially...")
            for _, plan in ras_compute_plan_entries.iterrows():
                plan_number = plan["plan_number"]
                start_time = time.time()
                try:
                    success = RasCmdr.compute_plan(
                        plan_number,
                        ras_object=compute_ras,
                        clear_geompre=clear_geompre,
                        num_cores=num_cores
                    )
                    execution_results[plan_number] = success
                    if success:
                        logger.info(f"Successfully computed plan {plan_number}")
                    else:
                        logger.error(f"Failed to compute plan {plan_number}")
                except Exception as e:
                    execution_results[plan_number] = False
                    logger.error(f"Error computing plan {plan_number}: {str(e)}")
                finally:
                    end_time = time.time()
                    run_time = end_time - start_time
                    logger.info(f"Total run time for plan {plan_number}: {run_time:.2f} seconds")

            logger.info("All selected plans have been executed.")
            logger.info("compute_test_mode completed.")

            logger.info("\nExecution Results:")
            for plan_num, success in execution_results.items():
                status = 'Successful' if success else 'Failed'
                logger.info(f"Plan {plan_num}: {status}")

            ras_obj.plan_df = ras_obj.get_plan_entries()
            ras_obj.geom_df = ras_obj.get_geom_entries()
            ras_obj.flow_df = ras_obj.get_flow_entries()
            ras_obj.unsteady_df = ras_obj.get_unsteady_entries()

            return execution_results

        except Exception as e:
            logger.critical(f"Error in compute_test_mode: {str(e)}")
            return {}
==================================================

File: c:\GH\ras-commander\ras_commander\RasExamples.py
==================================================
"""
RasExamples - Manage and load HEC-RAS example projects for testing and development

This module is part of the ras-commander library and uses a centralized logging configuration.

Logging Configuration:
- The logging is set up in the logging_config.py file.
- A @log_call decorator is available to automatically log function calls.
- Log levels: DEBUG, INFO, WARNING, ERROR, CRITICAL
- Logs are written to both console and a rotating file handler.
- The default log file is 'ras_commander.log' in the 'logs' directory.
- The default log level is INFO.

To use logging in this module:
1. Use the @log_call decorator for automatic function call logging.
2. For additional logging, use logger.[level]() calls (e.g., logger.info(), logger.debug()).
3. Obtain the logger using: logger = logging.getLogger(__name__)

Example:
    @log_call
    def my_function():
        logger = logging.getLogger(__name__)
        logger.debug("Additional debug information")
        # Function logic here
"""
import os
import requests
import zipfile
import pandas as pd
from pathlib import Path
import shutil
from typing import Union, List
import csv
from datetime import datetime
import logging
import re
from tqdm import tqdm
from ras_commander import get_logger
from ras_commander.LoggingConfig import log_call

logger = get_logger(__name__)

class RasExamples:
    """
    A class for quickly loading HEC-RAS example projects for testing and development of ras-commander.

    This class provides functionality to download, extract, and manage HEC-RAS example projects.
    It supports both default HEC-RAS example projects and custom projects from user-provided URLs.
    Additionally, it includes functionality to download FEMA's Base Level Engineering (BLE) models
    from CSV files provided by the FEMA Estimated Base Flood Elevation (BFE) Viewer.
    """
    @log_call
    def __init__(self):
        """
        Initialize the RasExamples class.
        """
        self.base_url = 'https://github.com/HydrologicEngineeringCenter/hec-downloads/releases/download/'
        self.valid_versions = [
            "6.6", "6.5", "6.4.1", "6.3.1", "6.3", "6.2", "6.1", "6.0",
            "5.0.7", "5.0.6", "5.0.5", "5.0.4", "5.0.3", "5.0.1", "5.0",
            "4.1", "4.0", "3.1.3", "3.1.2", "3.1.1", "3.0", "2.2"
        ]
        self.base_dir = Path.cwd()
        self.examples_dir = self.base_dir
        self.projects_dir = self.examples_dir / 'example_projects'
        self.zip_file_path = None
        self.folder_df = None
        self.csv_file_path = self.examples_dir / 'example_projects.csv'

        self.projects_dir.mkdir(parents=True, exist_ok=True)
        logger.info(f"Example projects folder: {self.projects_dir}")
        self._load_project_data()

    @log_call
    def get_example_projects(self, version_number='6.6'):
        """
        Download and extract HEC-RAS example projects for a specified version.
        """
        logger.info(f"Getting example projects for version {version_number}")
        if version_number not in self.valid_versions:
            error_msg = f"Invalid version number. Valid versions are: {', '.join(self.valid_versions)}"
            logger.error(error_msg)
            raise ValueError(error_msg)

        zip_url = f"{self.base_url}1.0.33/Example_Projects_{version_number.replace('.', '_')}.zip"
        
        self.examples_dir.mkdir(parents=True, exist_ok=True)
        
        self.zip_file_path = self.examples_dir / f"Example_Projects_{version_number.replace('.', '_')}.zip"

        if not self.zip_file_path.exists():
            logger.info(f"Downloading HEC-RAS Example Projects from {zip_url}. \nThe file is over 400 MB, so it may take a few minutes to download....")
            try:
                response = requests.get(zip_url, stream=True)
                response.raise_for_status()
                with open(self.zip_file_path, 'wb') as file:
                    shutil.copyfileobj(response.raw, file)
                logger.info(f"Downloaded to {self.zip_file_path}")
            except requests.exceptions.RequestException as e:
                logger.error(f"Failed to download the zip file: {e}")
                raise
        else:
            logger.info("HEC-RAS Example Projects zip file already exists. Skipping download.")

        self._load_project_data()
        return self.projects_dir


    @log_call
    def _load_project_data(self):
        """
        Load project data from CSV if up-to-date, otherwise extract from zip.
        """
        self._find_zip_file()
        
        if not self.zip_file_path:
            logger.info("No example projects zip file found. Downloading...")
            self.get_example_projects()
        
        try:
            zip_modified_time = os.path.getmtime(self.zip_file_path)
        except FileNotFoundError:
            logger.error(f"Zip file not found at {self.zip_file_path}.")
            return
        
        if self.csv_file_path.exists():
            csv_modified_time = os.path.getmtime(self.csv_file_path)
            
            if csv_modified_time >= zip_modified_time:
                logger.info("Loading project data from CSV...")
                try:
                    self.folder_df = pd.read_csv(self.csv_file_path)
                    logger.info(f"Loaded {len(self.folder_df)} projects from CSV. Use list_categories() and list_projects() to explore them.")
                except Exception as e:
                    logger.error(f"Failed to read CSV file: {e}")
                    self.folder_df = None
                return

        logger.info("Extracting folder structure from zip file...")
        self._extract_folder_structure()
        self._save_to_csv()

    @log_call
    def _find_zip_file(self):
        """Locate the example projects zip file in the examples directory."""
        for version in self.valid_versions:
            potential_zip = self.examples_dir / f"Example_Projects_{version.replace('.', '_')}.zip"
            if potential_zip.exists():
                self.zip_file_path = potential_zip
                logger.info(f"Found zip file: {self.zip_file_path}")
                break
        else:
            logger.warning("No existing example projects zip file found.")

    @log_call
    def _extract_folder_structure(self):
        """
        Extract folder structure from the zip file.

        Populates folder_df with category and project information.
        """
        folder_data = []
        try:
            with zipfile.ZipFile(self.zip_file_path, 'r') as zip_ref:
                for file in zip_ref.namelist():
                    parts = Path(file).parts
                    if len(parts) > 1:
                        folder_data.append({
                            'Category': parts[0],
                            'Project': parts[1]
                        })
        
            self.folder_df = pd.DataFrame(folder_data).drop_duplicates()
            logger.info(f"Extracted {len(self.folder_df)} projects.")
            logger.debug(f"folder_df:\n{self.folder_df}")
        except zipfile.BadZipFile:
            logger.error(f"The file {self.zip_file_path} is not a valid zip file.")
            self.folder_df = pd.DataFrame(columns=['Category', 'Project'])
        except Exception as e:
            logger.error(f"An error occurred while extracting the folder structure: {str(e)}")
            self.folder_df = pd.DataFrame(columns=['Category', 'Project'])

    @log_call
    def _save_to_csv(self):
        """Save the extracted folder structure to CSV file."""
        if self.folder_df is not None and not self.folder_df.empty:
            try:
                self.folder_df.to_csv(self.csv_file_path, index=False)
                logger.info(f"Saved project data to {self.csv_file_path}")
            except Exception as e:
                logger.error(f"Failed to save project data to CSV: {e}")
        else:
            logger.warning("No folder data to save to CSV.")


    @log_call
    def list_categories(self):
        """
        List all categories of example projects.
        """
        if self.folder_df is None or 'Category' not in self.folder_df.columns:
            logger.warning("No categories available. Make sure the zip file is properly loaded.")
            return []
        categories = self.folder_df['Category'].unique()
        logger.info(f"Available categories: {', '.join(categories)}")
        return categories.tolist()

    @log_call
    def list_projects(self, category=None):
        """
        List all projects or projects in a specific category.
        """
        if self.folder_df is None:
            logger.warning("No projects available. Make sure the zip file is properly loaded.")
            return []
        if category:
            projects = self.folder_df[self.folder_df['Category'] == category]['Project'].unique()
            logger.info(f"Projects in category '{category}': {', '.join(projects)}")
        else:
            projects = self.folder_df['Project'].unique()
            logger.info(f"All available projects: {', '.join(projects)}")
        return projects.tolist()

    @log_call
    def extract_project(self, project_names: Union[str, List[str]]):
        """
        Extract one or more specific HEC-RAS projects from the zip file.
        """
        if isinstance(project_names, str):
            project_names = [project_names]

        extracted_paths = []

        for project_name in project_names:
            logger.info("----- RasExamples Extracting Project -----")
            logger.info(f"Extracting project '{project_name}'")
            project_path = self.projects_dir

            if (project_path / project_name).exists():
                logger.info(f"Project '{project_name}' already exists. Deleting existing folder...")
                try:
                    shutil.rmtree(project_path / project_name)
                    logger.info(f"Existing folder for project '{project_name}' has been deleted.")
                except Exception as e:
                    logger.error(f"Failed to delete existing project folder '{project_name}': {e}")
                    continue

            if self.folder_df is None or self.folder_df.empty:
                error_msg = "No project information available. Make sure the zip file is properly loaded."
                logger.error(error_msg)
                raise ValueError(error_msg)

            project_info = self.folder_df[self.folder_df['Project'] == project_name]
            if project_info.empty:
                error_msg = f"Project '{project_name}' not found in the zip file."
                logger.error(error_msg)
                raise ValueError(error_msg)

            category = project_info['Category'].iloc[0]
            
            # Ensure the project directory exists
            project_path.mkdir(parents=True, exist_ok=True)

            try:
                with zipfile.ZipFile(self.zip_file_path, 'r') as zip_ref:
                    for file in zip_ref.namelist():
                        parts = Path(file).parts
                        if len(parts) > 1 and parts[1] == project_name:
                            # Remove the first level (category)
                            relative_path = Path(*parts[1:])
                            extract_path = project_path / relative_path
                            if file.endswith('/'):
                                extract_path.mkdir(parents=True, exist_ok=True)
                            else:
                                extract_path.parent.mkdir(parents=True, exist_ok=True)
                                with zip_ref.open(file) as source, open(extract_path, "wb") as target:
                                    shutil.copyfileobj(source, target)

                logger.info(f"Successfully extracted project '{project_name}' to {project_path / project_name}")
                extracted_paths.append(project_path / project_name)
            except zipfile.BadZipFile:
                logger.error(f"Error: The file {self.zip_file_path} is not a valid zip file.")
            except FileNotFoundError:
                logger.error(f"Error: The file {self.zip_file_path} was not found.")
            except Exception as e:
                logger.error(f"An unexpected error occurred while extracting the project: {str(e)}")
            logger.info("----- RasExamples Extraction Complete -----")
        return extracted_paths

    @log_call
    def is_project_extracted(self, project_name):
        """
        Check if a specific project is already extracted.
        """
        project_path = self.projects_dir / project_name
        is_extracted = project_path.exists()
        logger.info(f"Project '{project_name}' extracted: {is_extracted}")
        return is_extracted

    @log_call
    def clean_projects_directory(self):
        """Remove all extracted projects from the example_projects directory."""
        logger.info(f"Cleaning projects directory: {self.projects_dir}")
        if self.projects_dir.exists():
            try:
                shutil.rmtree(self.projects_dir)
                logger.info("All projects have been removed.")
            except Exception as e:
                logger.error(f"Failed to remove projects directory: {e}")
        else:
            logger.warning("Projects directory does not exist.")
        self.projects_dir.mkdir(parents=True, exist_ok=True)
        logger.info("Projects directory cleaned and recreated.")


    @log_call
    def download_fema_ble_model(self, huc8, output_dir=None):
        """
        Download a FEMA Base Level Engineering (BLE) model for a given HUC8.

        Args:
            huc8 (str): The 8-digit Hydrologic Unit Code (HUC) for the desired watershed.
            output_dir (str, optional): The directory to save the downloaded files. If None, uses the current working directory.

        Returns:
            str: The path to the downloaded and extracted model directory.

        Note:
            This method downloads the BLE model from the FEMA website and extracts it to the specified directory.
        """
        # Method implementation...

    @log_call
    def _make_safe_folder_name(self, name: str) -> str:
        """
        Convert a string to a safe folder name by replacing unsafe characters with underscores.
        """
        safe_name = re.sub(r'[^a-zA-Z0-9_\-]', '_', name)
        logger.debug(f"Converted '{name}' to safe folder name '{safe_name}'")
        return safe_name

    @log_call
    def _download_file_with_progress(self, url: str, dest_folder: Path, file_size: int) -> Path:
        """
        Download a file from a URL to a specified destination folder with progress bar.
        """
        local_filename = dest_folder / url.split('/')[-1]
        try:
            with requests.get(url, stream=True) as r:
                r.raise_for_status()
                with open(local_filename, 'wb') as f, tqdm(
                    desc=local_filename.name,
                    total=file_size,
                    unit='iB',
                    unit_scale=True,
                    unit_divisor=1024,
                ) as progress_bar:
                    for chunk in r.iter_content(chunk_size=8192):
                        size = f.write(chunk)
                        progress_bar.update(size)
            logger.info(f"Successfully downloaded {url} to {local_filename}")
            return local_filename
        except requests.exceptions.RequestException as e:
            logger.error(f"Request failed for {url}: {e}")
            raise
        except Exception as e:
            logger.error(f"Failed to write file {local_filename}: {e}")
            raise

    @log_call
    def _convert_size_to_bytes(self, size_str: str) -> int:
        """
        Convert a human-readable file size to bytes.
        """
        units = {'B': 1, 'KB': 1024, 'MB': 1024**2, 'GB': 1024**3, 'TB': 1024**4}
        size_str = size_str.upper().replace(' ', '')
        if not re.match(r'^\d+(\.\d+)?[BKMGT]B?$', size_str):
            raise ValueError(f"Invalid size string: {size_str}")
        
        number, unit = float(re.findall(r'[\d\.]+', size_str)[0]), re.findall(r'[BKMGT]B?', size_str)[0]
        return int(number * units[unit])
==================================================

File: c:\GH\ras-commander\ras_commander\RasGeo.py
==================================================
"""
RasGeo - Operations for handling geometry files in HEC-RAS projects

This module is part of the ras-commander library and uses a centralized logging configuration.

Logging Configuration:
- The logging is set up in the logging_config.py file.
- A @log_call decorator is available to automatically log function calls.
- Log levels: DEBUG, INFO, WARNING, ERROR, CRITICAL
- Logs are written to both console and a rotating file handler.
- The default log file is 'ras_commander.log' in the 'logs' directory.
- The default log level is INFO.

To use logging in this module:
1. Use the @log_call decorator for automatic function call logging.
2. For additional logging, use logger.[level]() calls (e.g., logger.info(), logger.debug()).
3. Obtain the logger using: logger = logging.getLogger(__name__)

Example:
    @log_call
    def my_function():
        logger = logging.getLogger(__name__)
        logger.debug("Additional debug information")
        # Function logic here
"""
import os
from pathlib import Path
from typing import List, Union
from .RasPlan import RasPlan
from .RasPrj import ras
from .LoggingConfig import get_logger
from .Decorators import log_call

logger = get_logger(__name__)

class RasGeo:
    """
    A class for operations on HEC-RAS geometry files.
    """
    
    @staticmethod
    @log_call
    def clear_geompre_files(
        plan_files: Union[str, Path, List[Union[str, Path]]] = None,
        ras_object = None
    ) -> None:
        """
        Clear HEC-RAS geometry preprocessor files for specified plan files or all plan files in the project directory.
        
        Limitations/Future Work:
        - This function only deletes the geometry preprocessor file.
        - It does not clear the IB tables.
        - It also does not clear geometry preprocessor tables from the geometry HDF.
        - All of these features will need to be added to reliably remove geometry preprocessor files for 1D and 2D projects.
        
        Parameters:
            plan_files (Union[str, Path, List[Union[str, Path]]], optional): 
                Full path(s) to the HEC-RAS plan file(s) (.p*).
                If None, clears all plan files in the project directory.
            ras_object: An optional RAS object instance.
        
        Returns:
            None
        
        Examples:
            # Clear all geometry preprocessor files in the project directory
            RasGeo.clear_geompre_files()
            
            # Clear a single plan file
            RasGeo.clear_geompre_files(r'path/to/plan.p01')
            
            # Clear multiple plan files
            RasGeo.clear_geompre_files([r'path/to/plan1.p01', r'path/to/plan2.p02'])

        Note:
            This function updates the ras object's geometry dataframe after clearing the preprocessor files.
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        def clear_single_file(plan_file: Union[str, Path], ras_obj) -> None:
            plan_path = Path(plan_file)
            geom_preprocessor_suffix = '.c' + ''.join(plan_path.suffixes[1:]) if plan_path.suffixes else '.c'
            geom_preprocessor_file = plan_path.with_suffix(geom_preprocessor_suffix)
            if geom_preprocessor_file.exists():
                try:
                    geom_preprocessor_file.unlink()
                    logger.info(f"Deleted geometry preprocessor file: {geom_preprocessor_file}")
                except PermissionError:
                    logger.error(f"Permission denied: Unable to delete geometry preprocessor file: {geom_preprocessor_file}")
                    raise PermissionError(f"Unable to delete geometry preprocessor file: {geom_preprocessor_file}. Permission denied.")
                except OSError as e:
                    logger.error(f"Error deleting geometry preprocessor file: {geom_preprocessor_file}. {str(e)}")
                    raise OSError(f"Error deleting geometry preprocessor file: {geom_preprocessor_file}. {str(e)}")
            else:
                logger.warning(f"No geometry preprocessor file found for: {plan_file}")
        
        if plan_files is None:
            logger.info("Clearing all geometry preprocessor files in the project directory.")
            plan_files_to_clear = list(ras_obj.project_folder.glob(r'*.p*'))
        elif isinstance(plan_files, (str, Path)):
            plan_files_to_clear = [plan_files]
            logger.info(f"Clearing geometry preprocessor file for single plan: {plan_files}")
        elif isinstance(plan_files, list):
            plan_files_to_clear = plan_files
            logger.info(f"Clearing geometry preprocessor files for multiple plans: {plan_files}")
        else:
            logger.error("Invalid input type for plan_files.")
            raise ValueError("Invalid input. Please provide a string, Path, list of paths, or None.")
        
        for plan_file in plan_files_to_clear:
            clear_single_file(plan_file, ras_obj)
        
        try:
            ras_obj.geom_df = ras_obj.get_geom_entries()
            logger.info("Geometry dataframe updated successfully.")
        except Exception as e:
            logger.error(f"Failed to update geometry dataframe: {str(e)}")
            raise









==================================================

File: c:\GH\ras-commander\ras_commander\RasGpt.py
==================================================
import os
from pathlib import Path
from typing import Optional
from ras_commander import get_logger, log_call

logger = get_logger(__name__)

class RasGpt:
    """
    A class containing helper functions for the RAS Commander GPT.
    """
    
# to be implemented later
# 
# This class will contain  methods to help LLM's extract useful information from HEC-RAS models in a structured format with token budget etc. 
# Templates will be used to help with this, based on the example projects (1D Steady, 1D Usteady, 1D Sediment Transport, 1D Water Quality, 2D Unsteady, 2D Steady, 2D Sediment Transport, 2D Water Quality, 2D Geospatial, 3D Unsteady, 3D Steady, 3D Sediment Transport, 3D Water Quality, 3D Geospatial).
# These will simply filter the data to only include the relevant information for the area of focus. 

#

==================================================

File: c:\GH\ras-commander\ras_commander\RasPlan.py
==================================================
"""
RasPlan - Operations for handling plan files in HEC-RAS projects

This module is part of the ras-commander library and uses a centralized logging configuration.

Logging Configuration:
- The logging is set up in the logging_config.py file.
- A @log_call decorator is available to automatically log function calls.
- Log levels: DEBUG, INFO, WARNING, ERROR, CRITICAL
- Logs are written to both console and a rotating file handler.
- The default log file is 'ras_commander.log' in the 'logs' directory.
- The default log level is INFO.

To use logging in this module:
1. Use the @log_call decorator for automatic function call logging.
2. For additional logging, use logger.[level]() calls (e.g., logger.info(), logger.debug()).
3. Obtain the logger using: logger = logging.getLogger(__name__)

Example:
    @log_call
    def my_function():
        logger = logging.getLogger(__name__)
        logger.debug("Additional debug information")
        # Function logic here
"""
import os
import re
import logging
from pathlib import Path
import shutil
from typing import Union, Optional
import pandas as pd
from .RasPrj import RasPrj, ras
from .RasUtils import RasUtils
from pathlib import Path
from typing import Union, Any
import logging
import re
from .LoggingConfig import get_logger
from .Decorators import log_call

logger = get_logger(__name__)

class RasPlan:
    """
    A class for operations on HEC-RAS plan files.
    """
    
    @staticmethod
    @log_call
    def set_geom(plan_number: Union[str, int], new_geom: Union[str, int], ras_object=None) -> pd.DataFrame:
        """
        Set the geometry for the specified plan.

        Parameters:
            plan_number (Union[str, int]): The plan number to update.
            new_geom (Union[str, int]): The new geometry number to set.
            ras_object: An optional RAS object instance.

        Returns:
            pd.DataFrame: The updated geometry DataFrame.

        Example:
            updated_geom_df = RasPlan.set_geom('02', '03')

        Note:
            This function updates the ras object's dataframes after modifying the project structure.
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()

        # Ensure plan_number and new_geom are strings
        plan_number = str(plan_number).zfill(2)
        new_geom = str(new_geom).zfill(2)

        # Before doing anything, make sure the plan, geom, flow, and unsteady dataframes are current
        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()
        
        if new_geom not in ras_obj.geom_df['geom_number'].values:
            logger.error(f"Geometry {new_geom} not found in project.")
            raise ValueError(f"Geometry {new_geom} not found in project.")

        # Update the geometry for the specified plan
        ras_obj.plan_df.loc[ras_obj.plan_df['plan_number'] == plan_number, 'geom_number'] = new_geom

        logger.info(f"Geometry for plan {plan_number} set to {new_geom}")
        logger.debug("Updated plan DataFrame:")
        logger.debug(ras_obj.plan_df)

        # Update the project file
        prj_file_path = ras_obj.prj_file
        RasUtils.update_file(prj_file_path, RasPlan._update_geom_in_file, plan_number, new_geom)

        # Re-initialize the ras object to reflect changes
        ras_obj.initialize(ras_obj.project_folder, ras_obj.ras_exe_path)

        return ras_obj.plan_df

    @staticmethod
    def _update_geom_in_file(lines, plan_number, new_geom):
        plan_pattern = re.compile(rf"^Plan File=p{plan_number}", re.IGNORECASE)
        geom_pattern = re.compile(r"^Geom File=g\d+", re.IGNORECASE)
        
        for i, line in enumerate(lines):
            if plan_pattern.match(line):
                for j in range(i+1, len(lines)):
                    if geom_pattern.match(lines[j]):
                        lines[j] = f"Geom File=g{new_geom}\n"
                        logger.info(f"Updated Geom File in project file to g{new_geom} for plan {plan_number}")
                        break
                break
        return lines

    @staticmethod
    @log_call
    def set_steady(plan_number: str, new_steady_flow_number: str, ras_object=None):
        """
        Apply a steady flow file to a plan file.
        
        Parameters:
        plan_number (str): Plan number (e.g., '02')
        new_steady_flow_number (str): Steady flow number to apply (e.g., '01')
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
        
        Returns:
        None

        Raises:
        ValueError: If the specified steady flow number is not found in the project file
        FileNotFoundError: If the specified plan file is not found

        Example:
        >>> RasPlan.set_steady('02', '01')

        Note:
            This function updates the ras object's dataframes after modifying the project structure.
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
                        
        # Update the flow dataframe in the ras instance to ensure it is current
        ras_obj.flow_df = ras_obj.get_flow_entries()
        
        if new_steady_flow_number not in ras_obj.flow_df['flow_number'].values:
            raise ValueError(f"Steady flow number {new_steady_flow_number} not found in project file.")
        
        # Resolve the full path of the plan file
        plan_file_path = RasPlan.get_plan_path(plan_number, ras_obj)
        if not plan_file_path:
            raise FileNotFoundError(f"Plan file not found: {plan_number}")
        
        RasUtils.update_file(plan_file_path, RasPlan._update_steady_in_file, new_steady_flow_number)

        # Update the ras object's dataframes
        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()

    @staticmethod
    def _update_steady_in_file(lines, new_steady_flow_number):
        return [f"Flow File=f{new_steady_flow_number}\n" if line.startswith("Flow File=f") else line for line in lines]

    @staticmethod
    @log_call
    def set_unsteady(plan_number: str, new_unsteady_flow_number: str, ras_object=None):
        """
        Apply an unsteady flow file to a plan file.
        
        Parameters:
        plan_number (str): Plan number (e.g., '04')
        new_unsteady_flow_number (str): Unsteady flow number to apply (e.g., '01')
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
        
        Returns:
        None

        Raises:
        ValueError: If the specified unsteady number is not found in the project file
        FileNotFoundError: If the specified plan file is not found

        Example:
        >>> RasPlan.set_unsteady('04', '01')

        Note:
            This function updates the ras object's dataframes after modifying the project structure.
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        # Update the unsteady dataframe in the ras instance to ensure it is current
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()
        
        if new_unsteady_flow_number not in ras_obj.unsteady_df['unsteady_number'].values:
            raise ValueError(f"Unsteady number {new_unsteady_flow_number} not found in project file.")
        
        # Get the full path of the plan file
        plan_file_path = RasPlan.get_plan_path(plan_number, ras_obj)
        if not plan_file_path:
            raise FileNotFoundError(f"Plan file not found: {plan_number}")
        
        try:
            RasUtils.update_file(plan_file_path, RasPlan._update_unsteady_in_file, new_unsteady_flow_number)
        except Exception as e:
            raise Exception(f"Failed to update unsteady flow file: {e}")

        # Update the ras object's dataframes
        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()

    @staticmethod
    def _update_unsteady_in_file(lines, new_unsteady_flow_number):
        return [f"Unsteady File=u{new_unsteady_flow_number}\n" if line.startswith("Unsteady File=u") else line for line in lines]
    @staticmethod
    @log_call
    def set_num_cores(plan_number, num_cores, ras_object=None):
        """
        Update the maximum number of cores to use in the HEC-RAS plan file.
        
        Parameters:
        plan_number (str): Plan number (e.g., '02') or full path to the plan file
        num_cores (int): Maximum number of cores to use
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
        
        Returns:
        None

        Notes on setting num_cores in HEC-RAS:
        The recommended setting for num_cores is 2 (most efficient) to 8 (most performant)
        More details in the HEC-Commander Repository Blog "Benchmarking is All You Need"
        https://github.com/billk-FM/HEC-Commander/blob/main/Blog/7._Benchmarking_Is_All_You_Need.md
        
        Microsoft Windows has a maximum of 64 cores that can be allocated to a single Ras.exe process. 

        Example:
        >>> # Using plan number
        >>> RasPlan.set_num_cores('02', 4)
        >>> # Using full path to plan file
        >>> RasPlan.set_num_cores('/path/to/project.p02', 4)

        Note:
            This function updates the ras object's dataframes after modifying the project structure.
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        plan_file_path = RasUtils.get_plan_path(plan_number, ras_obj)
        if not plan_file_path:
            raise FileNotFoundError(f"Plan file not found: {plan_number}. Please provide a valid plan number or path.")
        
        def update_num_cores(lines):
            updated_lines = []
            for line in lines:
                if "UNET D1 Cores=" in line:
                    parts = line.split("=")
                    updated_lines.append(f"{parts[0]}= {num_cores}\n")
                else:
                    updated_lines.append(line)
            return updated_lines
        
        try:
            RasUtils.update_file(plan_file_path, update_num_cores)
        except Exception as e:
            raise IOError(f"Failed to update number of cores in plan file: {e}")
        
        # Update the ras object's dataframes
        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()

    @staticmethod
    @log_call
    def set_geom_preprocessor(file_path, run_htab, use_ib_tables, ras_object=None):
        """
        Update the simulation plan file to modify the `Run HTab` and `UNET Use Existing IB Tables` settings.
        
        Parameters:
        file_path (str): Path to the simulation plan file (.p06 or similar) that you want to modify.
        run_htab (int): Value for the `Run HTab` setting:
            - `0` : Do not run the geometry preprocessor, use existing geometry tables.
            - `-1` : Run the geometry preprocessor, forcing a recomputation of the geometry tables.
        use_ib_tables (int): Value for the `UNET Use Existing IB Tables` setting:
            - `0` : Use existing interpolation/boundary (IB) tables without recomputing them.
            - `-1` : Do not use existing IB tables, force a recomputation.
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
        
        Returns:
        None

        Raises:
        ValueError: If `run_htab` or `use_ib_tables` are not integers or not within the accepted values (`0` or `-1`).
        FileNotFoundError: If the specified file does not exist.
        IOError: If there is an error reading or writing the file.

        Example:
        >>> RasPlan.set_geom_preprocessor('/path/to/project.p06', run_htab=-1, use_ib_tables=0)

        Note:
            This function updates the ras object's dataframes after modifying the project structure.
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        if run_htab not in [-1, 0]:
            raise ValueError("Invalid value for `Run HTab`. Expected `0` or `-1`.")
        if use_ib_tables not in [-1, 0]:
            raise ValueError("Invalid value for `UNET Use Existing IB Tables`. Expected `0` or `-1`.")
        
        def update_geom_preprocessor(lines, run_htab, use_ib_tables):
            updated_lines = []
            for line in lines:
                if line.lstrip().startswith("Run HTab="):
                    updated_lines.append(f"Run HTab= {run_htab} \n")
                elif line.lstrip().startswith("UNET Use Existing IB Tables="):
                    updated_lines.append(f"UNET Use Existing IB Tables= {use_ib_tables} \n")
                else:
                    updated_lines.append(line)
            return updated_lines
        
        try:
            RasUtils.update_file(file_path, update_geom_preprocessor, run_htab, use_ib_tables)
        except FileNotFoundError:
            raise FileNotFoundError(f"The file '{file_path}' does not exist.")
        except IOError as e:
            raise IOError(f"An error occurred while reading or writing the file: {e}")

        # Update the ras object's dataframes
        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()

    @staticmethod
    @log_call
    def get_results_path(plan_number: str, ras_object=None) -> Optional[str]:
        """
        Retrieve the results file path for a given HEC-RAS plan number.

        Args:
            plan_number (str): The HEC-RAS plan number for which to find the results path.
            ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.

        Returns:
            Optional[str]: The full path to the results file if found and the file exists, or None if not found.

        Raises:
            RuntimeError: If the project is not initialized.

        Example:
            >>> ras_plan = RasPlan()
            >>> results_path = ras_plan.get_results_path('01')
            >>> if results_path:
            ...     print(f"Results file found at: {results_path}")
            ... else:
            ...     print("Results file not found.")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        # Update the plan dataframe in the ras instance to ensure it is current
        ras_obj.plan_df = ras_obj.get_plan_entries()
        
        # Ensure plan_number is a string
        plan_number = str(plan_number).zfill(2)
        
        plan_entry = ras_obj.plan_df[ras_obj.plan_df['plan_number'] == plan_number]
        if not plan_entry.empty:
            results_path = plan_entry['HDF_Results_Path'].iloc[0]
            if results_path and Path(results_path).exists():
                return results_path
            else:
                return None
        else:
            return None

    @staticmethod
    @log_call
    def get_plan_path(plan_number: str, ras_object=None) -> Optional[str]:
        """
        Return the full path for a given plan number.
        
        This method ensures that the latest plan entries are included by refreshing
        the plan dataframe before searching for the requested plan number.
        
        Args:
        plan_number (str): The plan number to search for.
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
        
        Returns:
        Optional[str]: The full path of the plan file if found, None otherwise.
        
        Raises:
        RuntimeError: If the project is not initialized.

        Example:
        >>> ras_plan = RasPlan()
        >>> plan_path = ras_plan.get_plan_path('01')
        >>> if plan_path:
        ...     print(f"Plan file found at: {plan_path}")
        ... else:
        ...     print("Plan file not found.")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        # Use updated plan dataframe
        plan_df = ras_obj.get_plan_entries()
        
        plan_path = plan_df[plan_df['plan_number'] == plan_number]
        
        if not plan_path.empty:
            full_path = plan_path['full_path'].iloc[0]
            return full_path
        else:
            return None

    @staticmethod
    @log_call
    def get_flow_path(flow_number: str, ras_object=None) -> Optional[str]:
        """
        Return the full path for a given flow number.

        Args:
        flow_number (str): The flow number to search for.
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.

        Returns:
        Optional[str]: The full path of the flow file if found, None otherwise.

        Raises:
        RuntimeError: If the project is not initialized.

        Example:
        >>> ras_plan = RasPlan()
        >>> flow_path = ras_plan.get_flow_path('01')
        >>> if flow_path:
        ...     print(f"Flow file found at: {flow_path}")
        ... else:
        ...     print("Flow file not found.")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        # Use updated flow dataframe
        ras_obj.flow_df = ras_obj.get_prj_entries('Flow')
        
        flow_path = ras_obj.flow_df[ras_obj.flow_df['flow_number'] == flow_number]
        if not flow_path.empty:
            full_path = flow_path['full_path'].iloc[0]
            return full_path
        else:
            return None

    @staticmethod
    @log_call
    def get_unsteady_path(unsteady_number: str, ras_object=None) -> Optional[str]:
        """
        Return the full path for a given unsteady number.

        Args:
        unsteady_number (str): The unsteady number to search for.
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.

        Returns:
        Optional[str]: The full path of the unsteady file if found, None otherwise.

        Raises:
        RuntimeError: If the project is not initialized.

        Example:
        >>> ras_plan = RasPlan()
        >>> unsteady_path = ras_plan.get_unsteady_path('01')
        >>> if unsteady_path:
        ...     print(f"Unsteady file found at: {unsteady_path}")
        ... else:
        ...     print("Unsteady file not found.")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        # Use updated unsteady dataframe
        ras_obj.unsteady_df = ras_obj.get_prj_entries('Unsteady')
        
        unsteady_path = ras_obj.unsteady_df[ras_obj.unsteady_df['unsteady_number'] == unsteady_number]
        if not unsteady_path.empty:
            full_path = unsteady_path['full_path'].iloc[0]
            return full_path
        else:
            return None

    @staticmethod
    @log_call
    def get_geom_path(geom_number: str, ras_object=None) -> Optional[str]:
        """
        Return the full path for a given geometry number.

        Args:
        geom_number (str): The geometry number to search for.
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.

        Returns:
        Optional[str]: The full path of the geometry file if found, None otherwise.

        Raises:
        RuntimeError: If the project is not initialized.

        Example:
        >>> ras_plan = RasPlan()
        >>> geom_path = ras_plan.get_geom_path('01')
        >>> if geom_path:
        ...     print(f"Geometry file found at: {geom_path}")
        ... else:
        ...     print("Geometry file not found.")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        # Use updated geom dataframe
        ras_obj.geom_df = ras_obj.get_prj_entries('Geom')
        
        geom_path = ras_obj.geom_df[ras_obj.geom_df['geom_number'] == geom_number]
        if not geom_path.empty:
            full_path = geom_path['full_path'].iloc[0]
            return full_path
        else:
            return None

    # Clone Functions to copy unsteady, flow, and geometry files from templates

    @staticmethod
    @log_call
    def clone_plan(template_plan, new_plan_shortid=None, ras_object=None):
        """
        Create a new plan file based on a template and update the project file.
        
        Parameters:
        template_plan (str): Plan number to use as template (e.g., '01')
        new_plan_shortid (str, optional): New short identifier for the plan file
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
        
        Returns:
        str: New plan number
        
        Example:
        >>> ras_plan = RasPlan()
        >>> new_plan_number = ras_plan.clone_plan('01', new_plan_shortid='New Plan')
        >>> print(f"New plan created with number: {new_plan_number}")

        Note:
            This function updates the ras object's dataframes after modifying the project structure.
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()

        # Update plan entries without reinitializing the entire project
        ras_obj.plan_df = ras_obj.get_prj_entries('Plan')

        new_plan_num = RasPlan.get_next_number(ras_obj.plan_df['plan_number'])
        template_plan_path = ras_obj.project_folder / f"{ras_obj.project_name}.p{template_plan}"
        new_plan_path = ras_obj.project_folder / f"{ras_obj.project_name}.p{new_plan_num}"

        def update_shortid(lines):
            shortid_pattern = re.compile(r'^Short Identifier=(.*)$', re.IGNORECASE)
            for i, line in enumerate(lines):
                match = shortid_pattern.match(line.strip())
                if match:
                    current_shortid = match.group(1)
                    if new_plan_shortid is None:
                        new_shortid = (current_shortid + "_copy")[:24]
                    else:
                        new_shortid = new_plan_shortid[:24]
                    lines[i] = f"Short Identifier={new_shortid}\n"
                    break
            return lines

        # Use RasUtils to clone the file and update the short identifier
        RasUtils.clone_file(template_plan_path, new_plan_path, update_shortid)

        # Use RasUtils to update the project file
        RasUtils.update_project_file(ras_obj.prj_file, 'Plan', new_plan_num, ras_object=ras_obj)

        # Re-initialize the ras global object
        ras_obj.initialize(ras_obj.project_folder, ras_obj.ras_exe_path)

        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()

        return new_plan_num

    @staticmethod
    @log_call
    def clone_unsteady(template_unsteady, ras_object=None):
        """
        Copy unsteady flow files from a template, find the next unsteady number,
        and update the project file accordingly.

        Parameters:
        template_unsteady (str): Unsteady flow number to be used as a template (e.g., '01')
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.

        Returns:
        str: New unsteady flow number (e.g., '03')

        Example:
        >>> ras_plan = RasPlan()
        >>> new_unsteady_num = ras_plan.clone_unsteady('01')
        >>> print(f"New unsteady flow file created: u{new_unsteady_num}")

        Note:
            This function updates the ras object's dataframes after modifying the project structure.
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()

        # Update unsteady entries without reinitializing the entire project
        ras_obj.unsteady_df = ras_obj.get_prj_entries('Unsteady')

        new_unsteady_num = RasPlan.get_next_number(ras_obj.unsteady_df['unsteady_number'])
        template_unsteady_path = ras_obj.project_folder / f"{ras_obj.project_name}.u{template_unsteady}"
        new_unsteady_path = ras_obj.project_folder / f"{ras_obj.project_name}.u{new_unsteady_num}"

        # Use RasUtils to clone the file
        RasUtils.clone_file(template_unsteady_path, new_unsteady_path)

        # Copy the corresponding .hdf file if it exists
        template_hdf_path = ras_obj.project_folder / f"{ras_obj.project_name}.u{template_unsteady}.hdf"
        new_hdf_path = ras_obj.project_folder / f"{ras_obj.project_name}.u{new_unsteady_num}.hdf"
        if template_hdf_path.exists():
            shutil.copy(template_hdf_path, new_hdf_path)

        # Use RasUtils to update the project file
        RasUtils.update_project_file(ras_obj.prj_file, 'Unsteady', new_unsteady_num, ras_object=ras_obj)

        # Re-initialize the ras global object
        ras_obj.initialize(ras_obj.project_folder, ras_obj.ras_exe_path)

        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()

        return new_unsteady_num


    @staticmethod
    @log_call
    def clone_steady(template_flow, ras_object=None):
        """
        Copy steady flow files from a template, find the next flow number,
        and update the project file accordingly.
        
        Parameters:
        template_flow (str): Flow number to be used as a template (e.g., '01')
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
        
        Returns:
        str: New flow number (e.g., '03')

        Example:
        >>> ras_plan = RasPlan()
        >>> new_flow_num = ras_plan.clone_steady('01')
        >>> print(f"New steady flow file created: f{new_flow_num}")

        Note:
            This function updates the ras object's dataframes after modifying the project structure.
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()

        # Update flow entries without reinitializing the entire project
        ras_obj.flow_df = ras_obj.get_prj_entries('Flow')

        new_flow_num = RasPlan.get_next_number(ras_obj.flow_df['flow_number'])
        template_flow_path = ras_obj.project_folder / f"{ras_obj.project_name}.f{template_flow}"
        new_flow_path = ras_obj.project_folder / f"{ras_obj.project_name}.f{new_flow_num}"

        # Use RasUtils to clone the file
        RasUtils.clone_file(template_flow_path, new_flow_path)

        # Use RasUtils to update the project file
        RasUtils.update_project_file(ras_obj.prj_file, 'Flow', new_flow_num, ras_object=ras_obj)

        # Re-initialize the ras global object
        ras_obj.initialize(ras_obj.project_folder, ras_obj.ras_exe_path)
        
        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()
        
        return new_flow_num

    @staticmethod
    @log_call
    def clone_geom(template_geom, ras_object=None):
        """
        Copy geometry files from a template, find the next geometry number,
        and update the project file accordingly.
        
        Parameters:
        template_geom (str): Geometry number to be used as a template (e.g., '01')
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
        
        Returns:
        str: New geometry number (e.g., '03')

        Note:
            This function updates the ras object's dataframes after modifying the project structure.
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()

        # Update geometry entries without reinitializing the entire project
        ras_obj.geom_df = ras_obj.get_prj_entries('Geom')

        new_geom_num = RasPlan.get_next_number(ras_obj.geom_df['geom_number'])
        template_geom_path = ras_obj.project_folder / f"{ras_obj.project_name}.g{template_geom}"
        new_geom_path = ras_obj.project_folder / f"{ras_obj.project_name}.g{new_geom_num}"

        # Use RasUtils to clone the file
        RasUtils.clone_file(template_geom_path, new_geom_path)

        # Handle HDF file copy
        template_hdf_path = ras_obj.project_folder / f"{ras_obj.project_name}.g{template_geom}.hdf"
        new_hdf_path = ras_obj.project_folder / f"{ras_obj.project_name}.g{new_geom_num}.hdf"
        if template_hdf_path.is_file():
            RasUtils.clone_file(template_hdf_path, new_hdf_path)

        # Use RasUtils to update the project file
        RasUtils.update_project_file(ras_obj.prj_file, 'Geom', new_geom_num, ras_object=ras_obj)

        # Update all dataframes in the ras object
        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()

        return new_geom_num

    @staticmethod
    @log_call
    def get_next_number(existing_numbers):
        """
        Determine the next available number from a list of existing numbers.
        
        Parameters:
        existing_numbers (list): List of existing numbers as strings
        
        Returns:
        str: Next available number as a zero-padded string
        
        Example:
        >>> existing_numbers = ['01', '02', '04']
        >>> RasPlan.get_next_number(existing_numbers)
        '03'
        >>> existing_numbers = ['01', '02', '03']
        >>> RasPlan.get_next_number(existing_numbers)
        '04'
        """
        existing_numbers = sorted(int(num) for num in existing_numbers)
        next_number = 1
        for num in existing_numbers:
            if num == next_number:
                next_number += 1
            else:
                break
        return f"{next_number:02d}"

    @staticmethod
    @log_call
    def get_plan_value(
        plan_number_or_path: Union[str, Path],
        key: str,
        ras_object=None
    ) -> Any:
        """
        Retrieve a specific value from a HEC-RAS plan file.

        Parameters:
        plan_number_or_path (Union[str, Path]): The plan number (1 to 99) or full path to the plan file
        key (str): The key to retrieve from the plan file
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.

        Returns:
        Any: The value associated with the specified key

        Raises:
        ValueError: If the plan file is not found
        IOError: If there's an error reading the plan file

        Available keys and their expected types:
        - 'Computation Interval' (str): Time value for computational time step (e.g., '5SEC', '2MIN')
        - 'DSS File' (str): Name of the DSS file used
        - 'Flow File' (str): Name of the flow input file
        - 'Friction Slope Method' (int): Method selection for friction slope (e.g., 1, 2)
        - 'Geom File' (str): Name of the geometry input file
        - 'Mapping Interval' (str): Time interval for mapping output
        - 'Plan File' (str): Name of the plan file
        - 'Plan Title' (str): Title of the simulation plan
        - 'Program Version' (str): Version number of HEC-RAS
        - 'Run HTAB' (int): Flag to run HTab module (-1 or 1)
        - 'Run Post Process' (int): Flag to run post-processing (-1 or 1)
        - 'Run Sediment' (int): Flag to run sediment transport module (0 or 1)
        - 'Run UNET' (int): Flag to run unsteady network module (-1 or 1)
        - 'Run WQNET' (int): Flag to run water quality module (0 or 1)
        - 'Short Identifier' (str): Short name or ID for the plan
        - 'Simulation Date' (str): Start and end dates/times for simulation
        - 'UNET D1 Cores' (int): Number of cores used in 1D calculations
        - 'UNET Use Existing IB Tables' (int): Flag for using existing internal boundary tables (-1, 0, or 1)
        - 'UNET 1D Methodology' (str): 1D calculation methodology
        - 'UNET D2 Solver Type' (str): 2D solver type
        - 'UNET D2 Name' (str): Name of the 2D area
        - 'Run RASMapper' (int): Flag to run RASMapper for floodplain mapping (-1 for off, 0 for on)
        
        
        Note: 
        Writing Multi line keys like 'Description' are not supported by this function.

        Example:
        >>> computation_interval = RasPlan.get_plan_value("01", "Computation Interval")
        >>> print(f"Computation interval: {computation_interval}")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()

        supported_plan_keys = {
            'Description', 'Computation Interval', 'DSS File', 'Flow File', 'Friction Slope Method',
            'Geom File', 'Mapping Interval', 'Plan File', 'Plan Title', 'Program Version',
            'Run HTAB', 'Run Post Process', 'Run Sediment', 'Run UNET', 'Run WQNET',
            'Short Identifier', 'Simulation Date', 'UNET D1 Cores', 'UNET Use Existing IB Tables',
            'UNET 1D Methodology', 'UNET D2 Solver Type', 'UNET D2 Name', 'Run RASMapper'
        }

        if key not in supported_plan_keys:
            logger = logging.getLogger(__name__)
            logger.warning(f"Unknown key: {key}. Valid keys are: {', '.join(supported_plan_keys)}\n Add more keys and explanations in get_plan_value() as needed.")

        plan_file_path = Path(plan_number_or_path)
        if not plan_file_path.is_file():
            plan_file_path = RasPlan.get_plan_path(plan_number_or_path, ras_object=ras_obj)
            if plan_file_path is None or not Path(plan_file_path).exists():
                raise ValueError(f"Plan file not found: {plan_file_path}")

        try:
            with open(plan_file_path, 'r') as file:
                content = file.read()
        except IOError as e:
            logger = logging.getLogger(__name__)
            logger.error(f"Error reading plan file {plan_file_path}: {e}")
            raise

        if key == 'Description':
            match = re.search(r'Begin DESCRIPTION(.*?)END DESCRIPTION', content, re.DOTALL)
            return match.group(1).strip() if match else None
        else:
            pattern = f"{key}=(.*)"
            match = re.search(pattern, content)
            if match:
                return match.group(1).strip()
            else:
                logger = logging.getLogger(__name__)
                logger.error(f"Key '{key}' not found in the plan file.")
                return None

    @staticmethod
    @log_call
    def update_plan_value(
        plan_number_or_path: Union[str, Path],
        key: str,
        value: Any,
        ras_object=None
    ) -> None:
        """
        Update a specific key-value pair in a HEC-RAS plan file.

        Parameters:
        plan_number_or_path (Union[str, Path]): The plan number (1 to 99) or full path to the plan file
        key (str): The key to update in the plan file
        value (Any): The new value to set for the key
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.

        Raises:
        ValueError: If the plan file is not found
        IOError: If there's an error reading or writing the plan file

        Note: See the docstring of get_plan_value for a full list of available keys and their types.

        Example:
        >>> RasPlan.update_plan_value("01", "computation_interval", "10SEC")
        >>> RasPlan.update_plan_value("/path/to/plan.p01", "run_htab", 1)
        >>> RasPlan.update_plan_value("01", "run_rasmapper", 0)  # Turn on Floodplain Mapping
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()

        supported_plan_keys = {
            'Description', 'Computation Interval', 'DSS File', 'Flow File', 'Friction Slope Method',
            'Geom File', 'Mapping Interval', 'Plan File', 'Plan Title', 'Program Version',
            'Run HTAB', 'Run Post Process', 'Run Sediment', 'Run UNET', 'Run WQNET',
            'Short Identifier', 'Simulation Date', 'UNET D1 Cores', 'UNET Use Existing IB Tables',
            'UNET 1D Methodology', 'UNET D2 Solver Type', 'UNET D2 Name', 'Run RASMapper'
        }
        logger = logging.getLogger(__name__)
        if key not in supported_plan_keys:
            logger.warning(f"Unknown key: {key}. Valid keys are: {', '.join(supported_plan_keys)}")

        plan_file_path = Path(plan_number_or_path)
        if not plan_file_path.is_file():
            plan_file_path = RasPlan.get_plan_path(plan_number_or_path, ras_object)
            if plan_file_path is None or not Path(plan_file_path).exists():
                raise ValueError(f"Plan file not found: {plan_file_path}")

        try:
            with open(plan_file_path, 'r') as file:
                lines = file.readlines()
        except IOError as e:
            logger.error(f"Error reading plan file {plan_file_path}: {e}")
            raise

        # Special handling for description
        if key == 'description':
            description_start = None
            description_end = None
            for i, line in enumerate(lines):
                if line.strip() == 'Begin DESCRIPTION':
                    description_start = i
                elif line.strip() == 'END DESCRIPTION':
                    description_end = i
                    break
            if description_start is not None and description_end is not None:
                lines[description_start+1:description_end] = [f"{value}\n"]
            else:
                lines.append(f"Begin DESCRIPTION\n{value}\nEND DESCRIPTION\n")
        else:
            # For other keys
            pattern = f"{key.replace('_', ' ').title()}="
            updated = False
            for i, line in enumerate(lines):
                if line.startswith(pattern):
                    lines[i] = f"{pattern}{value}\n"
                    updated = True
                    break
            if not updated:
                logger.error(f"Key '{key}' not found in the plan file.")
                return

        try:
            with open(plan_file_path, 'w') as file:
                file.writelines(lines)
            logger.info(f"Updated {key} in plan file: {plan_file_path}")
        except IOError as e:
            logger.error(f"Error writing to plan file {plan_file_path}: {e}")
            raise

        # Refresh RasPrj dataframes
        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()
==================================================

File: c:\GH\ras-commander\ras_commander\RasPrj.py
==================================================
"""
RasPrj.py - Manages HEC-RAS projects within the ras-commander library

This module provides a class for managing HEC-RAS projects.

Classes:
    RasPrj: A class for managing HEC-RAS projects.

Functions:
    init_ras_project: Initialize a RAS project.
    get_ras_exe: Determine the HEC-RAS executable path based on the input.

DEVELOPER NOTE:
This class is used to initialize a RAS project and is used in conjunction with the RasCmdr class to manage the execution of RAS plans.
By default, the RasPrj class is initialized with the global 'ras' object.
However, you can create multiple RasPrj instances to manage multiple projects.
Do not mix and match global 'ras' object instances and custom instances of RasPrj - it will cause errors.

This module is part of the ras-commander library and uses a centralized logging configuration.

Logging Configuration:
- The logging is set up in the logging_config.py file.
- A @log_call decorator is available to automatically log function calls.
- Log levels: DEBUG, INFO, WARNING, ERROR, CRITICAL
- Logs are written to both console and a rotating file handler.
- The default log file is 'ras_commander.log' in the 'logs' directory.
- The default log level is INFO.

To use logging in this module:
1. Use the @log_call decorator for automatic function call logging.
2. For additional logging, use logger.[level]() calls (e.g., logger.info(), logger.debug()).


Example:
    @log_call
    def my_function():
        
        logger.debug("Additional debug information")
        # Function logic here
"""
import os
import re
from pathlib import Path
import pandas as pd
from typing import Union, Any, List, Dict, Tuple
import logging
from ras_commander.LoggingConfig import get_logger
from ras_commander.Decorators import log_call

logger = get_logger(__name__)

class RasPrj:
    
    def __init__(self):
        self.initialized = False
        self.boundaries_df = None  # New attribute to store boundary conditions

    @log_call
    def initialize(self, project_folder, ras_exe_path):
        """
        Initialize a RasPrj instance.

        This method sets up the RasPrj instance with the given project folder and RAS executable path.
        It finds the project file, loads project data, sets the initialization flag, and now also
        extracts boundary conditions.

        Args:
            project_folder (str or Path): Path to the HEC-RAS project folder.
            ras_exe_path (str or Path): Path to the HEC-RAS executable.

        Raises:
            ValueError: If no HEC-RAS project file is found in the specified folder.

        Note:
            This method is intended for internal use. External users should use the init_ras_project function instead.
        """
        self.project_folder = Path(project_folder)
        self.prj_file = self.find_ras_prj(self.project_folder)
        if self.prj_file is None:
            logger.error(f"No HEC-RAS project file found in {self.project_folder}")
            raise ValueError(f"No HEC-RAS project file found in {self.project_folder}")
        self.project_name = Path(self.prj_file).stem
        self.ras_exe_path = ras_exe_path
        self._load_project_data()
        self.boundaries_df = self.get_boundary_conditions()  # Extract boundary conditions
        self.initialized = True
        logger.info(f"Initialization complete for project: {self.project_name}")
        logger.info(f"Plan entries: {len(self.plan_df)}, Flow entries: {len(self.flow_df)}, "
                     f"Unsteady entries: {len(self.unsteady_df)}, Geometry entries: {len(self.geom_df)}, "
                     f"Boundary conditions: {len(self.boundaries_df)}")
        logger.info(f"Geometry HDF files found: {self.plan_df['Geom_File'].notna().sum()}")

    @log_call
    def _load_project_data(self):
        """
        Load project data from the HEC-RAS project file.

        This method initializes DataFrames for plan, flow, unsteady, and geometry entries
        by calling the _get_prj_entries method for each entry type.
        """
        # Initialize DataFrames
        self.plan_df = self._get_prj_entries('Plan')
        self.flow_df = self._get_prj_entries('Flow')
        self.unsteady_df = self._get_prj_entries('Unsteady')
        self.geom_df = self.get_geom_entries()  # Use get_geom_entries instead of _get_prj_entries
        
        # Add Geom_File to plan_df
        self.plan_df['Geom_File'] = self.plan_df.apply(lambda row: self._get_geom_file_for_plan(row['plan_number']), axis=1)

    @log_call
    def _get_geom_file_for_plan(self, plan_number):
        """
        Get the geometry file path for a given plan number.
        
        Args:
            plan_number (str): The plan number to find the geometry file for.
        
        Returns:
            str: The full path to the geometry HDF file, or None if not found.
        """
        plan_file_path = self.project_folder / f"{self.project_name}.p{plan_number}"
        try:
            with open(plan_file_path, 'r') as plan_file:
                for line in plan_file:
                    if line.startswith("Geom File="):
                        geom_file = line.strip().split('=')[1]
                        geom_hdf_path = self.project_folder / f"{self.project_name}.{geom_file}.hdf"
                        if geom_hdf_path.exists():
                            return str(geom_hdf_path)
                        else:
                            return None
        except Exception as e:
            logger.error(f"Error reading plan file for geometry: {e}")
        return None

    @log_call
    def _parse_plan_file(self, plan_file_path):
        """
        Parse a plan file and extract critical information.
        
        Args:
            plan_file_path (Path): Path to the plan file.
        
        Returns:
            dict: Dictionary containing extracted plan information.
        """
        plan_info = {}
        try:
            with open(plan_file_path, 'r') as file:
                content = file.read()
                
                # Extract description
                description_match = re.search(r'Begin DESCRIPTION(.*?)END DESCRIPTION', content, re.DOTALL)
                if description_match:
                    plan_info['description'] = description_match.group(1).strip()
                
                # BEGIN Exception to Style Guide, this is needed to keep the key names consistent with the plan file keys.
                
                # Extract other critical information
                supported_plan_keys = {
                    'Computation Interval': r'Computation Interval=(.+)',
                    'DSS File': r'DSS File=(.+)',
                    'Flow File': r'Flow File=(.+)',
                    'Friction Slope Method': r'Friction Slope Method=(.+)',
                    'Geom File': r'Geom File=(.+)',
                    'Mapping Interval': r'Mapping Interval=(.+)',
                    'Plan Title': r'Plan Title=(.+)',
                    'Program Version': r'Program Version=(.+)',
                    'Run HTab': r'Run HTab=(.+)',
                    'Run PostProcess': r'Run PostProcess=(.+)',
                    'Run Sediment': r'Run Sediment=(.+)',
                    'Run UNet': r'Run UNet=(.+)',
                    'Run WQNet': r'Run WQNet=(.+)',
                    'Short Identifier': r'Short Identifier=(.+)',
                    'Simulation Date': r'Simulation Date=(.+)',
                    'UNET D1 Cores': r'UNET D1 Cores=(.+)',
                    'UNET Use Existing IB Tables': r'UNET Use Existing IB Tables=(.+)',
                    'UNET 1D Methodology': r'UNET 1D Methodology=(.+)',
                    'UNET D2 SolverType': r'UNET D2 SolverType=(.+)',
                    'UNET D2 Name': r'UNET D2 Name=(.+)'
                }
                
                # END Exception to Style Guide
                
                for key, pattern in supported_plan_keys.items():
                    match = re.search(pattern, content)
                    if match:
                        plan_info[key] = match.group(1).strip()
            
            logger.debug(f"Parsed plan file: {plan_file_path}")
        except Exception as e:
            logger.exception(f"Error parsing plan file {plan_file_path}: {e}")
        
        return plan_info
    

    
    @log_call
    def _get_prj_entries(self, entry_type):
        """
        Extract entries of a specific type from the HEC-RAS project file.

        Args:
            entry_type (str): The type of entry to extract (e.g., 'Plan', 'Flow', 'Unsteady', 'Geom').

        Returns:
            pd.DataFrame: A DataFrame containing the extracted entries.

        Note:
            This method reads the project file and extracts entries matching the specified type.
            For 'Unsteady' entries, it parses additional information from the unsteady file.
        """
        entries = []
        pattern = re.compile(rf"{entry_type} File=(\w+)")

        try:
            with open(self.prj_file, 'r') as file:
                for line in file:
                    match = pattern.match(line.strip())
                    if match:
                        file_name = match.group(1)
                        full_path = str(self.project_folder / f"{self.project_name}.{file_name}")
                        entry = {
                            f'{entry_type.lower()}_number': file_name[1:],
                            'full_path': full_path
                        }

                        if entry_type == 'Plan':
                            plan_info = self._parse_plan_file(Path(full_path))
                            entry.update(plan_info)
                            
                            hdf_results_path = self.project_folder / f"{self.project_name}.p{file_name[1:]}.hdf"
                            entry['HDF_Results_Path'] = str(hdf_results_path) if hdf_results_path.exists() else None

                        if entry_type == 'Unsteady':
                            unsteady_info = self._parse_unsteady_file(Path(full_path))
                            entry.update(unsteady_info)

                        entries.append(entry)
        except Exception as e:
            raise

        return pd.DataFrame(entries)

    @log_call
    def _parse_unsteady_file(self, unsteady_file_path):
        """
        Parse an unsteady flow file and extract critical information.
        
        Args:
            unsteady_file_path (Path): Path to the unsteady flow file.
        
        Returns:
            dict: Dictionary containing extracted unsteady flow information.
        """
        unsteady_info = {}
        with open(unsteady_file_path, 'r') as file:
            content = file.read()
            
            # BEGIN Exception to Style Guide, this is needed to keep the key names consistent with the unsteady file keys.
                
            supported_unsteady_keys = {
                'Flow Title': r'Flow Title=(.+)',
                'Program Version': r'Program Version=(.+)',
                'Use Restart': r'Use Restart=(.+)',
                'Precipitation Mode': r'Precipitation Mode=(.+)',
                'Wind Mode': r'Wind Mode=(.+)',
                'Met BC=Precipitation|Mode': r'Met BC=Precipitation\|Mode=(.+)',
                'Met BC=Evapotranspiration|Mode': r'Met BC=Evapotranspiration\|Mode=(.+)',
                'Met BC=Precipitation|Expanded View': r'Met BC=Precipitation\|Expanded View=(.+)',
                'Met BC=Precipitation|Constant Units': r'Met BC=Precipitation\|Constant Units=(.+)',
                'Met BC=Precipitation|Gridded Source': r'Met BC=Precipitation\|Gridded Source=(.+)'
            }
            
            # END Exception to Style Guide
            
            for key, pattern in supported_unsteady_keys.items():
                match = re.search(pattern, content)
                if match:
                    unsteady_info[key] = match.group(1).strip()
        
        return unsteady_info

    @property
    def is_initialized(self):
        """
        Check if the RasPrj instance has been initialized.

        Returns:
            bool: True if the instance has been initialized, False otherwise.
        """
        return self.initialized

    @log_call
    def check_initialized(self):
        """
        Ensure that the RasPrj instance has been initialized.

        Raises:
            RuntimeError: If the project has not been initialized.
        """
        if not self.initialized:
            raise RuntimeError("Project not initialized. Call init_ras_project() first.")

    @staticmethod
    @log_call
    def find_ras_prj(folder_path):
        """
        Find the appropriate HEC-RAS project file (.prj) in the given folder.
        
        Parameters:
        folder_path (str or Path): Path to the folder containing HEC-RAS files.
        
        Returns:
        Path: The full path of the selected .prj file or None if no suitable file is found.
        """
        folder_path = Path(folder_path)
        prj_files = list(folder_path.glob("*.prj"))
        rasmap_files = list(folder_path.glob("*.rasmap"))
        if len(prj_files) == 1:
            return prj_files[0].resolve()
        if len(prj_files) > 1:
            if len(rasmap_files) == 1:
                base_filename = rasmap_files[0].stem
                prj_file = folder_path / f"{base_filename}.prj"
                if prj_file.exists():
                    return prj_file.resolve()
            for prj_file in prj_files:
                try:
                    with open(prj_file, 'r') as file:
                        content = file.read()
                        if "Proj Title=" in content:
                            return prj_file.resolve()
                except Exception:
                    continue
        return None


    @log_call
    def get_project_name(self):
        """
        Get the name of the HEC-RAS project.

        Returns:
            str: The name of the project.

        Raises:
            RuntimeError: If the project has not been initialized.
        """
        self.check_initialized()
        return self.project_name

    @log_call
    def get_prj_entries(self, entry_type):
        """
        Get entries of a specific type from the HEC-RAS project.

        Args:
            entry_type (str): The type of entry to retrieve (e.g., 'Plan', 'Flow', 'Unsteady', 'Geom').

        Returns:
            pd.DataFrame: A DataFrame containing the requested entries.

        Raises:
            RuntimeError: If the project has not been initialized.
        """
        self.check_initialized()
        return self._get_prj_entries(entry_type)

    @log_call
    def get_plan_entries(self):
        """
        Get all plan entries from the HEC-RAS project.

        Returns:
            pd.DataFrame: A DataFrame containing all plan entries.

        Raises:
            RuntimeError: If the project has not been initialized.
        """
        self.check_initialized()
        return self._get_prj_entries('Plan')

    @log_call
    def get_flow_entries(self):
        """
        Get all flow entries from the HEC-RAS project.

        Returns:
            pd.DataFrame: A DataFrame containing all flow entries.

        Raises:
            RuntimeError: If the project has not been initialized.
        """
        self.check_initialized()
        return self._get_prj_entries('Flow')

    @log_call
    def get_unsteady_entries(self):
        """
        Get all unsteady flow entries from the HEC-RAS project.

        Returns:
            pd.DataFrame: A DataFrame containing all unsteady flow entries.

        Raises:
            RuntimeError: If the project has not been initialized.
        """
        self.check_initialized()
        return self._get_prj_entries('Unsteady')

    @log_call
    def get_geom_entries(self):
        """
        Get geometry entries from the project file.

        Returns:
            pd.DataFrame: DataFrame containing geometry entries.
        """
        geom_pattern = re.compile(r'Geom File=(\w+)')
        geom_entries = []

        try:
            with open(self.prj_file, 'r') as f:
                for line in f:
                    match = geom_pattern.search(line)
                    if match:
                        geom_entries.append(match.group(1))
        
            geom_df = pd.DataFrame({'geom_file': geom_entries})
            geom_df['geom_number'] = geom_df['geom_file'].str.extract(r'(\d+)$')
            geom_df['full_path'] = geom_df['geom_file'].apply(lambda x: str(self.project_folder / f"{self.project_name}.{x}"))
            geom_df['hdf_path'] = geom_df['full_path'] + ".hdf"
            
            logger.info(f"Found {len(geom_df)} geometry entries")
            return geom_df
        except Exception as e:
            logger.error(f"Error reading geometry entries from project file: {e}")
            raise
    
    @log_call
    def get_hdf_entries(self):
        """
        Get HDF entries for plans that have results.
        
        Returns:
            pd.DataFrame: A DataFrame containing plan entries with HDF results.
                      Returns an empty DataFrame if no HDF entries are found.
        """
        self.check_initialized()
        
        hdf_entries = self.plan_df[self.plan_df['HDF_Results_Path'].notna()].copy()
        
        if hdf_entries.empty:
            return pd.DataFrame(columns=self.plan_df.columns)
        
        return hdf_entries
    
    
    @log_call
    def print_data(self):
        """Print all RAS Object data for this instance."""
        self.check_initialized()
        logger.info(f"--- Data for {self.project_name} ---")
        logger.info(f"Project folder: {self.project_folder}")
        logger.info(f"PRJ file: {self.prj_file}")
        logger.info(f"HEC-RAS executable: {self.ras_exe_path}")
        logger.info("Plan files:")
        logger.info(f"\n{self.plan_df}")
        logger.info("Flow files:")
        logger.info(f"\n{self.flow_df}")
        logger.info("Unsteady flow files:")
        logger.info(f"\n{self.unsteady_df}")
        logger.info("Geometry files:")
        logger.info(f"\n{self.geom_df}")
        logger.info("HDF entries:")
        logger.info(f"\n{self.get_hdf_entries()}")
        logger.info("Boundary conditions:")
        logger.info(f"\n{self.boundaries_df}")
        logger.info("----------------------------")

    @staticmethod
    @log_call
    def get_plan_value(
        plan_number_or_path: Union[str, Path],
        key: str,
        ras_object=None
    ) -> Any:
        """
        Retrieve a specific value from a HEC-RAS plan file.

        Parameters:
        plan_number_or_path (Union[str, Path]): The plan number (1 to 99) or full path to the plan file
        key (str): The key to retrieve from the plan file
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.

        Returns:
        Any: The value associated with the specified key

        Raises:
        ValueError: If an invalid key is provided or if the plan file is not found
        IOError: If there's an error reading the plan file

        Note: See the docstring of update_plan_file for a full list of available keys and their types.

        Example:
        >>> computation_interval = RasUtils.get_plan_value("01", "computation_interval")
        >>> print(f"Computation interval: {computation_interval}")
        """
        logger = getLogger(__name__)
        ras_obj = ras_object or ras
        ras_obj.check_initialized()

        valid_keys = {
            'description', 'computation_interval', 'dss_file', 'flow_file', 'friction_slope_method',
            'geom_file', 'mapping_interval', 'plan_file', 'plan_title', 'program_version',
            'run_htab', 'run_post_process', 'run_sediment', 'run_unet', 'run_wqnet',
            'short_identifier', 'simulation_date', 'unet_d1_cores', 'unet_use_existing_ib_tables',
            'unet_1d_methodology', 'unet_d2_solver_type', 'unet_d2_name'
        }

        if key not in valid_keys:
            logger.error(f"Invalid key: {key}")
            raise ValueError(f"Invalid key: {key}. Valid keys are: {', '.join(valid_keys)}")

        plan_file_path = Path(plan_number_or_path)
        if not plan_file_path.is_file():
            plan_file_path = RasUtils.get_plan_path(plan_number_or_path, ras_object)
            if not plan_file_path.exists():
                logger.error(f"Plan file not found: {plan_file_path}")
                raise ValueError(f"Plan file not found: {plan_file_path}")

        try:
            with open(plan_file_path, 'r') as file:
                content = file.read()
        except IOError as e:
            logger.error(f"Error reading plan file {plan_file_path}: {e}")
            raise

        if key == 'description':
            import re
            match = re.search(r'Begin DESCRIPTION(.*?)END DESCRIPTION', content, re.DOTALL)
            return match.group(1).strip() if match else None
        else:
            pattern = f"{key.replace('_', ' ').title()}=(.*)"
            import re
            match = re.search(pattern, content)
            return match.group(1).strip() if match else None

    @log_call
    def get_boundary_conditions(self) -> pd.DataFrame:
        """
        Extract boundary conditions from unsteady flow files and create a DataFrame.

        This method parses unsteady flow files to extract boundary condition information.
        It creates a DataFrame with structured data for known boundary condition types
        and parameters, and associates this information with the corresponding unsteady flow file.

        Note:
        Any lines in the boundary condition blocks that are not explicitly parsed and
        incorporated into the DataFrame are captured in a multi-line string. This string
        is logged at the DEBUG level for each boundary condition. This feature is crucial
        for developers incorporating new boundary condition types or parameters, as it
        allows them to see what information might be missing from the current parsing logic.
        If no unsteady flow files are present, it returns an empty DataFrame.

        Returns:
            pd.DataFrame: A DataFrame containing detailed boundary condition information,
                                      linked to the unsteady flow files.

        Usage:
            To see the unparsed lines, set the logging level to DEBUG before calling this method:
            
            import logging
            getLogger().setLevel(logging.DEBUG)
            
            boundaries_df = ras_project.get_boundary_conditions()
                          linked to the unsteady flow files. Returns an empty DataFrame if
                          no unsteady flow files are present.
        """
        boundary_data = []
        
        # Check if unsteady_df is empty
        if self.unsteady_df.empty:
            logger.info("No unsteady flow files found in the project.")
            return pd.DataFrame()  # Return an empty DataFrame
        
        for _, row in self.unsteady_df.iterrows():
            unsteady_file_path = row['full_path']
            unsteady_number = row['unsteady_number']
            
            try:
                with open(unsteady_file_path, 'r') as file:
                    content = file.read()
            except IOError as e:
                logger.error(f"Error reading unsteady file {unsteady_file_path}: {e}")
                continue
                
            bc_blocks = re.split(r'(?=Boundary Location=)', content)[1:]
            
            for i, block in enumerate(bc_blocks, 1):
                bc_info, unparsed_lines = self._parse_boundary_condition(block, unsteady_number, i)
                boundary_data.append(bc_info)
                
                if unparsed_lines:
                    logger.debug(f"Unparsed lines for boundary condition {i} in unsteady file {unsteady_number}:\n{unparsed_lines}")
        
        if not boundary_data:
            logger.info("No boundary conditions found in unsteady flow files.")
            return pd.DataFrame()  # Return an empty DataFrame if no boundary conditions were found
        
        boundaries_df = pd.DataFrame(boundary_data)
        
        # Merge with unsteady_df to get relevant unsteady flow file information
        merged_df = pd.merge(boundaries_df, self.unsteady_df, 
                             left_on='unsteady_number', right_on='unsteady_number', how='left')
        
        return merged_df

    @log_call
    def _parse_boundary_condition(self, block: str, unsteady_number: str, bc_number: int) -> Tuple[Dict, str]:
        lines = block.split('\n')
        bc_info = {
            'unsteady_number': unsteady_number,
            'boundary_condition_number': bc_number
        }
        
        parsed_lines = set()
        
        # Parse Boundary Location
        boundary_location = lines[0].split('=')[1].strip()
        fields = [field.strip() for field in boundary_location.split(',')]
        bc_info.update({
            'river_reach_name': fields[0] if len(fields) > 0 else '',
            'river_station': fields[1] if len(fields) > 1 else '',
            'storage_area_name': fields[2] if len(fields) > 2 else '',
            'pump_station_name': fields[3] if len(fields) > 3 else ''
        })
        parsed_lines.add(0)
        
        # Determine BC Type
        bc_types = {
            'Flow Hydrograph=': 'Flow Hydrograph',
            'Lateral Inflow Hydrograph=': 'Lateral Inflow Hydrograph',
            'Uniform Lateral Inflow Hydrograph=': 'Uniform Lateral Inflow Hydrograph',
            'Stage Hydrograph=': 'Stage Hydrograph',
            'Friction Slope=': 'Normal Depth',
            'Gate Name=': 'Gate Opening'
        }
        
        bc_info['bc_type'] = 'Unknown'
        bc_info['hydrograph_type'] = None
        for i, line in enumerate(lines[1:], 1):
            for key, bc_type in bc_types.items():
                if line.startswith(key):
                    bc_info['bc_type'] = bc_type
                    if 'Hydrograph' in bc_type:
                        bc_info['hydrograph_type'] = bc_type
                    parsed_lines.add(i)
                    break
            if bc_info['bc_type'] != 'Unknown':
                break
        
        # Parse other fields
        known_fields = ['Interval', 'DSS Path', 'Use DSS', 'Use Fixed Start Time', 'Fixed Start Date/Time',
                        'Is Critical Boundary', 'Critical Boundary Flow', 'DSS File']
        for i, line in enumerate(lines):
            if '=' in line:
                key, value = line.split('=', 1)
                key = key.strip()
                if key in known_fields:
                    bc_info[key] = value.strip()
                    parsed_lines.add(i)
        
        # Handle hydrograph values
        bc_info['hydrograph_num_values'] = 0
        if bc_info['hydrograph_type']:
            hydrograph_key = f"{bc_info['hydrograph_type']}="
            hydrograph_line = next((line for i, line in enumerate(lines) if line.startswith(hydrograph_key)), None)
            if hydrograph_line:
                hydrograph_index = lines.index(hydrograph_line)
                values_count = int(hydrograph_line.split('=')[1].strip())
                bc_info['hydrograph_num_values'] = values_count
                if values_count > 0:
                    values = ' '.join(lines[hydrograph_index + 1:]).split()[:values_count]
                    bc_info['hydrograph_values'] = values
                    parsed_lines.update(range(hydrograph_index, hydrograph_index + (values_count // 5) + 2))
        
        # Collect unparsed lines
        unparsed_lines = '\n'.join(line for i, line in enumerate(lines) if i not in parsed_lines and line.strip())
        
        if unparsed_lines:
            logger.debug(f"Unparsed lines for boundary condition {bc_number} in unsteady file {unsteady_number}:\n{unparsed_lines}")
        
        return bc_info, unparsed_lines


# Create a global instance named 'ras'
# Defining the global instance allows the init_ras_project function to initialize the project.
# This only happens on the library initialization, not when the user calls init_ras_project.
ras = RasPrj()

# END OF CLASS DEFINITION


# START OF FUNCTION DEFINITIONS


@log_call
def init_ras_project(ras_project_folder, ras_version=None, ras_instance=None):
    """
    Initialize a RAS project.

    USE THIS FUNCTION TO INITIALIZE A RAS PROJECT, NOT THE INITIALIZE METHOD OF THE RasPrj CLASS.
    The initialize method of the RasPrj class only modifies the global 'ras' object.

    This function creates or initializes a RasPrj instance, providing a safer and more
    flexible interface than directly using the 'initialize' method.

    Parameters:
    -----------
    ras_project_folder : str
        The path to the RAS project folder.
    ras_version : str, optional
        The version of RAS to use (e.g., "6.6").
        The version can also be a full path to the Ras.exe file. (Useful when calling ras objects for folder copies.)
        If None, the function will attempt to use the version from the global 'ras' object or a default path.
        You MUST specify a version number via init at some point or ras will not run.  
        Once the ras_version is specified once it should auto-fill from the global 'ras' object.
        The RAS Commander Library Assistant can ignore this argument since it does not have Ras.exe present, but all of other operations are fully working.
    ras_instance : RasPrj, optional
        An instance of RasPrj to initialize. If None, the global 'ras' instance is used.

    Returns:
    --------
    RasPrj
        An initialized RasPrj instance.

    Usage:
    ------
    1. For general use with a single project:
        init_ras_project("/path/to/project")
        # Use the global 'ras' object after initialization

    2. For managing multiple projects:
        project1 = init_ras_project("/path/to/project1", "6.6", ras_instance=RasPrj())
        project2 = init_ras_project("/path/to/project2", ras_instance=RasPrj())

    Notes:
    ------
    - This function is preferred over directly calling the 'initialize' method.
    - It supports both the global 'ras' object and custom instances.
    - Be consistent in your approach: stick to either the global 'ras' object
      or custom instances throughout your script or application.
    - Document your choice of approach clearly in your code.
    - If ras_version is not provided, the function will attempt to use the version
      from the global 'ras' object or a default path.

    Warnings:
    ---------
    Avoid mixing use of the global 'ras' object and custom instances to prevent
    confusion and potential bugs.
    """
    if not Path(ras_project_folder).exists():
        logger.error(f"The specified RAS project folder does not exist: {ras_project_folder}")
        raise FileNotFoundError(f"The specified RAS project folder does not exist: {ras_project_folder}. Please check the path and try again.")

    ras_exe_path = get_ras_exe(ras_version)

    if ras_instance is None:
        logger.info("Initializing global 'ras' object via init_ras_project function.")
        ras_instance = ras
    elif not isinstance(ras_instance, RasPrj):
        logger.error("Provided ras_instance is not an instance of RasPrj.")
        raise TypeError("ras_instance must be an instance of RasPrj or None.")

    # Initialize the RasPrj instance
    ras_instance.initialize(ras_project_folder, ras_exe_path)
    
    logger.info(f"Project initialized. ras_instance project folder: {ras_instance.project_folder}")
    return ras_instance

@log_call
def get_ras_exe(ras_version=None):
    """
    Determine the HEC-RAS executable path based on the input.
    
    Args:
        ras_version (str, optional): Either a version number or a full path to the HEC-RAS executable.
                                     If None, the function will attempt to use the version from the global 'ras' object
                                     or a default path.
    
    Returns:
        str: The full path to the HEC-RAS executable.
    
    Raises:
        ValueError: If the input is neither a valid version number nor a valid file path.
    
    Notes:
        - If ras_version is not provided, the function will first check the global 'ras' object for a path.
        - If the global 'ras' object is not initialized or doesn't have a path, a default path will be used.
        - The default path allows the library to function in environments without HEC-RAS installed.
        - This enables the HEC-Commander GPT to operate without stopping, even if HEC-RAS is not present.
        - End users MUST use logging to check for operational errors, as full code stops prevent the GPT from running.
    """
    if ras_version is None:
        if hasattr(ras, 'ras_exe_path') and ras.ras_exe_path:
            logger.info(f"Using HEC-RAS executable from global 'ras' object: {ras.ras_exe_path}")
            return ras.ras_exe_path
        else:
            default_path = Path("Ras.exe")
            logger.warning(f"No HEC-RAS version specified and global 'ras' object not initialized or missing ras_exe_path. Using default path: {default_path}. The RAS Commander (ras-commander) Library Assistant can ignore this error since it does not have HEC-RAS installed.")
            return str(default_path)
    
    ras_version_numbers = [
        "6.6", "6.5", "6.4.1", "6.3.1", "6.3", "6.2", "6.1", "6.0",
        "5.0.7", "5.0.6", "5.0.5", "5.0.4", "5.0.3", "5.0.1", "5.0",
        "4.1", "4.0", "3.1.3", "3.1.2", "3.1.1", "3.0", "2.2"
    ]
    
    hecras_path = Path(ras_version)
    
    if hecras_path.is_file() and hecras_path.suffix.lower() == '.exe':
        logger.info(f"HEC-RAS executable found at specified path: {hecras_path}")
        return str(hecras_path)
    
    if ras_version in ras_version_numbers:
        default_path = Path(f"C:/Program Files (x86)/HEC/HEC-RAS/{ras_version}/Ras.exe")
        if default_path.is_file():
            logger.info(f"HEC-RAS executable found at default path: {default_path}")
            return str(default_path)
        else:
            logger.critical(f"HEC-RAS executable not found at the expected path: {default_path}")
    
    try:
        version_float = float(ras_version)
        if version_float > max(float(v) for v in ras_version_numbers):
            newer_version_path = Path(f"C:/Program Files (x86)/HEC/HEC-RAS/{ras_version}/Ras.exe")
            if newer_version_path.is_file():
                logger.info(f"Newer version of HEC-RAS executable found at: {newer_version_path}")
                return str(newer_version_path)
            else:
                logger.critical("Newer version of HEC-RAS was specified, but the executable was not found.")
    except ValueError:
        pass
    
    logger.error(f"Invalid HEC-RAS version or path: {ras_version}, returning default path: {default_path}")
    #raise ValueError(f"Invalid HEC-RAS version or path: {ras_version}") # don't raise an error here, just return the default path
    return str(default_path)
    

==================================================

File: c:\GH\ras-commander\ras_commander\RasUnsteady.py
==================================================
"""
RasUnsteady - Operations for handling unsteady flow files in HEC-RAS projects.

This module is part of the ras-commander library and uses a centralized logging configuration.

Logging Configuration:
- The logging is set up in the logging_config.py file.
- A @log_call decorator is available to automatically log function calls.
- Log levels: DEBUG, INFO, WARNING, ERROR, CRITICAL
- Logs are written to both console and a rotating file handler.
- The default log file is 'ras_commander.log' in the 'logs' directory.
- The default log level is INFO.

To use logging in this module:
1. Use the @log_call decorator for automatic function call logging.
2. For additional logging, use logger.[level]() calls (e.g., logger.info(), logger.debug()).


Example:
    @log_call
    def my_function():
        logger.debug("Additional debug information")
        # Function logic here
"""
import os
from pathlib import Path
from .RasPrj import ras
from .LoggingConfig import get_logger
from .Decorators import log_call

logger = get_logger(__name__)

# Module code starts here

class RasUnsteady:
    """
    Class for all operations related to HEC-RAS unsteady flow files.
    """
    
    @staticmethod
    @log_call
    def update_unsteady_parameters(unsteady_file, modifications, ras_object=None):
        """
        Modify parameters in an unsteady flow file.
        
        Parameters:
        unsteady_file (str): Full path to the unsteady flow file
        modifications (dict): Dictionary of modifications to apply, where keys are parameter names and values are new values
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
        
        Returns:
        None

        Note:
            This function updates the ras object's unsteady dataframe after modifying the unsteady flow file.
        
        Example:
            from ras_commander import RasCmdr
            
            # Initialize RAS project
            ras_cmdr = RasCmdr()
            ras_cmdr.init_ras_project(project_folder, ras_version)
            
            # Update unsteady parameters
            unsteady_file = r"path/to/unsteady_file.u01"
            modifications = {"Parameter1": "NewValue1", "Parameter2": "NewValue2"}
            RasUnsteady.update_unsteady_parameters(unsteady_file, modifications, ras_object=ras_cmdr.ras)
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()
        
        unsteady_path = Path(unsteady_file)
        try:
            with open(unsteady_path, 'r') as f:
                lines = f.readlines()
            logger.debug(f"Successfully read unsteady flow file: {unsteady_path}")
        except FileNotFoundError:
            logger.error(f"Unsteady flow file not found: {unsteady_path}")
            raise FileNotFoundError(f"Unsteady flow file not found: {unsteady_path}")
        except PermissionError:
            logger.error(f"Permission denied when reading unsteady flow file: {unsteady_path}")
            raise PermissionError(f"Permission denied when reading unsteady flow file: {unsteady_path}")
        
        updated = False
        for i, line in enumerate(lines):
            for param, new_value in modifications.items():
                if line.startswith(f"{param}="):
                    old_value = line.strip().split('=')[1]
                    lines[i] = f"{param}={new_value}\n"
                    updated = True
                    logger.info(f"Updated {param} from {old_value} to {new_value}")
        
        if updated:
            try:
                with open(unsteady_path, 'w') as f:
                    f.writelines(lines)
                logger.debug(f"Successfully wrote modifications to unsteady flow file: {unsteady_path}")
            except PermissionError:
                logger.error(f"Permission denied when writing to unsteady flow file: {unsteady_path}")
                raise PermissionError(f"Permission denied when writing to unsteady flow file: {unsteady_path}")
            except IOError as e:
                logger.error(f"Error writing to unsteady flow file: {unsteady_path}. {str(e)}")
                raise IOError(f"Error writing to unsteady flow file: {unsteady_path}. {str(e)}")
            logger.info(f"Applied modifications to {unsteady_file}")
        else:
            logger.warning(f"No matching parameters found in {unsteady_file}")
    
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()

==================================================

File: c:\GH\ras-commander\ras_commander\RasUtils.py
==================================================
"""
RasUtils - Utility functions for the ras-commander library

This module is part of the ras-commander library and uses a centralized logging configuration.

Logging Configuration:
- The logging is set up in the logging_config.py file.
- A @log_call decorator is available to automatically log function calls.
- Log levels: DEBUG, INFO, WARNING, ERROR, CRITICAL
- Logs are written to both console and a rotating file handler.
- The default log file is 'ras_commander.log' in the 'logs' directory.
- The default log level is INFO.

To use logging in this module:
1. Use the @log_call decorator for automatic function call logging.
2. For additional logging, use logger.[level]() calls (e.g., logger.info(), logger.debug()).

Example:
    @log_call
    def my_function():
        logger.debug("Additional debug information")
        # Function logic here
"""
import os
from pathlib import Path
from .RasPrj import ras
from typing import Union, Optional, Dict, Callable, List, Tuple, Any
import pandas as pd
import numpy as np
import shutil
import re
from scipy.spatial import KDTree
import datetime
import time
import h5py
from datetime import timedelta
from .LoggingConfig import get_logger
from .Decorators import log_call


logger = get_logger(__name__)
# Module code starts here

class RasUtils:
    """
    A class containing utility functions for the ras-commander library.
    When integrating new functions that do not clearly fit into other classes, add them here.
    """

    @staticmethod
    @log_call
    def create_directory(directory_path: Path, ras_object=None) -> Path:
        """
        Ensure that a directory exists, creating it if necessary.

        Parameters:
        directory_path (Path): Path to the directory
        ras_object (RasPrj, optional): RAS object to use. If None, uses the default ras object.

        Returns:
        Path: Path to the ensured directory

        Example:
        >>> ensured_dir = RasUtils.create_directory(Path("output"))
        >>> print(f"Directory ensured: {ensured_dir}")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        path = Path(directory_path)
        try:
            path.mkdir(parents=True, exist_ok=True)
            logger.info(f"Directory ensured: {path}")
        except Exception as e:
            logger.error(f"Failed to create directory {path}: {e}")
            raise
        return path

    @staticmethod
    @log_call
    def find_files_by_extension(extension: str, ras_object=None) -> list:
        """
        List all files in the project directory with a specific extension.

        Parameters:
        extension (str): File extension to filter (e.g., '.prj')
        ras_object (RasPrj, optional): RAS object to use. If None, uses the default ras object.

        Returns:
        list: List of file paths matching the extension

        Example:
        >>> prj_files = RasUtils.find_files_by_extension('.prj')
        >>> print(f"Found {len(prj_files)} .prj files")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        try:
            files = list(ras_obj.project_folder.glob(f"*{extension}"))
            file_list = [str(file) for file in files]
            logger.info(f"Found {len(file_list)} files with extension '{extension}' in {ras_obj.project_folder}")
            return file_list
        except Exception as e:
            logger.error(f"Failed to find files with extension '{extension}': {e}")
            raise

    @staticmethod
    @log_call
    def get_file_size(file_path: Path, ras_object=None) -> Optional[int]:
        """
        Get the size of a file in bytes.

        Parameters:
        file_path (Path): Path to the file
        ras_object (RasPrj, optional): RAS object to use. If None, uses the default ras object.

        Returns:
        Optional[int]: Size of the file in bytes, or None if the file does not exist

        Example:
        >>> size = RasUtils.get_file_size(Path("project.prj"))
        >>> print(f"File size: {size} bytes")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        path = Path(file_path)
        if path.exists():
            try:
                size = path.stat().st_size
                logger.info(f"Size of {path}: {size} bytes")
                return size
            except Exception as e:
                logger.error(f"Failed to get size for {path}: {e}")
                raise
        else:
            logger.warning(f"File not found: {path}")
            return None

    @staticmethod
    @log_call
    def get_file_modification_time(file_path: Path, ras_object=None) -> Optional[float]:
        """
        Get the last modification time of a file.

        Parameters:
        file_path (Path): Path to the file
        ras_object (RasPrj, optional): RAS object to use. If None, uses the default ras object.

        Returns:
        Optional[float]: Last modification time as a timestamp, or None if the file does not exist

        Example:
        >>> mtime = RasUtils.get_file_modification_time(Path("project.prj"))
        >>> print(f"Last modified: {mtime}")
        """
        
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        path = Path(file_path)
        if path.exists():
            try:
                mtime = path.stat().st_mtime
                logger.info(f"Last modification time of {path}: {mtime}")
                return mtime
            except Exception as e:
                logger.exception(f"Failed to get modification time for {path}")
                raise
        else:
            logger.warning(f"File not found: {path}")
            return None

    @staticmethod
    @log_call
    def get_plan_path(current_plan_number_or_path: Union[str, Path], ras_object=None) -> Path:
        """
        Get the path for a plan file with a given plan number or path.

        Parameters:
        current_plan_number_or_path (Union[str, Path]): The plan number (1 to 99) or full path to the plan file
        ras_object (RasPrj, optional): RAS object to use. If None, uses the default ras object.

        Returns:
        Path: Full path to the plan file

        Example:
        >>> plan_path = RasUtils.get_plan_path(1)
        >>> print(f"Plan file path: {plan_path}")
        >>> plan_path = RasUtils.get_plan_path("path/to/plan.p01")
        >>> print(f"Plan file path: {plan_path}")
        """
        
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        plan_path = Path(current_plan_number_or_path)
        if plan_path.is_file():
            logger.info(f"Using provided plan file path: {plan_path}")
            return plan_path
        
        try:
            current_plan_number = f"{int(current_plan_number_or_path):02d}"  # Ensure two-digit format
            logger.debug(f"Converted plan number to two-digit format: {current_plan_number}")
        except ValueError:
            logger.error(f"Invalid plan number: {current_plan_number_or_path}. Expected a number from 1 to 99.")
            raise ValueError(f"Invalid plan number: {current_plan_number_or_path}. Expected a number from 1 to 99.")
        
        plan_name = f"{ras_obj.project_name}.p{current_plan_number}"
        full_plan_path = ras_obj.project_folder / plan_name
        logger.info(f"Constructed plan file path: {full_plan_path}")
        return full_plan_path

    @staticmethod
    @log_call
    def remove_with_retry(
        path: Path,
        max_attempts: int = 5,
        initial_delay: float = 1.0,
        is_folder: bool = True,
        ras_object=None
    ) -> bool:
        """
        Attempts to remove a file or folder with retry logic and exponential backoff.

        Parameters:
        path (Path): Path to the file or folder to be removed.
        max_attempts (int): Maximum number of removal attempts.
        initial_delay (float): Initial delay between attempts in seconds.
        is_folder (bool): If True, the path is treated as a folder; if False, it's treated as a file.
        ras_object (RasPrj, optional): RAS object to use. If None, uses the default ras object.

        Returns:
        bool: True if the file or folder was successfully removed, False otherwise.

        Example:
        >>> success = RasUtils.remove_with_retry(Path("temp_folder"), is_folder=True)
        >>> print(f"Removal successful: {success}")
        """
        
        ras_obj = ras_object or ras
        ras_obj.check_initialized()

        path = Path(path)
        for attempt in range(1, max_attempts + 1):
            try:
                if path.exists():
                    if is_folder:
                        shutil.rmtree(path)
                        logger.info(f"Folder removed: {path}")
                    else:
                        path.unlink()
                        logger.info(f"File removed: {path}")
                else:
                    logger.info(f"Path does not exist, nothing to remove: {path}")
                return True
            except PermissionError as pe:
                if attempt < max_attempts:
                    delay = initial_delay * (2 ** (attempt - 1))  # Exponential backoff
                    logger.warning(
                        f"PermissionError on attempt {attempt} to remove {path}: {pe}. "
                        f"Retrying in {delay} seconds..."
                    )
                    time.sleep(delay)
                else:
                    logger.error(
                        f"Failed to remove {path} after {max_attempts} attempts due to PermissionError: {pe}. Skipping."
                    )
                    return False
            except Exception as e:
                logger.exception(f"Failed to remove {path} on attempt {attempt}")
                return False
        return False

    @staticmethod
    @log_call
    def update_plan_file(
        plan_number_or_path: Union[str, Path],
        file_type: str,
        entry_number: int,
        ras_object=None
    ) -> None:
        """
        Update a plan file with a new file reference.

        Parameters:
        plan_number_or_path (Union[str, Path]): The plan number (1 to 99) or full path to the plan file
        file_type (str): Type of file to update ('Geom', 'Flow', or 'Unsteady')
        entry_number (int): Number (from 1 to 99) to set
        ras_object (RasPrj, optional): RAS object to use. If None, uses the default ras object.

        Raises:
        ValueError: If an invalid file_type is provided
        FileNotFoundError: If the plan file doesn't exist

        Example:
        >>> RasUtils.update_plan_file(1, "Geom", 2)
        >>> RasUtils.update_plan_file("path/to/plan.p01", "Geom", 2)
        """
        
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        valid_file_types = {'Geom': 'g', 'Flow': 'f', 'Unsteady': 'u'}
        if file_type not in valid_file_types:
            logger.error(
                f"Invalid file_type '{file_type}'. Expected one of: {', '.join(valid_file_types.keys())}"
            )
            raise ValueError(
                f"Invalid file_type. Expected one of: {', '.join(valid_file_types.keys())}"
            )

        plan_file_path = Path(plan_number_or_path)
        if not plan_file_path.is_file():
            plan_file_path = RasUtils.get_plan_path(plan_number_or_path, ras_object)
            if not plan_file_path.exists():
                logger.error(f"Plan file not found: {plan_file_path}")
                raise FileNotFoundError(f"Plan file not found: {plan_file_path}")
        
        file_prefix = valid_file_types[file_type]
        search_pattern = f"{file_type} File="
        formatted_entry_number = f"{int(entry_number):02d}"  # Ensure two-digit format

        try:
            RasUtils.check_file_access(plan_file_path, 'r')
            with plan_file_path.open('r') as file:
                lines = file.readlines()
        except Exception as e:
            logger.exception(f"Failed to read plan file {plan_file_path}")
            raise

        updated = False
        for i, line in enumerate(lines):
            if line.startswith(search_pattern):
                lines[i] = f"{search_pattern}{file_prefix}{formatted_entry_number}\n"
                logger.info(
                    f"Updated {file_type} File in {plan_file_path} to {file_prefix}{formatted_entry_number}"
                )
                updated = True
                break

        if not updated:
            logger.warning(
                f"Search pattern '{search_pattern}' not found in {plan_file_path}. No update performed."
            )

        try:
            with plan_file_path.open('w') as file:
                file.writelines(lines)
            logger.info(f"Successfully updated plan file: {plan_file_path}")
        except Exception as e:
            logger.exception(f"Failed to write updates to plan file {plan_file_path}")
            raise

        # Refresh RasPrj dataframes
        try:
            ras_obj.plan_df = ras_obj.get_plan_entries()
            ras_obj.geom_df = ras_obj.get_geom_entries()
            ras_obj.flow_df = ras_obj.get_flow_entries()
            ras_obj.unsteady_df = ras_obj.get_unsteady_entries()
            logger.info("RAS object dataframes have been refreshed.")
        except Exception as e:
            logger.exception("Failed to refresh RasPrj dataframes")
            raise

    @staticmethod
    @log_call
    def check_file_access(file_path: Path, mode: str = 'r') -> None:
        """
        Check if the file can be accessed with the specified mode.

        Parameters:
        file_path (Path): Path to the file
        mode (str): Mode to check ('r' for read, 'w' for write, etc.)

        Raises:
        FileNotFoundError: If the file does not exist
        PermissionError: If the required permissions are not met
        """
        
        path = Path(file_path)
        if not path.exists():
            logger.error(f"File not found: {file_path}")
            raise FileNotFoundError(f"File not found: {file_path}")
        
        if mode in ('r', 'rb'):
            if not os.access(path, os.R_OK):
                logger.error(f"Read permission denied for file: {file_path}")
                raise PermissionError(f"Read permission denied for file: {file_path}")
            else:
                logger.debug(f"Read access granted for file: {file_path}")
        
        if mode in ('w', 'wb', 'a', 'ab'):
            parent_dir = path.parent
            if not os.access(parent_dir, os.W_OK):
                logger.error(f"Write permission denied for directory: {parent_dir}")
                raise PermissionError(f"Write permission denied for directory: {parent_dir}")
            else:
                logger.debug(f"Write access granted for directory: {parent_dir}")


    @staticmethod
    @log_call
    def convert_to_dataframe(data_source: Union[pd.DataFrame, Path], **kwargs) -> pd.DataFrame:
        """
        Converts input to a pandas DataFrame. Supports existing DataFrames or file paths (CSV, Excel, TSV, Parquet).

        Args:
            data_source (Union[pd.DataFrame, Path]): The input to convert to a DataFrame. Can be a file path or an existing DataFrame.
            **kwargs: Additional keyword arguments to pass to pandas read functions.

        Returns:
            pd.DataFrame: The resulting DataFrame.

        Raises:
            NotImplementedError: If the file type is unsupported or input type is invalid.

        Example:
            >>> df = RasUtils.convert_to_dataframe(Path("data.csv"))
            >>> print(type(df))
            <class 'pandas.core.frame.DataFrame'>
        """
        if isinstance(data_source, pd.DataFrame):
            logger.debug("Input is already a DataFrame, returning a copy.")
            return data_source.copy()
        elif isinstance(data_source, Path):
            ext = data_source.suffix.replace('.', '', 1)
            logger.info(f"Converting file with extension '{ext}' to DataFrame.")
            if ext == 'csv':
                return pd.read_csv(data_source, **kwargs)
            elif ext.startswith('x'):
                return pd.read_excel(data_source, **kwargs)
            elif ext == "tsv":
                return pd.read_csv(data_source, sep="\t", **kwargs)
            elif ext in ["parquet", "pq", "parq"]:
                return pd.read_parquet(data_source, **kwargs)
            else:
                logger.error(f"Unsupported file type: {ext}")
                raise NotImplementedError(f"Unsupported file type {ext}. Should be one of csv, tsv, parquet, or xlsx.")
        else:
            logger.error(f"Unsupported input type: {type(data_source)}")
            raise NotImplementedError(f"Unsupported type {type(data_source)}. Only file path / existing DataFrame supported at this time")

    @staticmethod
    @log_call
    def save_to_excel(dataframe: pd.DataFrame, excel_path: Path, **kwargs) -> None:
        """
        Saves a pandas DataFrame to an Excel file with retry functionality.

        Args:
            dataframe (pd.DataFrame): The DataFrame to save.
            excel_path (Path): The path to the Excel file where the DataFrame will be saved.
            **kwargs: Additional keyword arguments passed to `DataFrame.to_excel()`.

        Raises:
            IOError: If the file cannot be saved after multiple attempts.

        Example:
            >>> df = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})
            >>> RasUtils.save_to_excel(df, Path('output.xlsx'))
        """
        saved = False
        max_attempts = 3
        attempt = 0

        while not saved and attempt < max_attempts:
            try:
                dataframe.to_excel(excel_path, **kwargs)
                logger.info(f'DataFrame successfully saved to {excel_path}')
                saved = True
            except IOError as e:
                attempt += 1
                if attempt < max_attempts:
                    logger.warning(f"Error saving file. Attempt {attempt} of {max_attempts}. Please close the Excel document if it's open.")
                else:
                    logger.error(f"Failed to save {excel_path} after {max_attempts} attempts.")
                    raise IOError(f"Failed to save {excel_path} after {max_attempts} attempts. Last error: {str(e)}")

    @staticmethod
    @log_call
    def calculate_rmse(observed_values: np.ndarray, predicted_values: np.ndarray, normalized: bool = True) -> float:
        """
        Calculate the Root Mean Squared Error (RMSE) between observed and predicted values.

        Args:
            observed_values (np.ndarray): Actual observations time series.
            predicted_values (np.ndarray): Estimated/predicted time series.
            normalized (bool, optional): Whether to normalize RMSE to a percentage of observed_values. Defaults to True.

        Returns:
            float: The calculated RMSE value.

        Example:
            >>> observed = np.array([1, 2, 3])
            >>> predicted = np.array([1.1, 2.2, 2.9])
            >>> RasUtils.calculate_rmse(observed, predicted)
            0.06396394
        """
        rmse = np.sqrt(np.mean((predicted_values - observed_values) ** 2))
        
        if normalized:
            rmse = rmse / np.abs(np.mean(observed_values))
        
        logger.debug(f"Calculated RMSE: {rmse}")
        return rmse

    @staticmethod
    @log_call
    def calculate_percent_bias(observed_values: np.ndarray, predicted_values: np.ndarray, as_percentage: bool = False) -> float:
        """
        Calculate the Percent Bias between observed and predicted values.

        Args:
            observed_values (np.ndarray): Actual observations time series.
            predicted_values (np.ndarray): Estimated/predicted time series.
            as_percentage (bool, optional): If True, return bias as a percentage. Defaults to False.

        Returns:
            float: The calculated Percent Bias.

        Example:
            >>> observed = np.array([1, 2, 3])
            >>> predicted = np.array([1.1, 2.2, 2.9])
            >>> RasUtils.calculate_percent_bias(observed, predicted, as_percentage=True)
            3.33333333
        """
        multiplier = 100 if as_percentage else 1
        
        percent_bias = multiplier * (np.mean(predicted_values) - np.mean(observed_values)) / np.mean(observed_values)
        
        logger.debug(f"Calculated Percent Bias: {percent_bias}")
        return percent_bias

    @staticmethod
    @log_call
    def calculate_error_metrics(observed_values: np.ndarray, predicted_values: np.ndarray) -> Dict[str, float]:
        """
        Compute a trio of error metrics: correlation, RMSE, and Percent Bias.

        Args:
            observed_values (np.ndarray): Actual observations time series.
            predicted_values (np.ndarray): Estimated/predicted time series.

        Returns:
            Dict[str, float]: A dictionary containing correlation ('cor'), RMSE ('rmse'), and Percent Bias ('pb').

        Example:
            >>> observed = np.array([1, 2, 3])
            >>> predicted = np.array([1.1, 2.2, 2.9])
            >>> RasUtils.calculate_error_metrics(observed, predicted)
            {'cor': 0.9993, 'rmse': 0.06396, 'pb': 0.03333}
        """
        correlation = np.corrcoef(observed_values, predicted_values)[0, 1]
        rmse = RasUtils.calculate_rmse(observed_values, predicted_values)
        percent_bias = RasUtils.calculate_percent_bias(observed_values, predicted_values)
        
        metrics = {'cor': correlation, 'rmse': rmse, 'pb': percent_bias}
        logger.info(f"Calculated error metrics: {metrics}")
        return metrics

    
    @staticmethod
    @log_call
    def update_file(file_path: Path, update_function: Callable, *args) -> None:
        """
        Generic method to update a file.

        Parameters:
        file_path (Path): Path to the file to be updated
        update_function (Callable): Function to update the file contents
        *args: Additional arguments to pass to the update_function

        Raises:
        Exception: If there's an error updating the file

        Example:
        >>> def update_content(lines, new_value):
        ...     lines[0] = f"New value: {new_value}\\n"
        ...     return lines
        >>> RasUtils.update_file(Path("example.txt"), update_content, "Hello")
        """
        try:
            with open(file_path, 'r') as f:
                lines = f.readlines()
            
            updated_lines = update_function(lines, *args) if args else update_function(lines)
            
            with open(file_path, 'w') as f:
                f.writelines(updated_lines)
            logger.info(f"Successfully updated file: {file_path}")
        except Exception as e:
            logger.exception(f"Failed to update file {file_path}")
            raise

    @staticmethod
    @log_call
    def get_next_number(existing_numbers: list) -> str:
        """
        Determine the next available number from a list of existing numbers.

        Parameters:
        existing_numbers (list): List of existing numbers as strings

        Returns:
        str: Next available number as a zero-padded string

        Example:
        >>> RasUtils.get_next_number(["01", "02", "04"])
        "05"
        """
        existing_numbers = sorted(int(num) for num in existing_numbers)
        next_number = max(existing_numbers, default=0) + 1
        return f"{next_number:02d}"

    @staticmethod
    @log_call
    def clone_file(template_path: Path, new_path: Path, update_function: Optional[Callable] = None, *args) -> None:
        """
        Generic method to clone a file and optionally update it.

        Parameters:
        template_path (Path): Path to the template file
        new_path (Path): Path where the new file will be created
        update_function (Optional[Callable]): Function to update the cloned file
        *args: Additional arguments to pass to the update_function

        Raises:
        FileNotFoundError: If the template file doesn't exist

        Example:
        >>> def update_content(lines, new_value):
        ...     lines[0] = f"New value: {new_value}\\n"
        ...     return lines
        >>> RasUtils.clone_file(Path("template.txt"), Path("new.txt"), update_content, "Hello")
        """
        if not template_path.exists():
            logger.error(f"Template file '{template_path}' does not exist.")
            raise FileNotFoundError(f"Template file '{template_path}' does not exist.")

        shutil.copy(template_path, new_path)
        logger.info(f"File cloned from {template_path} to {new_path}")

        if update_function:
            RasUtils.update_file(new_path, update_function, *args)
    @staticmethod
    @log_call
    def update_project_file(prj_file: Path, file_type: str, new_num: str, ras_object=None) -> None:
        """
        Update the project file with a new entry.

        Parameters:
        prj_file (Path): Path to the project file
        file_type (str): Type of file being added (e.g., 'Plan', 'Geom')
        new_num (str): Number of the new file entry
        ras_object (RasPrj, optional): RAS object to use. If None, uses the default ras object.

        Example:
        >>> RasUtils.update_project_file(Path("project.prj"), "Plan", "02")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        try:
            with open(prj_file, 'r') as f:
                lines = f.readlines()
            
            new_line = f"{file_type} File={file_type[0].lower()}{new_num}\n"
            lines.append(new_line)
            
            with open(prj_file, 'w') as f:
                f.writelines(lines)
            logger.info(f"Project file updated with new {file_type} entry: {new_num}")
        except Exception as e:
            logger.exception(f"Failed to update project file {prj_file}")
            raise
        
  
        
        
    # From FunkShuns
        
    @staticmethod
    @log_call
    def decode_byte_strings(dataframe: pd.DataFrame) -> pd.DataFrame:
        """
        Decodes byte strings in a DataFrame to regular string objects.

        This function converts columns with byte-encoded strings (e.g., b'string') into UTF-8 decoded strings.

        Args:
            dataframe (pd.DataFrame): The DataFrame containing byte-encoded string columns.

        Returns:
            pd.DataFrame: The DataFrame with byte strings decoded to regular strings.

        Example:
            >>> df = pd.DataFrame({'A': [b'hello', b'world'], 'B': [1, 2]})
            >>> decoded_df = RasUtils.decode_byte_strings(df)
            >>> print(decoded_df)
                A  B
            0  hello  1
            1  world  2
        """
        str_df = dataframe.select_dtypes(['object'])
        str_df = str_df.stack().str.decode('utf-8').unstack()
        for col in str_df:
            dataframe[col] = str_df[col]
        return dataframe

    @staticmethod
    @log_call
    def perform_kdtree_query(
        reference_points: np.ndarray,
        query_points: np.ndarray,
        max_distance: float = 2.0
    ) -> np.ndarray:
        """
        Performs a KDTree query between two datasets and returns indices with distances exceeding max_distance set to -1.

        Args:
            reference_points (np.ndarray): The reference dataset for KDTree.
            query_points (np.ndarray): The query dataset to search against KDTree of reference_points.
            max_distance (float, optional): The maximum distance threshold. Indices with distances greater than this are set to -1. Defaults to 2.0.

        Returns:
            np.ndarray: Array of indices from reference_points that are nearest to each point in query_points. 
                        Indices with distances > max_distance are set to -1.

        Example:
            >>> ref_points = np.array([[0, 0], [1, 1], [2, 2]])
            >>> query_points = np.array([[0.5, 0.5], [3, 3]])
            >>> result = RasUtils.perform_kdtree_query(ref_points, query_points)
            >>> print(result)
            array([ 0, -1])
        """
        dist, snap = KDTree(reference_points).query(query_points, distance_upper_bound=max_distance)
        snap[dist > max_distance] = -1
        return snap

    @staticmethod
    @log_call
    def find_nearest_neighbors(points: np.ndarray, max_distance: float = 2.0) -> np.ndarray:
        """
        Creates a self KDTree for dataset points and finds nearest neighbors excluding self, 
        with distances above max_distance set to -1.

        Args:
            points (np.ndarray): The dataset to build the KDTree from and query against itself.
            max_distance (float, optional): The maximum distance threshold. Indices with distances 
                                            greater than max_distance are set to -1. Defaults to 2.0.

        Returns:
            np.ndarray: Array of indices representing the nearest neighbor in points for each point in points. 
                        Indices with distances > max_distance or self-matches are set to -1.

        Example:
            >>> points = np.array([[0, 0], [1, 1], [2, 2], [10, 10]])
            >>> result = RasUtils.find_nearest_neighbors(points)
            >>> print(result)
            array([1, 0, 1, -1])
        """
        dist, snap = KDTree(points).query(points, k=2, distance_upper_bound=max_distance)
        snap[dist > max_distance] = -1
        
        snp = pd.DataFrame(snap, index=np.arange(len(snap)))
        snp = snp.replace(-1, np.nan)
        snp.loc[snp[0] == snp.index, 0] = np.nan
        snp.loc[snp[1] == snp.index, 1] = np.nan
        filled = snp[0].fillna(snp[1])
        snapped = filled.fillna(-1).astype(np.int64).to_numpy()
        return snapped

    @staticmethod
    @log_call
    def consolidate_dataframe(
        dataframe: pd.DataFrame,
        group_by: Optional[Union[str, List[str]]] = None,
        pivot_columns: Optional[Union[str, List[str]]] = None,
        level: Optional[int] = None,
        n_dimensional: bool = False,
        aggregation_method: Union[str, Callable] = 'list'
    ) -> pd.DataFrame:
        """
        Consolidate rows in a DataFrame by merging duplicate values into lists or using a specified aggregation function.

        Args:
            dataframe (pd.DataFrame): The DataFrame to consolidate.
            group_by (Optional[Union[str, List[str]]]): Columns or indices to group by.
            pivot_columns (Optional[Union[str, List[str]]]): Columns to pivot.
            level (Optional[int]): Level of multi-index to group by.
            n_dimensional (bool): If True, use a pivot table for N-Dimensional consolidation.
            aggregation_method (Union[str, Callable]): Aggregation method, e.g., 'list' to aggregate into lists.

        Returns:
            pd.DataFrame: The consolidated DataFrame.

        Example:
            >>> df = pd.DataFrame({'A': [1, 1, 2], 'B': [4, 5, 6], 'C': [7, 8, 9]})
            >>> result = RasUtils.consolidate_dataframe(df, group_by='A')
            >>> print(result)
            B         C
            A            
            1  [4, 5]  [7, 8]
            2  [6]     [9]
        """
        if aggregation_method == 'list':
            agg_func = lambda x: tuple(x)
        else:
            agg_func = aggregation_method

        if n_dimensional:
            result = dataframe.pivot_table(group_by, pivot_columns, aggfunc=agg_func)
        else:
            result = dataframe.groupby(group_by, level=level).agg(agg_func).applymap(list)

        return result

    @staticmethod
    @log_call
    def find_nearest_value(array: Union[list, np.ndarray], target_value: Union[int, float]) -> Union[int, float]:
        """
        Finds the nearest value in a NumPy array to the specified target value.

        Args:
            array (Union[list, np.ndarray]): The array to search within.
            target_value (Union[int, float]): The value to find the nearest neighbor to.

        Returns:
            Union[int, float]: The nearest value in the array to the specified target value.

        Example:
            >>> arr = np.array([1, 3, 5, 7, 9])
            >>> result = RasUtils.find_nearest_value(arr, 6)
            >>> print(result)
            5
        """
        array = np.asarray(array)
        idx = (np.abs(array - target_value)).argmin()
        return array[idx]
    
    @classmethod
    @log_call
    def horizontal_distance(cls, coord1: np.ndarray, coord2: np.ndarray) -> float:
        """
        Calculate the horizontal distance between two coordinate points.
        
        Args:
            coord1 (np.ndarray): First coordinate point [X, Y].
            coord2 (np.ndarray): Second coordinate point [X, Y].
        
        Returns:
            float: Horizontal distance.
        
        Example:
            >>> distance = RasUtils.horizontal_distance(np.array([0, 0]), np.array([3, 4]))
            >>> print(distance)
            5.0
        """
        return np.linalg.norm(coord2 - coord1)
    
    
    
    
    
==================================================

File: c:\GH\ras-commander\ras_commander\__init__.py
==================================================
from importlib.metadata import version, PackageNotFoundError
from .LoggingConfig import setup_logging, get_logger
from .Decorators import log_call, standardize_input

try:
    __version__ = version("ras-commander")
except PackageNotFoundError:
    # package is not installed
    __version__ = "unknown"

# Set up logging
setup_logging()

# Import all necessary functions and classes directly
from .RasPrj import RasPrj, init_ras_project, get_ras_exe, ras
from .RasPlan import RasPlan
from .RasGeo import RasGeo
from .RasUnsteady import RasUnsteady
from .RasUtils import RasUtils
from .RasExamples import RasExamples
from .RasCmdr import RasCmdr
from .RasGpt import RasGpt

# Import the Hdf* classes
from .HdfBase import HdfBase
from .HdfBndry import HdfBndry
from .HdfMesh import HdfMesh
from .HdfPlan import HdfPlan
from .HdfResultsMesh import HdfResultsMesh
from .HdfResultsPlan import HdfResultsPlan
from .HdfResultsXsec import HdfResultsXsec
from .HdfStruc import HdfStruc
from .HdfUtils import HdfUtils
from .HdfXsec import HdfXsec

# Define __all__ to specify what should be imported when using "from ras_commander import *"
__all__ = [
    "HdfBase",
    "HdfBndry",
    "HdfMesh",
    "HdfPlan",
    "HdfResultsMesh",
    "HdfResultsPlan",
    "HdfResultsXsec",
    "HdfStruc",
    "HdfUtils",
    "HdfXsec",
    "standardize_input",
    "ras",
    "init_ras_project",
    "get_ras_exe",
    "RasPrj",
    "RasPlan",
    "RasGeo",
    "RasUnsteady",
    "RasCmdr",
    "RasUtils",
    "RasExamples",
    "get_logger",
    "log_call",
]

__version__ = "0.1.0"

==================================================

