File: c:\GH\ras-commander\.cursorrules
==================================================
# RAS Commander (ras-commander) Coding Assistant

## Overview

This Coding Assistant helps you write efficient and well-structured Python code for working with HEC-RAS projects using the RAS Commander (ras-commander) library.

**Key Features:**

* **Automates HEC-RAS tasks:** Streamlines project setup, plan execution, data management, and more.
* **Pythonic interface:** Leverages familiar Python libraries like pandas and pathlib for intuitive coding.
* **Flexible execution:** Supports single plan, sequential, and parallel execution modes.
* **Built-in examples:** Provides access to HEC-RAS example projects for learning and testing.

**Core Concepts:**

* **RAS Objects:** Represent HEC-RAS projects and their components (plans, geometry, flow files).
* **Project Initialization:** Use `init_ras_project()` to set up a project, choosing between global and custom instances.
* **File Handling:** pathlib.Path ensures consistent file path management across operating systems.
* **Data Management:** Pandas DataFrames organize project data for efficient manipulation.
* **Execution Modes:** Choose from single, sequential, or parallel execution based on project needs.
* **Utility Functions:** RasUtils provides common file operations and project management tasks.

## Classes, Functions and Arguments for ras_commander

Class/Function | Required Arguments | Optional Arguments
---------------|--------------------|--------------------|
RasPrj | | |
init_ras_project | ras_project_folder, ras_version | ras_instance
get_ras_exe | ras_version | - |
RasPlan | | |
set_geom | plan_number, new_geom | ras_object |
set_steady | plan_number, new_steady_flow_number | ras_object |
set_unsteady | plan_number, new_unsteady_flow_number | ras_object |
set_num_cores | plan_number, num_cores | ras_object |
clone_plan | template_plan | new_plan_shortid, ras_object |
RasGeo | | |
clear_geompre_files | | plan_files, ras_object |
RasUnsteady | | |
update_unsteady_parameters | unsteady_file, modifications | ras_object |
RasCmdr | | |
compute_plan | plan_number | dest_folder, ras_object, clear_geompre, num_cores, overwrite_dest |
compute_parallel | | plan_number, max_workers, num_cores, ras_object, dest_folder, overwrite_dest |
compute_test_mode | | plan_number, dest_folder_suffix, clear_geompre, num_cores, ras_object, overwrite_dest |
RasUtils | | |
create_backup | file_path | backup_suffix, ras_object |
restore_from_backup | backup_path | remove_backup, ras_object |
update_plan_file | plan_number_or_path, file_type, entry_number | ras_object |
RasExamples | | |
extract_project | project_names | - |

## Coding Assistance Rules:

Your role is building, refactoring and debugging Python scripts using Python 3.9+, focusing on automation tasks for HEC-RAS projects.

1. Prefer default libraries where possible, especially pathlib for file operations.
2. Use r-strings for file and directory path inputs.
3. Use f-strings for string formatting and concatenation.
4. Always use pathlib over os for manipulation of file and directory paths.
5. Print DataFrame names and variable names before displaying DataFrames.
6. Prefer pandas for data manipulation and analysis tasks.
7. Use matplotlib or bokeh for visualization when needed.
8. Always include comments for code readability and explain complex operations.
9. Use logging for informative output and debugging information.
10. Follow PEP 8 conventions for code style.
11. Provide clear error handling and user feedback.
12. When using RAS Commander functions, explain their purpose and key arguments.
13. Encourage consistent use of either global 'ras' object or custom instances throughout scripts.
14. Highlight best practices for parallel execution and performance optimization.
15. Suggest using RasExamples for testing and learning purposes when appropriate.

When revising code, write planning steps as comments before implementation, labeled as:
## Explicit Planning and Reasoning for Revisions

For geodataframes, use the 'union_all()' method instead of the deprecated 'unary_union' attribute.

Note for pandas >= 2.0: Use pd.concat instead of the removed append method.

Always provide full code segments with no elides.

==================================================

Folder: c:\GH\ras-commander\.eggs
==================================================

Folder: c:\GH\ras-commander\.gitignore
==================================================

Folder: c:\GH\ras-commander\ai_tools
==================================================

File: c:\GH\ras-commander\Comprehensive_Library_Guide.md
==================================================
# Comprehensive RAS-Commander Library Guide

## Introduction

RAS-Commander (`ras_commander`) is a Python library designed to automate and streamline operations with HEC-RAS projects. It provides a suite of tools for managing projects, executing simulations, and handling results. This guide offers a comprehensive overview of the library's key concepts, modules, best practices, and advanced usage patterns.

---

## Table of Contents

- [Key Concepts](#key-concepts)
- [Module Overview](#module-overview)
- [Best Practices](#best-practices)
- [Usage Patterns](#usage-patterns)
  - [Initializing a Project](#initializing-a-project)
  - [Cloning a Plan](#cloning-a-plan)
  - [Executing Plans](#executing-plans)
  - [Working with Multiple Projects](#working-with-multiple-projects)
  - [Performance Optimization](#performance-optimization)
- [Advanced Usage](#advanced-usage)
  - [RasExamples](#rasexamples)
  - [RasUtils](#rasutils)
  - [Artifact System](#artifact-system)
  - [AI-Driven Coding Tools](#ai-driven-coding-tools)
- [Troubleshooting](#troubleshooting)
- [Conclusion](#conclusion)

---

## Key Concepts

1. **RAS Objects**:
   - Represent HEC-RAS projects containing information about plans, geometries, and flow files.
   - Support both a global `ras` object and custom `RasPrj` instances for different projects.

2. **Project Initialization**:
   - Use `init_ras_project()` to initialize projects and set up RAS objects.
   - Handles project file discovery and data structure setup.

3. **File Handling**:
   - Utilizes `pathlib.Path` for consistent, platform-independent file paths.
   - Adheres to HEC-RAS file naming conventions (`.prj`, `.p01`, `.g01`, `.f01`, `.u01`).

4. **Data Management**:
   - Employs Pandas DataFrames to manage structured data about plans, geometries, and flow files.
   - Provides methods for accessing and updating these DataFrames.

5. **Execution Modes**:
   - **Single Plan Execution**: Run individual plans.
   - **Sequential Execution**: Run multiple plans in sequence.
   - **Parallel Execution**: Run multiple plans concurrently for improved performance.

6. **Example Projects**:
   - The `RasExamples` class offers functionality to download and manage HEC-RAS example projects for testing and learning.

7. **Utility Functions**:
   - `RasUtils` provides common utility functions for file operations, backups, and error handling.

8. **Artifact System**:
   - Handles substantial, self-contained content that users might modify or reuse, displayed in a separate UI window.

9. **AI-Driven Coding Tools**:
   - Integrates AI-powered tools like ChatGPT Assistant, LLM Summaries, Cursor IDE Integration, and Jupyter Notebook Assistant.

---

## Module Overview

1. **RasPrj**: Manages HEC-RAS project initialization and data.
2. **RasCmdr**: Handles execution of HEC-RAS simulations.
3. **RasPlan**: Provides functions for plan file operations.
4. **RasGeo**: Manages geometry file operations.
5. **RasUnsteady**: Handles unsteady flow file operations.
6. **RasUtils**: Offers utility functions for common tasks.
7. **RasExamples**: Manages example HEC-RAS projects.

---

## Best Practices

### 1. RAS Object Usage

- **Single Project Scripts**:
  - Use the global `ras` object for simplicity.
    ```python
    from ras_commander import ras, init_ras_project

    init_ras_project("/path/to/project", "6.5")
    # Use ras object for operations
    ```

- **Multiple Projects**:
  - Create separate `RasPrj` instances for each project.
    ```python
    from ras_commander import RasPrj, init_ras_project

    project1 = init_ras_project("/path/to/project1", "6.5", ras_instance=RasPrj())
    project2 = init_ras_project("/path/to/project2", "6.5", ras_instance=RasPrj())
    ```

- **Consistency**:
  - Avoid mixing global and custom RAS objects in the same script.

### 2. Plan Specification

- Use plan numbers as strings (e.g., `"01"`, `"02"`) for consistency.
  ```python
  RasCmdr.compute_plan("01")
  ```

- Check available plans before specifying plan numbers.
  ```python
  print(ras.plan_df)  # Displays available plans
  ```

### 3. Geometry Preprocessor Files

- Clear geometry preprocessor files before significant changes.
  ```python
  RasGeo.clear_geompre_files()
  ```

- Use `clear_geompre=True` for a clean computation environment.
  ```python
  RasCmdr.compute_plan("01", clear_geompre=True)
  ```

### 4. Parallel Execution

- Adjust `max_workers` and `num_cores` based on system capabilities.
  ```python
  RasCmdr.compute_parallel(max_workers=4, num_cores=2)
  ```

- Use `dest_folder` to organize outputs and prevent conflicts.
  ```python
  RasCmdr.compute_parallel(dest_folder="/path/to/results")
  ```

### 5. Error Handling

- Implement try-except blocks to handle potential errors.
  ```python
  try:
      RasCmdr.compute_plan("01")
  except FileNotFoundError:
      print("Plan file not found")
  ```

- Utilize logging for informative output.
  ```python
  import logging
  logging.basicConfig(level=logging.INFO)
  ```

### 6. File Path Handling

- Use `pathlib.Path` for robust file and directory operations.
  ```python
  from pathlib import Path
  project_path = Path("/path/to/project")
  ```

### 7. Type Hinting

- Apply type hints to improve code readability and IDE support.
  ```python
  def compute_plan(plan_number: str, clear_geompre: bool = False) -> bool:
      ...
  ```

---

## Usage Patterns

### Initializing a Project

```python
from ras_commander import init_ras_project, ras

init_ras_project("/path/to/project", "6.5")
print(f"Working with project: {ras.project_name}")
```

### Cloning a Plan

```python
from ras_commander import RasPlan

new_plan_number = RasPlan.clone_plan("01")
print(f"Created new plan: {new_plan_number}")
```

### Executing Plans

- **Single Plan Execution**:
  ```python
  from ras_commander import RasCmdr

  success = RasCmdr.compute_plan("01", num_cores=2)
  print(f"Plan execution {'successful' if success else 'failed'}")
  ```

- **Parallel Execution of Multiple Plans**:
  ```python
  from ras_commander import RasCmdr

  results = RasCmdr.compute_parallel(
      plan_numbers=["01", "02", "03"],
      max_workers=3,
      num_cores=4,
      dest_folder="/path/to/results",
      clear_geompre=True
  )

  for plan, success in results.items():
      print(f"Plan {plan}: {'Successful' if success else 'Failed'}")
  ```

### Working with Multiple Projects

```python
from ras_commander import RasPrj, init_ras_project, RasCmdr

# Initialize two separate projects
project1 = init_ras_project("/path/to/project1", "6.5", ras_instance=RasPrj())
project2 = init_ras_project("/path/to/project2", "6.5", ras_instance=RasPrj())

# Perform operations on each project
RasCmdr.compute_plan("01", ras_object=project1)
RasCmdr.compute_plan("02", ras_object=project2)

# Compare results
results1 = project1.get_hdf_entries()
results2 = project2.get_hdf_entries()
```

### Performance Optimization

```python
from ras_commander import RasCmdr

results = RasCmdr.compute_parallel(
    plan_numbers=["01", "02", "03"],
    max_workers=3,
    num_cores=4,
    dest_folder="/path/to/results",
    clear_geompre=True
)

for plan, success in results.items():
    print(f"Plan {plan}: {'Successful' if success else 'Failed'}")
```

- **Best Practices**:
  - Use `compute_parallel()` for concurrent plan execution.
  - Adjust `max_workers` and `num_cores` based on system capabilities.
  - Organize outputs with `dest_folder`.
  - Use `clear_geompre=True` for clean computations.

---

## Advanced Usage

### RasExamples

The `RasExamples` class provides functionality for managing HEC-RAS example projects. This is particularly useful for testing, learning, and development purposes.

#### Key Concepts

- **Example Project Management**: Access and manipulate example projects.
- **Automatic Downloading and Extraction**: Fetches projects from official sources.
- **Project Categorization**: Organizes projects into categories for easy navigation.

#### Usage Patterns

```python
from ras_commander import RasExamples

# Initialize RasExamples
ras_examples = RasExamples()

# Download example projects (if not already present)
ras_examples.get_example_projects()

# List available categories
categories = ras_examples.list_categories()
print(f"Available categories: {categories}")

# List projects in a specific category
steady_flow_projects = ras_examples.list_projects("Steady Flow")
print(f"Steady Flow projects: {steady_flow_projects}")

# Extract specific projects
extracted_paths = ras_examples.extract_project(["Bald Eagle Creek", "Muncie"])
for path in extracted_paths:
    print(f"Extracted project to: {path}")

# Clean up extracted projects when done
ras_examples.clean_projects_directory()
```

### RasUtils

The `RasUtils` class provides utility functions for common tasks in the `ras_commander` library.

#### Key Concepts

- **File and Directory Operations**: Create, delete, and manage files and directories.
- **Backup and Restoration**: Safeguard original files with backups.
- **Error Handling and Retries**: Robust methods to handle common file system errors.

#### Usage Patterns

```python
from ras_commander import RasUtils
from pathlib import Path

# Create a backup of a file
original_file = Path("project.prj")
backup_file = RasUtils.create_backup(original_file)

# Ensure a directory exists
output_dir = RasUtils.create_directory(Path("output"))

# Find files by extension
prj_files = RasUtils.find_files_by_extension(".prj")

# Get file information
file_size = RasUtils.get_file_size(original_file)
mod_time = RasUtils.get_file_modification_time(original_file)

# Update a plan file
RasUtils.update_plan_file("01", "Geom", 2)

# Remove a file or folder with retry logic
RasUtils.remove_with_retry(Path("temp_folder"), is_folder=True)
```

### Artifact System

The artifact system in `ras_commander` is designed to handle substantial, self-contained content that users might modify or reuse. Artifacts are displayed in a separate UI window for clarity.

#### When to Use Artifacts

- **Code Snippets**: Longer than 15 lines.
- **Complex Diagrams or Charts**: Visual representations that require focus.
- **Detailed Reports or Documentation**: Extensive text content.

#### Example of Creating an Artifact

```python
# Example Function Artifact

<ANTARTIFACTLINK identifier="example-function" type="application/vnd.ant.code" language="python" title="Example Function" isClosed="true" />
```

### AI-Driven Coding Tools

`ras_commander` integrates several AI-powered tools to enhance the coding experience.

#### Tools and Features

1. **ChatGPT Assistant**:
   - Use for general questions about the library and its usage.
   - Provides code suggestions and explanations.

2. **LLM Summaries**:
   - Utilize large language models for up-to-date context on the codebase.
   - Available in two versions: full codebase and examples/docstrings only.

3. **Cursor IDE Integration**:
   - Offers context-aware suggestions and documentation.
   - Automatically includes a `.cursorrules` file when opening the `ras_commander` folder.

4. **Jupyter Notebook Assistant**:
   - Dynamic code summarization and API interaction.
   - Allows for real-time querying and exploration of the library.

#### Best Practices

- **Documentation First**: Start with the provided documentation and examples.
- **Specific Queries**: Use the ChatGPT Assistant for specific questions or clarifications.
- **LLM Summaries**: Leverage when working with external AI models.
- **IDE Integration**: Use Cursor IDE for the most integrated coding experience.
- **Interactive Learning**: Explore the Jupyter Notebook Assistant for experimentation.

---

## Troubleshooting

### 1. Project Initialization Issues

- **Ensure Correct Paths**: Verify that the project path is accurate and the `.prj` file exists.
- **HEC-RAS Version**: Confirm that the specified HEC-RAS version is installed on your system.

### 2. Execution Failures

- **File Existence**: Check that all referenced plan, geometry, and flow files exist.
- **Executable Path**: Ensure the HEC-RAS executable path is correctly set.
- **Log Files**: Review HEC-RAS log files for specific error messages.

### 3. Parallel Execution Problems

- **Resource Allocation**: Reduce `max_workers` if encountering memory issues.
- **System Capabilities**: Adjust `num_cores` based on your system's capacity.
- **Clean Environment**: Use `clear_geompre=True` to prevent conflicts.

### 4. File Access Errors

- **Permissions**: Verify read/write permissions for the project directory.
- **File Locks**: Close any open HEC-RAS instances that might lock files.

### 5. Inconsistent Results

- **Geometry Files**: Clear geometry preprocessor files when making changes.
- **Plan Parameters**: Ensure all plan parameters are correctly set before execution.

---

## Conclusion

The RAS-Commander (`ras_commander`) library provides a powerful set of tools for automating HEC-RAS operations. By following the best practices outlined in this guide and leveraging the library's features, you can efficiently manage and execute complex HEC-RAS projects programmatically.

Remember to refer to the latest documentation and the library's source code for up-to-date information. As you become more familiar with `ras_commander`, you'll discover more ways to optimize your HEC-RAS workflows and increase productivity.

For further assistance, bug reports, or feature requests, please refer to the library's [GitHub repository](https://github.com/billk-FM/ras-commander) and issue tracker.

---

**Happy Modeling!**
==================================================

Folder: c:\GH\ras-commander\examples
==================================================

File: c:\GH\ras-commander\future_dev_roadmap.ipynb
==================================================
{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Future Development Roadmap: \n",
    "    \n",
    "    1. Load critical keys and values from the project files into the project config\n",
    "        Implemented:\n",
    "        - Project Name\n",
    "        - Project Folder\n",
    "        - Lists of plan, flow, unsteady, and geometry files\n",
    "        - HEC-RAS Executable Path\n",
    "        \n",
    "        Not Implemented:\n",
    "        - Units \n",
    "        - Coordinate System \n",
    "        - rasmap file path (replace prj file path extension with \".rasmap\" and add it to the project config)\n",
    "        - Current Plan\n",
    "        - Description (including checks to see if it is a valid string and within the default max length)\n",
    "        - DSS Start Date=01JAN1999 (note format is MMDDYYY)\n",
    "        - DSS Start Time=1200 (note format is HHMM)\n",
    "        - DSS End Date=04JAN1999 (note format is MMDDYYY)\n",
    "        - DSS End Time=1200 (note format is HHMM)\n",
    "        - DSS File=dss\n",
    "        - DSS File=Bald_Eagle_Creek.dss \n",
    "              \n",
    "    Other not implemented:\n",
    "    \n",
    "    2. Load critical keys and lists of string values from the plan files into the project config\n",
    "        - Plan Title\n",
    "        - Plan Shortid\n",
    "        - Simulation Date\n",
    "        - Geometry File\n",
    "        - Flow File (may not be present) - if present, the plan is a 1D steady plan\n",
    "        - Unsteady File (may not be present) - if present, the plan is a 1D or 2D unsteady plan\n",
    "        - UNET D2 Name (may not be present) - if present, the plan is a 2D plan\n",
    "        - Type (1D Steady, 1D Unsteady, 1D/2D, or 2D)\n",
    "        - UNET 1D Methodology\n",
    "       \n",
    "    3. Load critical keys and strings from the unsteady flow files into the project config\n",
    "        - Flow Title\n",
    "        - Pandas Dataframe for any Boundary Conditions present and whether they are defined in the file or whether they use a DSS file input\n",
    "           - One dataframe for all unsteady flow files, with each Boundary Location in each file having its own row\n",
    "           - For each unsteady flow filereturn an appended dataframe with each boundary condition and it's \"Boundary Name\", \"Interval\", \"DSS Path\", \"Flow Hydrograph Slope\", and whether Use DSS is True or False\n",
    "           - Need to incorporate knowledge from the excel methods we used for setting boundary conditions\n",
    "           \n",
    "    4. Load critical keys and strings from the steady flow files into the project config\n",
    "        - Flow Title\n",
    "        - Since steady models are not as commonly used, this is a low priority integration (external contributions are welcome)\n",
    "               \n",
    "    \n",
    "    5. Load critical keys and values from the rasmap file into the project config\n",
    "        - rasmap_projection_string\n",
    "        - Version   #Ex: <Version>2.0.0</Version> \n",
    "        - RASProjectionFilename Filename=\".\\Terrain\\Projection.prj\"\n",
    "        \n",
    "        - List of ras terrains as pandas dataframes\n",
    "            - for each, list of tiff files and order\n",
    "            - flag whether terrain mods exist \n",
    "            \n",
    "        - List of Infiltration hdf files as pandas dataframes\n",
    "            - Mapping of infiltration layers to geometries\n",
    "            \n",
    "        - List of land cover hdf files as pandas dataframes\n",
    "            - Mapping of land cover to geometries\n",
    "        \n",
    "        - List of all Mannings N layers, hdf files and mapping to geometries as pandas dataframes\n",
    "            \n",
    "    6. Create a list of all valid hdf plan files are present in the project folder, and flag whether they contain a completed simulation\n",
    "    \n",
    "    This roadmap for the project_init function will provide the basic information needed to support most basic hec-ras automation workflows.  \n",
    "    \n",
    "    Remember, this project init might be called multiple times.  Every time, it should clear any previously created datafrarmes and variables and replace them.  It is important that revisions can be made, init be re-run, and information is current and reflects the current state of the project. \n",
    "\n",
    "       \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "NOTE: We will NOT need to extract all keys from the HEC-RAS plan files.  We only need to toggle relevant settings, and provide a low-level function that can handle setting a single key by passing a full path.  We will build on top of that function to make specialized functions for each key that is important enough to warrant automation.  Each should have a docstring explaining the keys and how to set them, so the end user does not need to determine those details.   "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# HEC-RAS Plan File Extraction Strategy (Version 6.5)\n",
    "\n",
    "## Key Changes Observed:\n",
    "\n",
    "1. The Program Version has been updated to 6.50.\n",
    "2. Several new keys have been added.\n",
    "3. Some keys have been removed.\n",
    "4. The order of some keys has changed.\n",
    "\n",
    "## Observed Keys in Version 6.5 (1D Unsteady Plan File)\n",
    "\n",
    "| Key | Example Value | Extraction Strategy |\n",
    "|-----|---------------|---------------------|\n",
    "| Plan Title | Unsteady with Bridges and Dam | Split by '=' and take second part |\n",
    "| Program Version | 6.50 | Split by '=' and take second part |\n",
    "| Short Identifier | UnsteadyFlow | Split by '=' and take second part |\n",
    "| Simulation Date | 18FEB1999,0000,24FEB1999,0500 | Split by '=' and ',' to extract start and end dates/times |\n",
    "| Geom File | g01 | Split by '=' and take second part |\n",
    "| Flow File | u02 | Find all occurrences, split by '=' and take second part |\n",
    "| Subcritical Flow | (No value, presence indicates subcritical flow) | Check for presence of line |\n",
    "| K Sum by GR | 0 | Split by '=' and take second part |\n",
    "| Std Step Tol | 0.01 | Split by '=' and take second part |\n",
    "| Critical Tol | 0.01 | Split by '=' and take second part |\n",
    "| Num of Std Step Trials | 20 | Split by '=' and take second part |\n",
    "| Max Error Tol | 0.3 | Split by '=' and take second part |\n",
    "| Flow Tol Ratio | 0.001 | Split by '=' and take second part |\n",
    "| Split Flow NTrial | 30 | Split by '=' and take second part |\n",
    "| Split Flow Tol | 0.02 | Split by '=' and take second part |\n",
    "| Split Flow Ratio | 0.02 | Split by '=' and take second part |\n",
    "| Log Output Level | 0 | Split by '=' and take second part |\n",
    "| Friction Slope Method | 2 | Split by '=' and take second part |\n",
    "| Unsteady Friction Slope Method | 2 | Split by '=' and take second part |\n",
    "| Unsteady Bridges Friction Slope Method | 1 | Split by '=' and take second part |\n",
    "| Parabolic Critical Depth | (No value, presence indicates use) | Check for presence of line |\n",
    "| Global Vel Dist | 0 , 0 , 0 | Split by '=' and then by ',' |\n",
    "| Global Log Level | 0 | Split by '=' and take second part |\n",
    "| CheckData | True | Split by '=' and take second part |\n",
    "| Encroach Param | -1 ,0,0, 0 | Split by '=' and then by ',' |\n",
    "| Flow Ratio Target | (Empty in example) | Split by '=' and take second part if present |\n",
    "| Flow Ratio Tolerance | 0.1 | Split by '=' and take second part |\n",
    "| Flow Ratio Initial Ratio | (Empty in example) | Split by '=' and take second part if present |\n",
    "| Flow Ratio Min Ratio | 0.5 | Split by '=' and take second part |\n",
    "| Flow Ratio Max Ratio | 4 | Split by '=' and take second part |\n",
    "| Flow Ratio Max Iterations | 10 | Split by '=' and take second part |\n",
    "| Flow Ratio Reference | (Empty in example) | Split by '=' and take second part if present |\n",
    "| Computation Interval | 2MIN | Split by '=' and parse value and unit |\n",
    "| Output Interval | 1HOUR | Split by '=' and parse value and unit |\n",
    "| Instantaneous Interval | 2HOUR | Split by '=' and parse value and unit |\n",
    "| Mapping Interval | 1HOUR | Split by '=' and parse value and unit |\n",
    "| Computation Time Step Use Courant | 0 | Split by '=' and take second part |\n",
    "| Computation Time Step Use Time Series | 0 | Split by '=' and take second part |\n",
    "| Computation Time Step Max Courant | (Empty in example) | Split by '=' and take second part if present |\n",
    "| Computation Time Step Min Courant | (Empty in example) | Split by '=' and take second part if present |\n",
    "| Computation Time Step Count To Double | 0 | Split by '=' and take second part |\n",
    "| Computation Time Step Max Doubling | 0 | Split by '=' and take second part |\n",
    "| Computation Time Step Max Halving | 0 | Split by '=' and take second part |\n",
    "| Computation Time Step Residence Courant | 0 | Split by '=' and take second part |\n",
    "| Run HTab | 1 | Split by '=' and take second part |\n",
    "| Run UNet | 1 | Split by '=' and take second part |\n",
    "| Run Sediment | 0 | Split by '=' and take second part |\n",
    "| Run PostProcess | 1 | Split by '=' and take second part |\n",
    "| Run WQNet | 0 | Split by '=' and take second part |\n",
    "| Run RASMapper | 0 | Split by '=' and take second part |\n",
    "| UNET Theta | 1 | Split by '=' and take second part |\n",
    "| UNET Theta Warmup | 1 | Split by '=' and take second part |\n",
    "| UNET ZTol | 0.01 | Split by '=' and take second part |\n",
    "| UNET ZSATol | 0.1 | Split by '=' and take second part |\n",
    "| UNET QTol | (Empty in example) | Split by '=' and take second part if present |\n",
    "| UNET MxIter | 20 | Split by '=' and take second part |\n",
    "| UNET Max Iter WO Improvement | 0 | Split by '=' and take second part |\n",
    "| UNET MaxInSteps | 0 | Split by '=' and take second part |\n",
    "| UNET DtIC | 0 | Split by '=' and take second part |\n",
    "| UNET DtMin | 0 | Split by '=' and take second part |\n",
    "| UNET MaxCRTS | 20 | Split by '=' and take second part |\n",
    "| UNET WFStab | 2 | Split by '=' and take second part |\n",
    "| UNET SFStab | 1 | Split by '=' and take second part |\n",
    "| UNET WFX | 1 | Split by '=' and take second part |\n",
    "| UNET SFX | 1 | Split by '=' and take second part |\n",
    "| UNET Gravity | 32.17405 | Split by '=' and take second part |\n",
    "| UNET 1D Methodology | Finite Difference | Split by '=' and take second part |\n",
    "| UNET DSS MLevel | 4 | Split by '=' and take second part |\n",
    "| UNET Pardiso | 0 | Split by '=' and take second part |\n",
    "| UNET DZMax Abort | 100 | Split by '=' and take second part |\n",
    "| UNET Use Existing IB Tables | -1 | Split by '=' and take second part |\n",
    "| UNET Froude Reduction | False | Split by '=' and take second part |\n",
    "| UNET Froude Limit | 0.8 | Split by '=' and take second part |\n",
    "| UNET Froude Power | 4 | Split by '=' and take second part |\n",
    "| UNET D1 Cores | 0 | Split by '=' and take second part |\n",
    "| UNET WindReference | Eulerian | Split by '=' and take second part |\n",
    "| UNET WindDragFormulation | Hsu (1988) | Split by '=' and take second part |\n",
    "| UNET D2 Coriolis | 0 | Split by '=' and take second part |\n",
    "| UNET D2 Cores | 0 | Split by '=' and take second part |\n",
    "| UNET D2 Theta | 1 | Split by '=' and take second part |\n",
    "| UNET D2 Theta Warmup | 1 | Split by '=' and take second part |\n",
    "| UNET D2 Z Tol | 0.01 | Split by '=' and take second part |\n",
    "| UNET D2 Volume Tol | 0.01 | Split by '=' and take second part |\n",
    "| UNET D2 Max Iterations | 20 | Split by '=' and take second part |\n",
    "| UNET D2 Equation | 0 | Split by '=' and take second part |\n",
    "| UNET D2 TotalICTime | (Empty in example) | Split by '=' and take second part if present |\n",
    "| UNET D2 RampUpFraction | 0.5 | Split by '=' and take second part |\n",
    "| UNET D2 TimeSlices | 1 | Split by '=' and take second part |\n",
    "| UNET D2 Turbulence Formulation | Non-Conservative (original) | Split by '=' and take second part |\n",
    "| UNET D2 Eddy Viscosity | (Empty in example) | Split by '=' and take second part if present |\n",
    "| UNET D2 Transverse Eddy Viscosity | (Empty in example) | Split by '=' and take second part if present |\n",
    "| UNET D2 Smagorinsky Mixing | 0 | Split by '=' and take second part |\n",
    "| UNET D2 BCVolumeCheck | 0 | Split by '=' and take second part |\n",
    "| UNET D2 Latitude | (Empty in example) | Split by '=' and take second part if present |\n",
    "| UNET D2 Cores | 0 | Split by '=' and take second part |\n",
    "| UNET D2 SolverType | PARDISO (Direct) | Split by '=' and take second part |\n",
    "| UNET D2 Minimum Iterations | 3 | Split by '=' and take second part |\n",
    "| UNET D2 Maximum Iterations | 30 | Split by '=' and take second part |\n",
    "| UNET D2 Restart Number | 10 | Split by '=' and take second part |\n",
    "| UNET D2 Relaxation Coeff | 1.3 | Split by '=' and take second part |\n",
    "| UNET D2 SOR Precondition Iterations | 10 | Split by '=' and take second part |\n",
    "| UNET D2 ILUT Maximum Fill | 8 | Split by '=' and take second part |\n",
    "| UNET D2 ILUT Tolerance | 1E-08 | Split by '=' and take second part |\n",
    "| UNET D2 Convergence Tolerance | 0.00001 | Split by '=' and take second part |\n",
    "| PS Theta | 1 | Split by '=' and take second part |\n",
    "| PS WS Tol | 0.01 | Split by '=' and take second part |\n",
    "| PS Volume Tol | 0.01 | Split by '=' and take second part |\n",
    "| PS Max Iterations | 20 | Split by '=' and take second part |\n",
    "| PS Time Slices | 1 | Split by '=' and take second part |\n",
    "| PS Iterate With 2D | 0 | Split by '=' and take second part |\n",
    "| PS Cores | 0 | Split by '=' and take second part |\n",
    "| UNET D1D2 MaxIter | 0 | Split by '=' and take second part |\n",
    "| UNET D1D2 ZTol | 0.01 | Split by '=' and take second part |\n",
    "| UNET D1D2 QTol | 0.1 | Split by '=' and take second part |\n",
    "| UNET D1D2 MinQTol | 1 | Split by '=' and take second part |\n",
    "| DSS File | dss | Split by '=' and take second part |\n",
    "| Write IC File | 0 | Split by '=' and take second part |\n",
    "| Write IC File at Fixed DateTime | 0 | Split by '=' and take second part |\n",
    "| IC Time | ,, | Split by '=' and then by ',' |\n",
    "| Write IC File Reoccurance | (Empty in example) | Split by '=' and take second part if present |\n",
    "| Write IC File at Sim End | 0 | Split by '=' and take second part |\n",
    "| Echo Input | False | Split by '=' and take second part |\n",
    "| Echo Parameters | False | Split by '=' and take second part |\n",
    "| Echo Output | False | Split by '=' and take second part |\n",
    "| Write Detailed | 0 | Split by '=' and take second part |\n",
    "| HDF Write Warmup | 0 | Split by '=' and take second part |\n",
    "| HDF Write Time Slices | 0 | Split by '=' and take second part |\n",
    "| HDF Flush | 0 | Split by '=' and take second part |\n",
    "| HDF Compression | 1 | Split by '=' and take second part |\n",
    "| HDF Chunk Size | 1 | Split by '=' and take second part |\n",
    "| HDF Spatial Parts | 1 | Split by '=' and take second part |\n",
    "| HDF Use Max Rows | 0 | Split by '=' and take second part |\n",
    "| HDF Fixed Rows | 1 | Split by '=' and take second part |\n",
    "| Stage Flow Hydrograph | Bald Eagle      ,Loc Hav         ,138154.4 | Find all occurrences, split by '=' and ',' |\n",
    "| Calibration Method | 0 | Split by '=' and take second part |\n",
    "| Calibration Iterations | 20 | Split by '=' and take second part |\n",
    "| Calibration Max Change | 0.05 | Split by '=' and take second part |\n",
    "| Calibration Tolerance | 0.2 | Split by '=' and take second part |\n",
    "| Calibration Maximum | 1.5 | Split by '=' and take second part |\n",
    "| Calibration Minimum | 0.5 | Split by '=' and take second part |\n",
    "| Calibration Optimization Method | 1 | Split by '=' and take second part |\n",
    "| Calibration Window | ,,, | Split by '=' and then by ',' |\n",
    "| WQ AD Non Conservative | (No value, presence indicates use) | Check for presence of line |\n",
    "| WQ ULTIMATE | -1 | Split by '=' and take second part |\n",
    "| WQ Max Comp Step | 1HOUR | Split by '=' and parse value and unit |\n",
    "| WQ Output Interval | 15MIN | Split by '=' and parse value and unit |\n",
    "| WQ Output Selected Increments | 0 | Split by '=' and take second part |\n",
    "| WQ Create Restart | 0 | Split by '=' and take second part |\n",
    "| WQ Fixed Restart | 0 | Split by '=' and take second part |\n",
    "| WQ Restart Simtime | (Empty in example) | Split by '=' and take second part if present |\n",
    "| WQ Restart Date | (Empty in example) | Split by '=' and take second part if present |\n",
    "| WQ Restart Hour | (Empty in example) | Split by '=' and take second part if present |\n",
    "| WQ System Summary | 0 | Split by '=' and take second part |\n",
    "| WQ Write To DSS | 0 | Split by '=' and take second part |\n",
    "| Sorting and Armoring Iterations | 10 | Split by '=' and take second part |\n",
    "| XS Update Threshold | 0.02 | Split by '=' and take second part |\n",
    "| Bed Roughness Predictor | 0 | Split by '=' and take second part |\n",
    "| Hydraulics Update Threshold | 0.02 | Split by '=' and take second part |\n",
    "| Energy Slope Method | 0 | Split by '=' and take second part |\n",
    "| Volume Change Method | 1 | Split by '=' and take second part |\n",
    "| Sediment Retention Method | 0 | Split by '=' and take second part |\n",
    "| Sediment TS Multiplier | 1 | Split by '=' and take second part |\n",
    "| Warm Up Method | 0 | Split by '=' and take second part |\n",
    "| Warm Up Duration | (Empty in example) | Split by '=' and take second part if present |\n",
    "| Warm Up Duration - Concentration | (Empty in example) | Split by '=' and take second part if present |\n",
    "| Warm Up Duration - Gradation | (Empty in example) | Split by '=' and take second part if present |\n",
    "| Warm Up Duration - Bathymetry | (Empty in example) | Split by '=' and take second part if present |\n",
    "| XS Weighting Method | 0 | Split by '=' and take second part |\n",
    "| Number of US Weighted Cross Sections | 1 | Split by '=' and take second part |\n",
    "| Number of DS Weighted Cross Sections | 1 | Split by '=' and take second part |\n",
    "| Upstream XS Weight | 0 | Split by '=' and take second part |\n",
    "| Main XS Weight | 1 | Split by '=' and take second part |\n",
    "| Downstream XS Weight | 0 | Split by '=' and take second part |\n",
    "| Number of DS XS's Weighted with US Boundary | 1 | Split by '=' and take second part |\n",
    "| Upstream Boundary Weight | 1 | Split by '=' and take second part |\n",
    "| Weight of XSs Associated with US Boundary | 0 | Split by '=' and take second part |\n",
    "| Number of US XS's Weighted with DS Boundary | 1 | Split by '=' and take second part |\n",
    "| Downstream Boundary Weight | 0.5 | Split by '=' and take second part |\n",
    "| Weight of XSs Associated with DS Boundary | 0.5 | Split by '=' and take second part |\n",
    "| Percentile Method | 0 | Split by '=' and take second part |\n",
    "| Sediment Output Level | 4 | Split by '=' and take second part |\n",
    "| Mass or Volume Output | 0 | Split by '=' and take second part |\n",
    "| Output Increment Type | 1 | Split by '=' and take second part |\n",
    "| Profile and TS Output Increment | 10 | Split by '=' and take second part |\n",
    "| Transport Output Increment | 1 | Split by '=' and take second part |\n",
    "| XS Output Flag | 0 | Split by '=' and take second part |\n",
    "| XS Output Increment | 10 | Split by '=' and take second part |\n",
    "| Read HDF5 Sediment Hotstart | 0 | Split by '=' and take second part |\n",
    "| Sediment Hotstart Type | 0 | Split by '=' and take second part |\n",
    "| Sediment Hotstart File | (Empty in example) | Split by '=' and take second part if present |\n",
    "| Sediment Hotstart Date | (Empty in example) | Split by '=' and take second part if present |\n",
    "| Sediment Hotstart Time | (Empty in example) | Split by '=' and take second part if present |\n",
    "| Write Gradation File | 0 | Split by '=' and take second part |\n",
    "| Read Gradation Hotstart | 0 | Split by '=' and take second part |\n",
    "| Gradation File Name | (Empty in example) | Split by '=' and take second part if present |\n",
    "| Write HDF5 File | 0 | Split by '=' and take second part |\n",
    "| Write Binary Output | 1 | Split by '=' and take second part |\n",
    "| Write DSS Sediment File | 0 | Split by '=' and take second part |\n",
    "| DSS Sediment Output Type | 1 | Split by '=' and take second part |\n",
    "| DSS Location | (Empty in example) | Split by '=' and take second part if present |\n",
    "| Summary Reach | (Empty in example) | Split by '=' and take second part if present |\n",
    "| SV Curve | 0 | Split by '=' and take second part |\n",
    "| Specific Gage Flag | 0 | Split by '=' and take second part |\n",
    "| Subcell Erosion Methods | 0 | Split by '=' and take second part |\n",
    "| Subcell Deposition Methods | 0 | Split by '=' and take second part |\n",
    "| Advection Scheme | 1 | Split by '=' and take second part |\n",
    "| Matrix Solver | 0 | Split by '=' and take second part |\n",
    "| Implicit Weighting Factor | 1 | Split by '=' and take second part |\n",
    "| Maximum Outer Loop Convergence Iterations | 5 | Split by '=' and take second part |\n",
    "| Convergence Maximum Absolute | 0.001 | Split by '=' and take second part |\n",
    "| Convergence RMSE | 0.0001 | Split by '=' and take second part |\n",
    "| Grain Fractions Max Abs Error | 0.001 | Split by '=' and take second part |\n",
    "| Max Subgrid Regions | 1 | Split by '=' and take second part |\n",
    "| Max Subgrid Length Scale | 3.402823E+38 | Split by '=' and take second part |\n",
    "| Initial Layer Thickness | 3 | Split by '=' and take second part |\n",
    "| Min Layer Thickness | 0.1 | Split by '=' and take second part |\n",
    "| Max Layer Thickness | 6 | Split by '=' and take second part |\n",
    "| Number of Layers | 5 | Split by '=' and take second part |\n",
    "\n",
    "## Key Changes and Implications:\n",
    "\n",
    "1. New sediment-related parameters: The updated file includes many new parameters related to sediment transport and modeling. This suggests that the sediment modeling capabilities have been expanded in Version 6.5.\n",
    "\n",
    "2. Computational parameters: New parameters for time step control and computational methods have been added, indicating more fine-grained control over the simulation process.\n",
    "\n",
    "3. 2D modeling parameters: Additional parameters for 2D modeling (e.g., UNET D2 parameters) suggest enhanced 2D modeling capabilities.\n",
    "\n",
    "4. Water quality parameters: Some water quality (WQ) parameters have been removed, while others remain. This might indicate a change in how water quality modeling is handled.\n",
    "\n",
    "5. Output control: New parameters for controlling output formats and intervals have been added, suggesting more flexible output options.\n",
    "\n",
    "## Revised Extraction Strategy:\n",
    "\n",
    "1. Maintain a dictionary of all of the relevant keys, including those from both versions.\n",
    "    - Have a separate function specifically to lookup keys in the plan file from a dictionary or by passing the key name. \n",
    "2. When parsing the file, check for the presence of each key and extract its value if present.\n",
    "3. For keys that may appear multiple times (e.g., 'Stage Flow Hydrograph'), collect all occurrences in a list.\n",
    "4. Use regular expressions for more complex parsing tasks, especially for keys with multiple values or specific formats.\n",
    "5. Implement version-specific parsing logic where necessary, based on the 'Program Version' value.\n",
    "6. Handle empty values consistently, either storing them as None or an empty string.\n",
    "7. For boolean flags (keys without values), store their presence as True in the dictionary.\n",
    "8. Implement error handling for unexpected formats or missing required keys.\n",
    "\n",
    "## Similarities Across Plan Types\n",
    "\n",
    "1. Basic Structure: All plan types (steady, unsteady, 1D, and 2D) maintain a similar overall structure with key-value pairs.\n",
    "2. Common Keys: Many keys are shared across all plan types, including basic project information, computational parameters, and output settings.\n",
    "3. Version Consistency: The key structure remains consistent across different HEC-RAS versions, with differences primarily in values rather than key names.\n",
    "\n",
    "## Key Differences in 2D Plans\n",
    "\n",
    "While 2D plans share many keys with 1D plans, they introduce several new keys and sections:\n",
    "\n",
    "1. 2D Specific Keys:\n",
    "   - UNET D2 Name\n",
    "   - UNET D2 Cores\n",
    "   - UNET D2 SolverType\n",
    "   - UNET D2 Turbulence Formulation\n",
    "   - UNET D2 Smagorinsky Mixing\n",
    "\n",
    "2. Breach Modeling Keys:\n",
    "   - Breach Loc (multiple entries)\n",
    "   - Breach Method\n",
    "   - Breach Geom\n",
    "   - Breach Start\n",
    "   - Breach Progression\n",
    "   - Simplified Physical Breach Downcutting\n",
    "   - Simplified Physical Breach Widening\n",
    "   - Mass Wasting Options\n",
    "   - Various DLBreach keys\n",
    "\n",
    "3. Adaptive Hydraulics (ADH) Keys:\n",
    "   - ADH Filename\n",
    "   - ADH Link\n",
    "\n",
    "## Updated Extraction Strategy\n",
    "\n",
    "1. Single Key-Value Pairs:\n",
    "   - Create a dictionary to store all single key-value pairs.\n",
    "   - Populate this dictionary for all plan types (steady, unsteady, 1D, 2D).\n",
    "   - Handle empty values consistently, storing them as None or an empty string.\n",
    "\n",
    "2. Multi-Key Pairs (e.g., Boundary Conditions, Breach Locations):\n",
    "   - Use pandas DataFrames to store multi-key pairs.\n",
    "   - Create separate DataFrames for different types of multi-key data (e.g., one for boundary conditions, another for breach locations).\n",
    "   - Ensure the DataFrame structure can accommodate data from all plan types.\n",
    "\n",
    "3. Plan Type Detection:\n",
    "   - Implement logic to detect the plan type (steady/unsteady, 1D/2D) based on the presence of specific keys.\n",
    "   - Use this detection to guide the extraction process, especially for 2D-specific keys.\n",
    "\n",
    "4. Consistent Extraction Process:\n",
    "   - Use a single extraction function that can handle all plan types.\n",
    "   - Within this function, use conditional logic to handle plan-type-specific keys and sections.\n",
    "\n",
    "5. Version Agnostic Approach:\n",
    "   - Design the extraction process to be version-agnostic, focusing on key names rather than specific values.\n",
    "   - Maintain a comprehensive list of all possible keys across versions and plan types.\n",
    "\n",
    "6. Handling 2D-Specific Data:\n",
    "   - For 2D-specific sections (like breach data), create dedicated DataFrames or nested dictionaries to capture the hierarchical structure.\n",
    "   - Ensure that the extraction process can handle the repetitive nature of certain 2D-specific sections (e.g., multiple breach locations).\n",
    "\n",
    "7. Error Handling and Logging:\n",
    "   - Implement robust error handling to manage unexpected key names or structures.\n",
    "   - Log any inconsistencies or unrecognized keys for further analysis.\n",
    "\n",
    "By following this updated strategy, we can create a flexible and comprehensive extraction process that handles all types of HEC-RAS plan files consistently, regardless of the simulation type or software version. The resulting data structure will provide easy access to both common and plan-specific parameters, facilitating further analysis and processing of HEC-RAS simulation data.\n",
    "\n",
    "\n",
    "\n",
    "This revised strategy accounts for the changes in Version 6.5 while maintaining backward compatibility with earlier versions. It allows for flexible parsing of the plan file, accommodating both existing and potential future changes in the file structure."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}

==================================================

File: c:\GH\ras-commander\LICENSE
==================================================
MIT License

Copyright (c) 2024 William M. Katzenmeyer

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so.

==================================================

File: c:\GH\ras-commander\pyproject.toml
==================================================
[build-system]
requires = ["setuptools>=45", "wheel"]
build-backend = "setuptools.build_meta:__legacy__"

==================================================

Folder: c:\GH\ras-commander\ras_commander
==================================================

File: c:\GH\ras-commander\README.md
==================================================
# RAS Commander (ras-commander)

RAS Commander is a Python library for automating HEC-RAS operations, providing a set of tools to interact with HEC-RAS project files, execute simulations, and manage project data. This library is an evolution of the RASCommander 1.0 Python Notebook Application previously released under HEC-Commander tools.

Contributors:
William Katzenmeyer, P.E., C.F.M. - billk@fenstermaker.com
Sean Micek, P.E., C.F.M. - smicek@fenstermaker.com
Aaron Nichols, P.E., C.F.M. - anichols@fenstermaker.com

## Features

- Automate HEC-RAS project management and simulations
- Support for both single and multiple project instances
- Parallel execution of HEC-RAS plans
- Utilities for managing geometry, plan, and unsteady flow files
- Example project management for testing and development
- Two primary operation modes: "Run Missing" and "Build from DSS"

## Installation

Install ras-commander using pip:

pip install pandas requests pathlib
pip install ras-commander

## Requirements

- Python 3.9+
- HEC-RAS 6.2 or later (other versions may work, all testing was done with version 6.2 and above)

For a full list of dependencies, see the `requirements.txt` file.

## Quick Start

from ras_commander import init_ras_project, RasCmdr, RasPlan

# Initialize a project
init_ras_project(r"/path/to/project", "6.5")

# Execute a single plan
RasCmdr.compute_plan("01", dest_folder=r"/path/to/results", overwrite_dest=True)

# Execute plans in parallel
results = RasCmdr.compute_parallel(
    plan_numbers=["01", "02"],
    max_workers=2,
    cores_per_run=2,
    dest_folder=r"/path/to/results",
    overwrite_dest=True
)

# Modify a plan
RasPlan.set_geom("01", "02")

## Key Components

- `RasPrj`: Manages HEC-RAS projects
- `RasCmdr`: Handles execution of HEC-RAS simulations
- `RasPlan`: Provides functions for modifying and updating plan files
- `RasGeo`: Handles operations related to geometry files
- `RasUnsteady`: Manages unsteady flow file operations
- `RasUtils`: Contains utility functions for file operations and data management
- `RasExamples`: Manages and loads HEC-RAS example projects

## RasExamples

The `RasExamples` class provides functionality for quickly loading and managing HEC-RAS example projects. This is particularly useful for testing and development purposes.

Key features:
- Download and extract HEC-RAS example projects
- List available project categories and projects
- Extract specific projects for use
- Manage example project data efficiently

Example usage:
from ras_commander import RasExamples

ras_examples = RasExamples()
ras_examples.get_example_projects()  # Downloads example projects if not already present
categories = ras_examples.list_categories()
projects = ras_examples.list_projects("Steady Flow")
extracted_paths = ras_examples.extract_project(["Bald Eagle Creek", "Muncie"])

## RasPrj

The `RasPrj` class is central to managing HEC-RAS projects within the ras-commander library. It handles project initialization, data loading, and provides access to project components.

Key features:
- Initialize HEC-RAS projects
- Load and manage project data (plans, geometries, flows, etc.)
- Provide easy access to project files and information

Note: While a global `ras` object is available for convenience, you can create multiple `RasPrj` instances to manage several projects simultaneously.

Example usage:
from ras_commander import RasPrj, init_ras_project

# Using the global ras object
init_ras_project("/path/to/project", "6.5")

# Creating a custom RasPrj instance
custom_project = RasPrj()
init_ras_project("/path/to/another_project", "6.5", ras_instance=custom_project)


## AI-Driven Coding Experience

ras-commander provides several AI-powered tools to enhance the coding experience:

1. ChatGPT Assistant: A specialized GPT model trained on the ras-commander codebase, available for answering queries and providing code suggestions.

2. LLM Summaries: Up-to-date summaries of the codebase for use with large language models like Claude or GPT-4.

3. Cursor IDE Integration: Custom rules for the Cursor IDE to provide context-aware suggestions and documentation.

4. Jupyter Notebook Assistant: A notebook for dynamic code summarization and API interaction.

These tools aim to streamline development and provide intelligent assistance when working with the ras-commander library.

## Documentation

For detailed usage instructions and API documentation, please refer to the [Comprehensive Library Guide](Comprehensive_Library_Guide.md).

## Examples

Check out the `examples/` directory for sample scripts demonstrating various features of ras-commander.

## Project Organization Diagram

ras_commander
 .github
    workflows
        python-package.yml
 ras_commander
    __init__.py
    RasCmdr.py
    RasExamples.py
    RasGeo.py
    RasPlan.py
    RasPrj.py
    RasUnsteady.py
    RasUtils.py
 examples
    01_project_initialization.py
    02_plan_operations.py
    03_geometry_operations.py
    04_unsteady_flow_operations.py
    05_utility_functions.py
    06_single_plan_execution.py
    07_sequential_plan_execution.py
    08_parallel_execution.py
    09_specifying_plans.py
    10_arguments_for_compute.py
    11_Using_RasExamples.ipynb
    12_plan_set_execution.py
    13_multiple_project_operations.py
 tests
    ... (test files)
 .gitignore
 LICENSE
 README.md
 STYLE_GUIDE.md
 Comprehensive_Library_Guide.md
 pyproject.toml
 setup.cfg
 setup.py
 requirements.txt

## Inclusion of .cursorrules and ai_tools for AI-driven Coding Experience

Open the ras_commander folder in the Cursor IDE, and it will automatically include the .cursorrules file in your instructions. Additionally, two other provided methods for interacting with the library through your current AI subscriptions:

- ChatGPT: ras_commander GPT Assistant (LINK HERE)
- Latest LLM summaries of the code base:
   - Entire code base: LINK HERE (TOKEN COUNT) (for Claude or Gemini)
   - Examples and Function Docstrings Only: LINK HERE (TOKEN COUNT) (for GPT-4o, o1 or Llama 3.1 405b)
- Cursor IDE through .cursorrules file
- 'rascommander_code_assistant.ipynb' notebook in the ras_commander folder, which allows for dynamic summarization of the code base and API chatting directly through the notebook.

There are a series of scripts provided in the "llm_summaries" folder that provide summaries of the code base, and the docstrings of the functions. They can be run in your local environment, or provided to ChatGPT's code interpreter for execution.

## RAS-Cmdr GPT Assistant

The RAS Commander GPT assistant has access to the entire code base, and can be a helpful tool for understanding the library and its capabilities.  However, it is subject to the same context window limitations and file retrieval limitations as I have covered in ADD BLOG LINK HERE.  For best results, use the llm summaries above to provide robust context to the model before asking to generate complex workflows. 

## Current Uses and Roadmap Items

### Potential Uses (Roadmap Items) of HEC-RAS Automation Functions

This set of functions provides a powerful foundation for automating various aspects of HEC-RAS modeling workflows. Here are some potential applications:

1. **Calibration and Sensitivity Analysis:**
    - **Automated Parameter Variation:** Users can create multiple simulation scenarios with varying parameters (e.g., Manning's n values, boundary conditions, initial conditions) to calibrate their model against observed data.
    - **Sensitivity Testing:** Evaluate the impact of different input parameters on model outputs by generating a range of scenarios and analyzing the results. This helps identify critical parameters that require more attention during calibration.

2. **Real-time Forecasting:**
    - **Dynamic Model Updates:** Integrate with external data sources (e.g., weather forecasts, streamflow observations) to automatically update boundary conditions and initial conditions in unsteady flow files before running the simulation.
    - **Ensemble Forecasting:** Generate multiple forecasts by incorporating uncertainty in input data and model parameters. This provides a more comprehensive understanding of potential future flow conditions.

3. **Scenario Analysis:**
    - **Land Use Change Impacts:** Evaluate the effects of land use changes on flood risk by modifying Manning's n values using `extract_2d_mannings_tables`, `modify_2d_mannings_table`, and `write_2d_mannings_tables` and running simulations with updated geometry files.
    - **Climate Change Impacts:** Analyze the potential impacts of projected climate changes on flood risk by adjusting precipitation patterns and other relevant parameters in unsteady flow files.

4. **Batch Processing and High-Performance Computing:**
    - **Large-scale Model Runs:** Utilize `run_plans_parallel` to execute multiple simulations concurrently on a multi-core system, significantly reducing processing time for large-scale models or complex scenarios.
    - **Automated Report Generation:** Integrate with Python libraries like matplotlib and bokeh to automatically generate customized reports summarizing simulation results, including tables, figures, and maps.

5. **Model Development and Testing:**
    - **Rapid Prototyping:** Quickly set up and run new model configurations using template files and automated workflows, facilitating rapid model development and testing.
    - **Regression Testing:** Ensure model integrity and consistency after code changes or updates by automatically running a predefined set of simulations and comparing results with expected outputs.

6. **User-Friendly Interfaces:**
    - **GUI Development:** Integrate with Python GUI libraries like Tkinter or PyQt to create user-friendly interfaces for automating HEC-RAS workflows, allowing non-programmers to access the power of automation.

## Contributing

We welcome contributions! Please see our [Contributing Guide](CONTRIBUTING.md) for details on how to submit pull requests, report issues, and suggest improvements.

## Style Guide

This project follows a specific style guide to maintain consistency across the codebase. Please refer to the [Style Guide](STYLE_GUIDE.md) for details on coding conventions, documentation standards, and best practices.

## License

ras-commander is released under the MIT License. See the license file for details.

## Acknowledgments

RAS Commander is based on the HEC-Commander project's "Command Line is All You Need" approach, leveraging the HEC-RAS command-line interface for automation. The initial development of this library was presented in the HEC-Commander Tools repository.  In a 2024 Australian Water School webinar, Bill demonstrated the derivation of basic HEC-RAS automation functions from plain language instructions. Leveraging the previously developed code and AI tools, the library was created. The primary tools used for this initial development were Anthropic's Claude, GPT-4o, Google's Gemini Experimental models, and the Cursor AI Coding IDE.

## Contact

For questions, suggestions, or support, please contact:
William Katzenmeyer, P.E., C.F.M. - billk@fenstermaker.com

==================================================

File: c:\GH\ras-commander\requirements.txt
==================================================
# Core dependencies
pandas>=1.0.0
numpy>=1.18.0
pathlib>=1.0.1
requests>=2.25.0

# Data handling and analysis
h5py>=3.1.0

# Plotting (if needed)
matplotlib>=3.3.0

# Development and testing
pytest>=6.2.0
flake8>=3.9.0
black>=21.5b1

# Documentation
sphinx>=3.5.0
sphinx-rtd-theme>=0.5.0

# Packaging and distribution
setuptools>=50.3.2
wheel>=0.35.1
twine>=3.3.0
==================================================

File: c:\GH\ras-commander\setup.py
==================================================
from setuptools import setup, find_packages

setup(
    name="ras-commander",
    version="0.33.0",
    packages=["ras_commander"],
    include_package_data=True,
)
==================================================

File: c:\GH\ras-commander\STYLE_GUIDE.md
==================================================
# RAS Commander (ras-commander) Style Guide

## Table of Contents
1. [Naming Conventions](#1-naming-conventions)
2. [Code Structure and Organization](#2-code-structure-and-organization)
3. [Documentation and Comments](#3-documentation-and-comments)
4. [Code Style](#4-code-style)
5. [Error Handling](#5-error-handling)
6. [Testing](#6-testing)
7. [Version Control](#7-version-control)
8. [Type Hinting](#8-type-hinting)
9. [Project-Specific Conventions](#9-project-specific-conventions)
10. [Inheritance](#10-inheritance)
11. [RasUtils Usage](#11-rasutils-usage)
12. [Working with RasExamples](#12-working-with-rasexamples)

## 1. Naming Conventions

### 1.1 General Rules
- Use `snake_case` for all function and variable names
- Use `PascalCase` for class names
- Use `UPPER_CASE` for constants

### 1.2 Library-Specific Naming
- Informal Name: RAS Commander
- Package Name and GitHub Library Name: ras-commander (with a hyphen)
- Import Name: ras_commander (with an underscore)
- Main Class of functions for HEC-RAS Automation: RasCmdr

### 1.3 Function Naming
- Start function names with a verb describing the action
- Use clear, descriptive names
- Common verbs and their uses:
  - `get_`: retrieve data
  - `set_`: set values or properties
  - `compute_`: execute or calculate
  - `clone_`: copy
  - `clear_`: remove or reset data
  - `find_`: search
  - `update_`: modify existing data

### 1.4 Abbreviations
Use the following abbreviations consistently throughout the codebase:

- ras: HEC-RAS
- prj: Project
- geom: Geometry
- pre: Preprocessor
- geompre: Geometry Preprocessor
- num: Number
- init: Initialize
- XS: Cross Section
- DSS: Data Storage System
- GIS: Geographic Information System
- BC: Boundary Condition
- IC: Initial Condition
- TW: Tailwater

Use these abbreviations in lowercase for function and variable names (e.g., `geom`, not `Geom` or `GEOM`).

### 1.5 Class Naming
- Use `PascalCase` for class names (e.g., `FileOperations`, `PlanOperations`, `RasCmdr`)
- Class names should be nouns or noun phrases

### 1.6 Variable Naming
- Use descriptive names indicating purpose or content
- Prefix boolean variables with `is_`, `has_`, or similar

## 2. Code Structure and Organization

### 2.1 File Organization
- Group related functions into appropriate classes
- Keep each class in its own file, named after the class

### 2.2 Function Organization
- Order functions logically within a class
- Place common or important functions at the top of the class

### 2.3 Module Structure
- Use the following order for module contents:
  1. Module-level docstring
  2. Imports (grouped and ordered)
  3. Constants
  4. Classes
  5. Functions

## 3. Documentation and Comments

### 3.1 Docstrings
- Use docstrings for all modules, classes, methods, and functions
- Follow Google Python Style Guide format
- Include parameters, return values, and a brief description
- For complex functions, include examples in the docstring

### 3.2 Comments
- Use inline comments sparingly, only for complex logic
- Keep comments up-to-date with code changes
- Use TODO comments for future work, formatted as: `# TODO: description`

## 4. Code Style

### 4.1 Imports
- Order imports as follows:
  1. Standard library imports
  2. Third-party library imports
  3. Local application imports
- Use absolute imports
- Use `import ras_commander as ras` for shortening the library name in examples

### 4.2 Whitespace
- Follow PEP 8 guidelines
- Use 4 spaces for indentation (no tabs)
- Use blank lines to separate logical sections of code

### 4.3 Line Length
- Limit lines to 79 characters for code, 72 for comments and docstrings
- Use parentheses for line continuation in long expressions

## 5. Error Handling

- Use explicit exception handling with try/except blocks
- Raise custom exceptions when appropriate, with descriptive messages
- Use logging for error reporting and debugging information
- Use specific exception types when raising errors (e.g., `ValueError`, `FileNotFoundError`)
- Provide informative error messages that include relevant details
- Implement proper cleanup in finally blocks when necessary
- For user-facing functions, consider wrapping internal exceptions in custom exceptions specific to ras-commander

Example:
```python
try:
    result = compute_plan(plan_number)
except FileNotFoundError as e:
    raise RasCommanderError(f"Plan file not found: {e}")
except ValueError as e:
    raise RasCommanderError(f"Invalid plan parameter: {e}")
except Exception as e:
    raise RasCommanderError(f"Unexpected error during plan computation: {e}")
```

## 6. Testing

- Write unit tests for all functions and methods
- Use the `unittest` framework
- Aim for high test coverage, especially for critical functionality
- Include tests for both single-project and multi-project scenarios
- Write clear and descriptive test names
- Use setUp and tearDown methods for common test preparations and cleanups
- Use mock objects when appropriate to isolate units under test

## 7. Version Control

- Use meaningful commit messages that clearly describe the changes made
- Create feature branches for new features or significant changes
- Submit pull requests for code review before merging into the main branch
- Keep commits focused and atomic (one logical change per commit)
- Use git tags for marking releases
- Follow semantic versioning for release numbering

## 8. Type Hinting

- Use type hints for all function parameters and return values
- Use the `typing` module for complex types (e.g., `List`, `Dict`, `Optional`)
- Include type hints in function signatures and docstrings
- Use `Union` for parameters that can accept multiple types
- For methods that don't return a value, use `-> None`

Example:
```python
from typing import List, Optional

def process_plans(plan_numbers: List[str], max_workers: Optional[int] = None) -> bool:
    # Function implementation
    return True
```

## 9. Project-Specific Conventions

### 9.1 RAS Instance Handling
- Design functions to accept an optional `ras_object` parameter:
  ```python
  def some_function(param1, param2, ras_object=None):
      ras_obj = ras_object or ras
      ras_obj.check_initialized()
      # Function implementation
  ```

### 9.2 File Path Handling
- Use `pathlib.Path` for file and directory path manipulations
- Convert string paths to Path objects at the beginning of functions

### 9.3 DataFrame Handling
- Use pandas for data manipulation and storage where appropriate
- Prefer method chaining for pandas operations to improve readability

### 9.4 Parallel Execution
- Follow the guidelines in the "Benchmarking is All You Need" blog post for optimal core usage in parallel plan execution

### 9.5 Function Return Values
- Prefer returning meaningful values over modifying global state
- Use tuple returns for multiple values instead of modifying input parameters

## 10. Inheritance

### 10.1 General Principles

- Prioritize composition over inheritance when appropriate
- Design base classes for extension
- Clearly document the public API and subclass API using docstrings

### 10.2 Naming Conventions

- Public API: No leading underscores
- Subclass API: Single leading underscore (e.g., `_prepare_for_execution`)
- Internal attributes and methods: Single leading underscore
- Name mangling (double leading underscores): Use sparingly and document the decision clearly

### 10.3 Template Method Pattern

Consider using the template method pattern in base classes to define a high-level algorithm structure. Subclasses can then override specific steps to customize behavior.

### 10.4 Dataframe Access Control

Use properties to control access and modification of dataframes, providing a controlled interface for subclasses.

## 11. RasUtils Usage

- Use RasUtils for general-purpose utility functions that don't fit into other specific classes
- When adding new utility functions, ensure they are static methods of the RasUtils class
- Keep utility functions focused and single-purpose
- Document utility functions thoroughly, including examples of usage

Example:
```python
class RasUtils:
    @staticmethod
    def create_backup(file_path: Path, backup_suffix: str = "_backup") -> Path:
        """
        Create a backup of the specified file.

        Args:
            file_path (Path): Path to the file to be backed up
            backup_suffix (str): Suffix to append to the backup file name

        Returns:
            Path: Path to the created backup file

        Example:
            >>> backup_path = RasUtils.create_backup(Path("project.prj"))
            >>> print(f"Backup created at: {backup_path}")
        """
        # Function implementation
```

## 12. Working with RasExamples

- Use RasExamples for managing and loading example HEC-RAS projects
- Always check if example projects are already downloaded before attempting to download them again
- Use the `list_categories()` and `list_projects()` methods to explore available examples
- When extracting projects, use meaningful names and keep track of extracted paths
- Clean up extracted projects when they are no longer needed using `clean_projects_directory()`

Example:
```python
ras_examples = RasExamples()
if not ras_examples.is_project_extracted("Bald Eagle Creek"):
    extracted_path = ras_examples.extract_project("Bald Eagle Creek")[0]
    # Use the extracted project
    # ...
    # Clean up when done
    RasUtils.remove_with_retry(extracted_path, is_folder=True)
```

Remember, consistency is key. When in doubt, prioritize readability and clarity in your code. Always consider the maintainability and extensibility of the codebase when making design decisions.
==================================================

File: c:\GH\ras-commander\.eggs\README.txt
==================================================
This directory contains eggs that were downloaded by setuptools to build, test, and run plug-ins.

This directory caches those eggs to prevent repeated downloads.

However, it is safe to delete this directory.


==================================================

Folder: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg
==================================================

Folder: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\EGG-INFO
==================================================

Folder: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm
==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\EGG-INFO\entry_points.txt
==================================================
[distutils.setup_keywords]
use_scm_version = setuptools_scm._integration.setuptools:version_keyword

[setuptools.file_finders]
setuptools_scm = setuptools_scm._file_finders:find_files

[setuptools.finalize_distribution_options]
setuptools_scm = setuptools_scm._integration.setuptools:infer_version

[setuptools_scm.files_command]
.git = setuptools_scm._file_finders.git:git_find_files
.hg = setuptools_scm._file_finders.hg:hg_find_files

[setuptools_scm.files_command_fallback]
.git_archival.txt = setuptools_scm._file_finders.git:git_archive_find_files
.hg_archival.txt = setuptools_scm._file_finders.hg:hg_archive_find_files

[setuptools_scm.local_scheme]
dirty-tag = setuptools_scm.version:get_local_dirty_tag
no-local-version = setuptools_scm.version:get_no_local_node
node-and-date = setuptools_scm.version:get_local_node_and_date
node-and-timestamp = setuptools_scm.version:get_local_node_and_timestamp

[setuptools_scm.parse_scm]
.git = setuptools_scm.git:parse
.hg = setuptools_scm.hg:parse

[setuptools_scm.parse_scm_fallback]
.git_archival.txt = setuptools_scm.git:parse_archival
.hg_archival.txt = setuptools_scm.hg:parse_archival
PKG-INFO = setuptools_scm.fallbacks:parse_pkginfo
pyproject.toml = setuptools_scm.fallbacks:fallback_version
setup.py = setuptools_scm.fallbacks:fallback_version

[setuptools_scm.version_scheme]
calver-by-date = setuptools_scm.version:calver_by_date
guess-next-dev = setuptools_scm.version:guess_next_dev_version
no-guess-dev = setuptools_scm.version:no_guess_dev_version
only-version = setuptools_scm.version:only_version
post-release = setuptools_scm.version:postrelease_version
python-simplified-semver = setuptools_scm.version:simplified_semver_version
release-branch-semver = setuptools_scm.version:release_branch_semver_version

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\EGG-INFO\LICENSE
==================================================
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\EGG-INFO\PKG-INFO
==================================================
Metadata-Version: 2.1
Name: setuptools-scm
Version: 8.1.0
Summary: the blessed package to manage your versions by scm tags
Author-email: Ronny Pfannschmidt <opensource@ronnypfannschmidt.de>
License: Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:
        
        The above copyright notice and this permission notice shall be included in
        all copies or substantial portions of the Software.
        
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        THE SOFTWARE.
        
Project-URL: documentation, https://setuptools-scm.readthedocs.io/
Project-URL: repository, https://github.com/pypa/setuptools_scm/
Classifier: Development Status :: 5 - Production/Stable
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3 :: Only
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Topic :: Software Development :: Libraries
Classifier: Topic :: Software Development :: Version Control
Classifier: Topic :: System :: Software Distribution
Classifier: Topic :: Utilities
Requires-Python: >=3.8
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: packaging >=20
Requires-Dist: setuptools
Requires-Dist: typing-extensions ; python_version < "3.10"
Requires-Dist: tomli >=1 ; python_version < "3.11"
Provides-Extra: docs
Requires-Dist: entangled-cli ~=2.0 ; extra == 'docs'
Requires-Dist: mkdocs ; extra == 'docs'
Requires-Dist: mkdocs-entangled-plugin ; extra == 'docs'
Requires-Dist: mkdocs-material ; extra == 'docs'
Requires-Dist: mkdocstrings[python] ; extra == 'docs'
Requires-Dist: pygments ; extra == 'docs'
Provides-Extra: rich
Requires-Dist: rich ; extra == 'rich'
Provides-Extra: test
Requires-Dist: build ; extra == 'test'
Requires-Dist: pytest ; extra == 'test'
Requires-Dist: rich ; extra == 'test'
Requires-Dist: wheel ; extra == 'test'
Requires-Dist: typing-extensions ; (python_version < "3.11") and extra == 'test'
Provides-Extra: toml

# setuptools_scm
[![github ci](https://github.com/pypa/setuptools_scm/workflows/python%20tests+artifacts+release/badge.svg)](https://github.com/pypa/setuptools_scm/actions)
[![Documentation Status](https://readthedocs.org/projects/setuptools-scm/badge/?version=latest)](https://setuptools-scm.readthedocs.io/en/latest/?badge=latest)
[![tidelift](https://tidelift.com/badges/package/pypi/setuptools-scm) ](https://tidelift.com/subscription/pkg/pypi-setuptools-scm?utm_source=pypi-setuptools-scm&utm_medium=readme)

## about

[setuptools-scm] extracts Python package versions from `git` or
`hg` metadata instead of declaring them as the version argument
or in an SCM managed file.

Additionally, [setuptools-scm] provides setuptools
with a list of files that are managed by the SCM <br/>
(i.e. it automatically adds **all of** the SCM-managed files to the sdist).<br/>
Unwanted files must be excluded via `MANIFEST.in`.


## `pyproject.toml` usage

The preferred way to configure [setuptools-scm] is to author
settings in a `tool.setuptools_scm` section of `pyproject.toml`.

This feature requires setuptools 61 or later.
First, ensure that [setuptools-scm] is present during the project's
build step by specifying it as one of the build requirements.

```toml title="pyproject.toml"
[build-system]
requires = ["setuptools>=64", "setuptools_scm>=8"]
build-backend = "setuptools.build_meta"
```

That will be sufficient to require [setuptools-scm] for projects
that support [PEP 518] like [pip] and [build].

[pip]: https://pypi.org/project/pip
[build]: https://pypi.org/project/build
[PEP 518]: https://peps.python.org/pep-0518/


To enable version inference, you need to set the version
dynamically in the `project` section of `pyproject.toml`:

```toml title="pyproject.toml"
[project]
# version = "0.0.1"  # Remove any existing version parameter.
dynamic = ["version"]

[tool.setuptools_scm]
```

Additionally, a version file can be written by specifying:

```toml title="pyproject.toml"
[tool.setuptools_scm]
version_file = "pkg/_version.py"
```

Where `pkg` is the name of your package.

If you need to confirm which version string is being generated or debug the configuration,
you can install [setuptools-scm] directly in your working environment and run:

```console
$ python -m setuptools_scm
# To explore other options, try:
$ python -m setuptools_scm --help
```

For further configuration see the [documentation].

[setuptools-scm]: https://github.com/pypa/setuptools_scm
[documentation]: https://setuptools-scm.readthedocs.io/


## Interaction with Enterprise Distributions

Some enterprise distributions like RHEL7
ship rather old setuptools versions.

In those cases its typically possible to build by using an sdist against `setuptools_scm<2.0`.
As those old setuptools versions lack sensible types for versions,
modern [setuptools-scm] is unable to support them sensibly.

It's strongly recommended to build a wheel artifact using modern Python and setuptools,
then installing the artifact instead of trying to run against old setuptools versions.


## Code of Conduct


Everyone interacting in the [setuptools-scm] project's codebases, issue
trackers, chat rooms, and mailing lists is expected to follow the
[PSF Code of Conduct].

[PSF Code of Conduct]: https://github.com/pypa/.github/blob/main/CODE_OF_CONDUCT.md


## Security Contact

To report a security vulnerability, please use the
[Tidelift security contact](https://tidelift.com/security).
Tidelift will coordinate the fix and disclosure.

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\EGG-INFO\RECORD
==================================================
setuptools_scm/.git_archival.txt,sha256=2_90kdS1POSQMuZfBCUw6qNjObu7Ijp8DmptEAmlGkU,102
setuptools_scm/__init__.py,sha256=k4jjJK8ejFI95amIoLWNCFECWIQW9NlxF9Had4RqOHM,785
setuptools_scm/__main__.py,sha256=AhntzdNH3Jhcio_Ohoc6_EW7CuIN02OM-0irpGEXXh0,116
setuptools_scm/_cli.py,sha256=c1OtDXCGl7IzCdZ8z8yJg9TEBt1eXjh3mgqr16Qc5dQ,5597
setuptools_scm/_config.py,sha256=Zf9jOxr7BWQ8RN863MPOfzO6x8Os_pwYi7VuA0Bbr4U,4968
setuptools_scm/_entrypoints.py,sha256=GX3Lqs4YFUbQMa0mKCVYpXsfP8kR8nIuYbXRYkPaz7Y,3843
setuptools_scm/_get_version_impl.py,sha256=P72m2imnte-J7IXD3nTjYk7gBUoLk6hrZZv5O5r9akY,5940
setuptools_scm/_log.py,sha256=BFsXD-s2fcLV3zZaSQkQfRKPS-MjcI0tsmthJ3a2HqA,2137
setuptools_scm/_modify_version.py,sha256=9VU-juFg2IZjrcyz9kLGRfBq4RyZZElhjPMipqjB3Xc,1738
setuptools_scm/_overrides.py,sha256=2-ld0PSoi8IPVUAS3H2aBWM7yxJneDcyydq9ueQRdsE,1655
setuptools_scm/_run_cmd.py,sha256=6AB6Kv1kg75Yx6-p7NHMrXSWTCPWDAN5id8cSF8XW6s,6094
setuptools_scm/_types.py,sha256=QhY9jqXTH8sSxHXNQg2toQduk60s0vXya_Mdfv5rQAg,708
setuptools_scm/_version_cls.py,sha256=9wEWl4WY_sUvqZhN1PQbVETVq9OAQKu1Y47ZPg9vx-c,2925
setuptools_scm/discover.py,sha256=Kfm8S5I078vw8Cvbs9qpKOg5dr2TqBp1us-W579Dlts,2027
setuptools_scm/fallbacks.py,sha256=x3Xv1p89AqJiBX6oxuoo8Di0yR5ijOFOwKBJGAeWTbY,1448
setuptools_scm/git.py,sha256=-FbDzrVeEYd6jgEEzpWfuaeIfksS2QPktHZINXeSyzA,10526
setuptools_scm/hg.py,sha256=iY294X0ZOqLEv_KXmPWwXXsPDhgx4wsOVoxFkM9WiPc,6207
setuptools_scm/hg_git.py,sha256=hx2rq1kwW9Zs23xK9ZCn509emze22iyXvT3zIZh7JFM,4546
setuptools_scm/integration.py,sha256=0l04N6IhRKW32vD9DPvvJuiZ1HrVCYupmNYDcYXu8lQ,806
setuptools_scm/scm_workdir.py,sha256=oreoRhJfvhhxVGIhDPWH8-dg9umsmZM0sV2oRIzGXc8,327
setuptools_scm/version.py,sha256=TzdIjApX5t-aWBwGZoJLykpGWVVStRxH2Fui0RVVXvU,14215
setuptools_scm/_file_finders/__init__.py,sha256=QBZkrT7FLNfclH7taOohnNAPkVtaLJva3cHpX0sozbc,3751
setuptools_scm/_file_finders/git.py,sha256=vW_SGVGTXNFyC4dHOhNjh3ER2Aqp0QNe1qc0XLUIZEQ,4156
setuptools_scm/_file_finders/hg.py,sha256=1I4LPr_k7lIVMTqSl9_h1_csIEYMfRow2ta5FEo0Rjs,2246
setuptools_scm/_file_finders/pathtools.py,sha256=AgOl5u_WHxCQeiUCwlN8bUE3B4vs5BxSJEK1LJutyus,179
setuptools_scm/_integration/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
setuptools_scm/_integration/dump_version.py,sha256=2VYFa0Aa1YRcrQQVit-COg7w1QaRjmZFM22LYZWuvEg,2584
setuptools_scm/_integration/pyproject_reading.py,sha256=Wz-_ncjggrC-YfCsclIsSd2BkH0OYLdQhl9Insobpcg,2604
setuptools_scm/_integration/setuptools.py,sha256=DcYqpUUMMu_gD2XxdyY3enPFr12pqV9fZa06PuFqBSU,3468
setuptools_scm/_integration/toml.py,sha256=GYXDZOUC-AfQ_WmOIESP1ARBnc6WKIBQy3oDvsF-bUQ,1467
setuptools_scm-8.1.0.dist-info/LICENSE,sha256=iYB6zyMJvShfAzQE7nhYFgLzzZuBmhasLw5fYP9KRz4,1023
setuptools_scm-8.1.0.dist-info/METADATA,sha256=JstkuN1RJAjyijO1FYrd2ZfrphMgbl-j1LyiGmVbzrQ,6614
setuptools_scm-8.1.0.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
setuptools_scm-8.1.0.dist-info/entry_points.txt,sha256=7VjBrJmw12qwaWG0yLbRs5fYIf7g4ySdOwHNsJMhy4A,1776
setuptools_scm-8.1.0.dist-info/top_level.txt,sha256=kiu-91q3_rJLUoc2wl8_lC4cIlpgtgdD_4NaChF4hOA,15
setuptools_scm-8.1.0.dist-info/RECORD,,

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\EGG-INFO\requires.txt
==================================================
packaging>=20
setuptools

[docs]
entangled-cli~=2.0
mkdocs
mkdocs-entangled-plugin
mkdocs-material
mkdocstrings[python]
pygments

[rich]
rich

[test]
build
pytest
rich
wheel

[toml]

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\EGG-INFO\top_level.txt
==================================================
setuptools_scm

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\EGG-INFO\WHEEL
==================================================
Wheel-Version: 1.0
Generator: bdist_wheel (0.43.0)
Root-Is-Purelib: true
Tag: py3-none-any


==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\.git_archival.txt
==================================================
node: $Format:%H$
node-date: $Format:%cI$
describe-name: $Format:%(describe:tags=true,match=*[0-9]*)$

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\discover.py
==================================================
from __future__ import annotations

import os

from pathlib import Path
from typing import Iterable
from typing import Iterator

from . import _entrypoints
from . import _log
from . import _types as _t
from ._config import Configuration

log = _log.log.getChild("discover")


def walk_potential_roots(root: _t.PathT, search_parents: bool = True) -> Iterator[Path]:
    """
    Iterate though a path and each of its parents.
    :param root: File path.
    :param search_parents: If ``False`` the parents are not considered.
    """
    root = Path(root)
    yield root
    if search_parents:
        yield from root.parents


def match_entrypoint(root: _t.PathT, name: str) -> bool:
    """
    Consider a ``root`` as entry-point.
    :param root: File path.
    :param name: Subdirectory name.
    :return: ``True`` if a subdirectory ``name`` exits in ``root``.
    """

    if os.path.exists(os.path.join(root, name)):
        if not os.path.isabs(name):
            return True
        log.debug("ignoring bad ep %s", name)

    return False


# blocked entrypints from legacy plugins
_BLOCKED_EP_TARGETS = {"setuptools_scm_git_archive:parse"}


def iter_matching_entrypoints(
    root: _t.PathT, entrypoint: str, config: Configuration
) -> Iterable[_entrypoints.EntryPoint]:
    """
    Consider different entry-points in ``root`` and optionally its parents.
    :param root: File path.
    :param entrypoint: Entry-point to consider.
    :param config: Configuration,
        read ``search_parent_directories``, write found parent to ``parent``.
    """

    log.debug("looking for ep %s in %s", entrypoint, root)
    from ._entrypoints import iter_entry_points

    for wd in walk_potential_roots(root, config.search_parent_directories):
        for ep in iter_entry_points(entrypoint):
            if ep.value in _BLOCKED_EP_TARGETS:
                continue
            if match_entrypoint(wd, ep.name):
                log.debug("found ep %s in %s", ep, wd)
                config.parent = wd
                yield ep

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\fallbacks.py
==================================================
from __future__ import annotations

import logging
import os

from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from . import _types as _t
from . import Configuration
from .integration import data_from_mime
from .version import ScmVersion
from .version import meta
from .version import tag_to_version

log = logging.getLogger(__name__)

_UNKNOWN = "UNKNOWN"


def parse_pkginfo(root: _t.PathT, config: Configuration) -> ScmVersion | None:
    pkginfo = Path(root) / "PKG-INFO"
    log.debug("pkginfo %s", pkginfo)
    data = data_from_mime(pkginfo)
    version = data.get("Version", _UNKNOWN)
    if version != _UNKNOWN:
        return meta(version, preformatted=True, config=config)
    else:
        return None


def fallback_version(root: _t.PathT, config: Configuration) -> ScmVersion | None:
    if config.parentdir_prefix_version is not None:
        _, parent_name = os.path.split(os.path.abspath(root))
        if parent_name.startswith(config.parentdir_prefix_version):
            version = tag_to_version(
                parent_name[len(config.parentdir_prefix_version) :], config
            )
            if version is not None:
                return meta(str(version), preformatted=True, config=config)
    if config.fallback_version is not None:
        log.debug("FALLBACK %s", config.fallback_version)
        return meta(config.fallback_version, preformatted=True, config=config)
    return None

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\git.py
==================================================
from __future__ import annotations

import dataclasses
import logging
import os
import re
import shlex
import sys
import warnings

from datetime import date
from datetime import datetime
from datetime import timezone
from os.path import samefile
from pathlib import Path
from typing import TYPE_CHECKING
from typing import Callable
from typing import Sequence

from . import Configuration
from . import _types as _t
from . import discover
from ._run_cmd import CompletedProcess as _CompletedProcess
from ._run_cmd import require_command as _require_command
from ._run_cmd import run as _run
from .integration import data_from_mime
from .scm_workdir import Workdir
from .version import ScmVersion
from .version import meta
from .version import tag_to_version

if TYPE_CHECKING:
    from . import hg_git
log = logging.getLogger(__name__)

REF_TAG_RE = re.compile(r"(?<=\btag: )([^,]+)\b")
DESCRIBE_UNSUPPORTED = "%(describe"

# If testing command in shell make sure to quote the match argument like
# '*[0-9]*' as it will expand before being sent to git if there are any matching
# files in current directory.
DEFAULT_DESCRIBE = [
    "git",
    "describe",
    "--dirty",
    "--tags",
    "--long",
    "--match",
    "*[0-9]*",
]


def run_git(
    args: Sequence[str | os.PathLike[str]],
    repo: Path,
    *,
    check: bool = False,
    timeout: int | None = None,
) -> _CompletedProcess:
    return _run(
        ["git", "--git-dir", repo / ".git", *args],
        cwd=repo,
        check=check,
        timeout=timeout,
    )


class GitWorkdir(Workdir):
    """experimental, may change at any time"""

    @classmethod
    def from_potential_worktree(cls, wd: _t.PathT) -> GitWorkdir | None:
        wd = Path(wd).resolve()
        real_wd = run_git(["rev-parse", "--show-prefix"], wd).parse_success(parse=str)
        if real_wd is None:
            return None
        else:
            real_wd = real_wd[:-1]  # remove the trailing pathsep

        if not real_wd:
            real_wd = os.fspath(wd)
        else:
            str_wd = os.fspath(wd)
            assert str_wd.replace("\\", "/").endswith(real_wd)
            # In windows wd contains ``\`` which should be replaced by ``/``
            # for this assertion to work.  Length of string isn't changed by replace
            # ``\\`` is just and escape for `\`
            real_wd = str_wd[: -len(real_wd)]
        log.debug("real root %s", real_wd)
        if not samefile(real_wd, wd):
            return None

        return cls(Path(real_wd))

    def is_dirty(self) -> bool:
        return run_git(
            ["status", "--porcelain", "--untracked-files=no"], self.path
        ).parse_success(
            parse=bool,
            default=False,
        )

    def get_branch(self) -> str | None:
        return run_git(
            ["rev-parse", "--abbrev-ref", "HEAD"],
            self.path,
        ).parse_success(
            parse=str,
            error_msg="branch err (abbrev-err)",
        ) or run_git(
            ["symbolic-ref", "--short", "HEAD"],
            self.path,
        ).parse_success(
            parse=str,
            error_msg="branch err (symbolic-ref)",
        )

    def get_head_date(self) -> date | None:
        def parse_timestamp(timestamp_text: str) -> date | None:
            if "%c" in timestamp_text:
                log.warning("git too old -> timestamp is %r", timestamp_text)
                return None
            if sys.version_info < (3, 11) and timestamp_text.endswith("Z"):
                timestamp_text = timestamp_text[:-1] + "+00:00"
            return datetime.fromisoformat(timestamp_text).date()

        res = run_git(
            [
                *("-c", "log.showSignature=false"),
                *("log", "-n", "1", "HEAD"),
                "--format=%cI",
            ],
            self.path,
        )
        return res.parse_success(
            parse=parse_timestamp,
            error_msg="logging the iso date for head failed",
        )

    def is_shallow(self) -> bool:
        return self.path.joinpath(".git/shallow").is_file()

    def fetch_shallow(self) -> None:
        run_git(["fetch", "--unshallow"], self.path, check=True, timeout=240)

    def node(self) -> str | None:
        def _unsafe_short_node(node: str) -> str:
            return node[:7]

        return run_git(
            ["rev-parse", "--verify", "--quiet", "HEAD"], self.path
        ).parse_success(
            parse=_unsafe_short_node,
        )

    def count_all_nodes(self) -> int:
        res = run_git(["rev-list", "HEAD"], self.path)
        return res.stdout.count("\n") + 1

    def default_describe(self) -> _CompletedProcess:
        return run_git(DEFAULT_DESCRIBE[1:], self.path)


def warn_on_shallow(wd: GitWorkdir) -> None:
    """experimental, may change at any time"""
    if wd.is_shallow():
        warnings.warn(f'"{wd.path}" is shallow and may cause errors')


def fetch_on_shallow(wd: GitWorkdir) -> None:
    """experimental, may change at any time"""
    if wd.is_shallow():
        warnings.warn(f'"{wd.path}" was shallow, git fetch was used to rectify')
        wd.fetch_shallow()


def fail_on_shallow(wd: GitWorkdir) -> None:
    """experimental, may change at any time"""
    if wd.is_shallow():
        raise ValueError(
            f'{wd.path} is shallow, please correct with "git fetch --unshallow"'
        )


def get_working_directory(config: Configuration, root: _t.PathT) -> GitWorkdir | None:
    """
    Return the working directory (``GitWorkdir``).
    """

    if config.parent:  # todo broken
        return GitWorkdir.from_potential_worktree(config.parent)

    for potential_root in discover.walk_potential_roots(
        root, search_parents=config.search_parent_directories
    ):
        potential_wd = GitWorkdir.from_potential_worktree(potential_root)
        if potential_wd is not None:
            return potential_wd

    return GitWorkdir.from_potential_worktree(root)


def parse(
    root: _t.PathT,
    config: Configuration,
    describe_command: str | list[str] | None = None,
    pre_parse: Callable[[GitWorkdir], None] = warn_on_shallow,
) -> ScmVersion | None:
    """
    :param pre_parse: experimental pre_parse action, may change at any time
    """
    _require_command("git")
    wd = get_working_directory(config, root)
    if wd:
        return _git_parse_inner(
            config, wd, describe_command=describe_command, pre_parse=pre_parse
        )
    else:
        return None


def version_from_describe(
    wd: GitWorkdir | hg_git.GitWorkdirHgClient,
    config: Configuration,
    describe_command: _t.CMD_TYPE | None,
) -> ScmVersion | None:
    pass

    if config.git_describe_command is not None:
        describe_command = config.git_describe_command

    if describe_command is not None:
        if isinstance(describe_command, str):
            describe_command = shlex.split(describe_command)
            # todo: figure how to ensure git with gitdir gets correctly invoked
        if describe_command[0] == "git":
            describe_res = run_git(describe_command[1:], wd.path)
        else:
            describe_res = _run(describe_command, wd.path)
    else:
        describe_res = wd.default_describe()

    def parse_describe(output: str) -> ScmVersion:
        tag, distance, node, dirty = _git_parse_describe(output)
        return meta(tag=tag, distance=distance, dirty=dirty, node=node, config=config)

    return describe_res.parse_success(parse=parse_describe)


def _git_parse_inner(
    config: Configuration,
    wd: GitWorkdir | hg_git.GitWorkdirHgClient,
    pre_parse: None | (Callable[[GitWorkdir | hg_git.GitWorkdirHgClient], None]) = None,
    describe_command: _t.CMD_TYPE | None = None,
) -> ScmVersion:
    if pre_parse:
        pre_parse(wd)

    version = version_from_describe(wd, config, describe_command)

    if version is None:
        # If 'git git_describe_command' failed, try to get the information otherwise.
        tag = config.version_cls("0.0")
        node = wd.node()
        if node is None:
            distance = 0
            dirty = True
        else:
            distance = wd.count_all_nodes()
            node = "g" + node
            dirty = wd.is_dirty()
        version = meta(
            tag=tag, distance=distance, dirty=dirty, node=node, config=config
        )
    branch = wd.get_branch()
    node_date = wd.get_head_date() or datetime.now(timezone.utc).date()
    return dataclasses.replace(version, branch=branch, node_date=node_date)


def _git_parse_describe(
    describe_output: str,
) -> tuple[str, int, str | None, bool]:
    # 'describe_output' looks e.g. like 'v1.5.0-0-g4060507' or
    # 'v1.15.1rc1-37-g9bd1298-dirty'.
    # It may also just be a bare tag name if this is a tagged commit and we are
    # parsing a .git_archival.txt file.

    if describe_output.endswith("-dirty"):
        dirty = True
        describe_output = describe_output[:-6]
    else:
        dirty = False

    split = describe_output.rsplit("-", 2)
    if len(split) < 3:  # probably a tagged commit
        tag = describe_output
        number = 0
        node = None
    else:
        tag, number_, node = split
        number = int(number_)
    return tag, number, node, dirty


def archival_to_version(
    data: dict[str, str], config: Configuration
) -> ScmVersion | None:
    node: str | None
    log.debug("data %s", data)
    archival_describe = data.get("describe-name", DESCRIBE_UNSUPPORTED)
    if DESCRIBE_UNSUPPORTED in archival_describe:
        warnings.warn("git archive did not support describe output")
    else:
        tag, number, node, _ = _git_parse_describe(archival_describe)
        return meta(
            tag,
            config=config,
            distance=number,
            node=node,
        )

    for ref in REF_TAG_RE.findall(data.get("ref-names", "")):
        version = tag_to_version(ref, config)
        if version is not None:
            return meta(version, config=config)
    else:
        node = data.get("node")
        if node is None:
            return None
        elif "$FORMAT" in node.upper():
            warnings.warn("unprocessed git archival found (no export subst applied)")
            return None
        else:
            return meta("0.0", node=node, config=config)


def parse_archival(root: _t.PathT, config: Configuration) -> ScmVersion | None:
    archival = os.path.join(root, ".git_archival.txt")
    data = data_from_mime(archival)
    return archival_to_version(data, config=config)

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\hg.py
==================================================
from __future__ import annotations

import datetime
import logging
import os

from pathlib import Path
from typing import TYPE_CHECKING

from . import Configuration
from ._version_cls import Version
from .integration import data_from_mime
from .scm_workdir import Workdir
from .version import ScmVersion
from .version import meta
from .version import tag_to_version

if TYPE_CHECKING:
    from . import _types as _t

from ._run_cmd import require_command as _require_command
from ._run_cmd import run as _run

log = logging.getLogger(__name__)


class HgWorkdir(Workdir):
    @classmethod
    def from_potential_worktree(cls, wd: _t.PathT) -> HgWorkdir | None:
        res = _run(["hg", "root"], wd)
        if res.returncode:
            return None
        return cls(Path(res.stdout))

    def get_meta(self, config: Configuration) -> ScmVersion | None:
        node: str
        tags_str: str
        node_date_str: str
        node, tags_str, node_date_str = self.hg_log(
            ".", "{node}\n{tag}\n{date|shortdate}"
        ).split("\n")

        # TODO: support bookmarks and topics (but nowadays bookmarks are
        # mainly used to emulate Git branches, which is already supported with
        # the dedicated class GitWorkdirHgClient)

        branch, dirty_str, dirty_date = _run(
            ["hg", "id", "-T", "{branch}\n{if(dirty, 1, 0)}\n{date|shortdate}"],
            cwd=self.path,
            check=True,
        ).stdout.split("\n")
        dirty = bool(int(dirty_str))
        node_date = datetime.date.fromisoformat(dirty_date if dirty else node_date_str)

        if node == "0" * len(node):
            log.debug("initial node %s", self.path)
            return meta(
                Version("0.0"),
                config=config,
                dirty=dirty,
                branch=branch,
                node_date=node_date,
            )

        node = "h" + node[:7]

        tags = tags_str.split()
        if "tip" in tags:
            # tip is not a real tag
            tags.remove("tip")

        if tags:
            tag = tag_to_version(tags[0], config)
            if tag:
                return meta(tag, dirty=dirty, branch=branch, config=config)

        try:
            tag_str = self.get_latest_normalizable_tag()
            if tag_str is None:
                dist = self.get_distance_revs("")
            else:
                dist = self.get_distance_revs(tag_str)

            if tag_str == "null" or tag_str is None:
                tag = Version("0.0")
                dist += 1
            else:
                tag = tag_to_version(tag_str, config=config)
                assert tag is not None

            if self.check_changes_since_tag(tag_str) or dirty:
                return meta(
                    tag,
                    distance=dist,
                    node=node,
                    dirty=dirty,
                    branch=branch,
                    config=config,
                    node_date=node_date,
                )
            else:
                return meta(tag, config=config, node_date=node_date)

        except ValueError as e:
            log.exception("error %s", e)
            pass  # unpacking failed, old hg

        return None

    def hg_log(self, revset: str, template: str) -> str:
        cmd = ["hg", "log", "-r", revset, "-T", template]

        return _run(cmd, cwd=self.path, check=True).stdout

    def get_latest_normalizable_tag(self) -> str | None:
        # Gets all tags containing a '.' (see #229) from oldest to newest
        outlines = self.hg_log(
            revset="ancestors(.) and tag('re:\\.')",
            template="{tags}{if(tags, '\n', '')}",
        ).split()
        if not outlines:
            return None
        tag = outlines[-1].split()[-1]
        return tag

    def get_distance_revs(self, rev1: str, rev2: str = ".") -> int:
        revset = f"({rev1}::{rev2})"
        out = self.hg_log(revset, ".")
        return len(out) - 1

    def check_changes_since_tag(self, tag: str | None) -> bool:
        if tag == "0.0" or tag is None:
            return True

        revset = (
            "(branch(.)"  # look for revisions in this branch only
            f" and tag({tag!r})::."  # after the last tag
            # ignore commits that only modify .hgtags and nothing else:
            " and (merge() or file('re:^(?!\\.hgtags).*$'))"
            f" and not tag({tag!r}))"  # ignore the tagged commit itself
        )

        return bool(self.hg_log(revset, "."))


def parse(root: _t.PathT, config: Configuration) -> ScmVersion | None:
    _require_command("hg")
    if os.path.exists(os.path.join(root, ".hg/git")):
        res = _run(["hg", "path"], root)
        if not res.returncode:
            for line in res.stdout.split("\n"):
                if line.startswith("default ="):
                    path = Path(line.split()[2])
                    if path.name.endswith(".git") or (path / ".git").exists():
                        from .git import _git_parse_inner
                        from .hg_git import GitWorkdirHgClient

                        wd_hggit = GitWorkdirHgClient.from_potential_worktree(root)
                        if wd_hggit:
                            return _git_parse_inner(config, wd_hggit)

    wd = HgWorkdir.from_potential_worktree(config.absolute_root)

    if wd is None:
        return None

    return wd.get_meta(config)


def archival_to_version(data: dict[str, str], config: Configuration) -> ScmVersion:
    log.debug("data %s", data)
    node = data.get("node", "")[:12]
    if node:
        node = "h" + node
    if "tag" in data:
        return meta(data["tag"], config=config)
    elif "latesttag" in data:
        return meta(
            data["latesttag"],
            distance=int(data["latesttagdistance"]),
            node=node,
            branch=data.get("branch"),
            config=config,
        )
    else:
        return meta(config.version_cls("0.0"), node=node, config=config)


def parse_archival(root: _t.PathT, config: Configuration) -> ScmVersion:
    archival = os.path.join(root, ".hg_archival.txt")
    data = data_from_mime(archival)
    return archival_to_version(data, config=config)

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\hg_git.py
==================================================
from __future__ import annotations

import logging
import os

from contextlib import suppress
from datetime import date
from pathlib import Path

from . import _types as _t
from ._run_cmd import CompletedProcess as _CompletedProcess
from ._run_cmd import require_command
from ._run_cmd import run as _run
from .git import GitWorkdir
from .hg import HgWorkdir

log = logging.getLogger(__name__)

_FAKE_GIT_DESCRIBE_ERROR = _CompletedProcess(
    "fake git describe output for hg",
    1,
    "<>hg git failed to describe",
)


class GitWorkdirHgClient(GitWorkdir, HgWorkdir):
    COMMAND = "hg"

    @classmethod
    def from_potential_worktree(cls, wd: _t.PathT) -> GitWorkdirHgClient | None:
        require_command("hg")
        res = _run(["hg", "root"], cwd=wd).parse_success(parse=Path)
        if res is None:
            return None
        return cls(res)

    def is_dirty(self) -> bool:
        res = _run(["hg", "id", "-T", "{dirty}"], cwd=self.path, check=True)
        return bool(res.stdout)

    def get_branch(self) -> str | None:
        res = _run(["hg", "id", "-T", "{bookmarks}"], cwd=self.path)
        if res.returncode:
            log.info("branch err %s", res)
            return None
        return res.stdout

    def get_head_date(self) -> date | None:
        return _run('hg log -r . -T "{shortdate(date)}"', cwd=self.path).parse_success(
            parse=date.fromisoformat, error_msg="head date err"
        )

    def is_shallow(self) -> bool:
        return False

    def fetch_shallow(self) -> None:
        pass

    def get_hg_node(self) -> str | None:
        res = _run('hg log -r . -T "{node}"', cwd=self.path)
        if res.returncode:
            return None
        else:
            return res.stdout

    def _hg2git(self, hg_node: str) -> str | None:
        with suppress(FileNotFoundError):
            with open(os.path.join(self.path, ".hg/git-mapfile")) as map_items:
                for item in map_items:
                    if hg_node in item:
                        git_node, hg_node = item.split()
                        return git_node
        return None

    def node(self) -> str | None:
        hg_node = self.get_hg_node()
        if hg_node is None:
            return None

        git_node = self._hg2git(hg_node)

        if git_node is None:
            # trying again after hg -> git
            _run(["hg", "gexport"], cwd=self.path)
            git_node = self._hg2git(hg_node)

            if git_node is None:
                log.debug("Cannot get git node so we use hg node %s", hg_node)

                if hg_node == "0" * len(hg_node):
                    # mimic Git behavior
                    return None

                return hg_node

        return git_node[:7]

    def count_all_nodes(self) -> int:
        res = _run(["hg", "log", "-r", "ancestors(.)", "-T", "."], cwd=self.path)
        return len(res.stdout)

    def default_describe(self) -> _CompletedProcess:
        """
        Tentative to reproduce the output of

        `git describe --dirty --tags --long --match *[0-9]*`

        """
        res = _run(
            [
                "hg",
                "log",
                "-r",
                "(reverse(ancestors(.)) and tag(r're:v?[0-9].*'))",
                "-T",
                "{tags}{if(tags, ' ', '')}",
            ],
            cwd=self.path,
        )
        if res.returncode:
            return _FAKE_GIT_DESCRIBE_ERROR
        hg_tags: list[str] = res.stdout.split()

        if not hg_tags:
            return _FAKE_GIT_DESCRIBE_ERROR

        with self.path.joinpath(".hg/git-tags").open() as fp:
            git_tags: dict[str, str] = dict(line.split()[::-1] for line in fp)

        tag: str
        for hg_tag in hg_tags:
            if hg_tag in git_tags:
                tag = hg_tag
                break
        else:
            logging.warning("tag not found hg=%s git=%s", hg_tags, git_tags)
            return _FAKE_GIT_DESCRIBE_ERROR

        res = _run(["hg", "log", "-r", f"'{tag}'::.", "-T", "."], cwd=self.path)
        if res.returncode:
            return _FAKE_GIT_DESCRIBE_ERROR
        distance = len(res.stdout) - 1

        node = self.node()
        assert node is not None
        desc = f"{tag}-{distance}-g{node}"

        if self.is_dirty():
            desc += "-dirty"
        log.debug("faked describe %r", desc)
        return _CompletedProcess(
            ["setuptools-scm", "faked", "describe"],
            returncode=0,
            stdout=desc,
            stderr="",
        )

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\integration.py
==================================================
from __future__ import annotations

import logging
import textwrap

from pathlib import Path

from . import _types as _t

log = logging.getLogger(__name__)


def data_from_mime(path: _t.PathT, content: None | str = None) -> dict[str, str]:
    """return a mapping from mime/pseudo-mime content
    :param path: path to the mime file
    :param content: content of the mime file, if None, read from path
    :rtype: dict[str, str]

    """

    if content is None:
        content = Path(path).read_text(encoding="utf-8")
    log.debug("mime %s content:\n%s", path, textwrap.indent(content, "    "))

    from email.parser import HeaderParser

    parser = HeaderParser()
    message = parser.parsestr(content)
    data = dict(message.items())
    log.debug("mime %s data:\n%s", path, data)
    return data

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\scm_workdir.py
==================================================
from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path

from ._config import Configuration
from .version import ScmVersion


@dataclass()
class Workdir:
    path: Path

    def run_describe(self, config: Configuration) -> ScmVersion:
        raise NotImplementedError(self.run_describe)

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\version.py
==================================================
from __future__ import annotations

import dataclasses
import logging
import os
import re
import warnings

from datetime import date
from datetime import datetime
from datetime import timezone
from typing import TYPE_CHECKING
from typing import Any
from typing import Callable
from typing import Match

from . import _entrypoints
from . import _modify_version

if TYPE_CHECKING:
    import sys

    if sys.version_info >= (3, 10):
        from typing import Concatenate
        from typing import ParamSpec
    else:
        from typing_extensions import Concatenate
        from typing_extensions import ParamSpec

    _P = ParamSpec("_P")

from typing import TypedDict

from . import _config
from . import _version_cls as _v
from ._version_cls import Version as PkgVersion
from ._version_cls import _VersionT

log = logging.getLogger(__name__)


SEMVER_MINOR = 2
SEMVER_PATCH = 3
SEMVER_LEN = 3


class _TagDict(TypedDict):
    version: str
    prefix: str
    suffix: str


def _parse_version_tag(
    tag: str | object, config: _config.Configuration
) -> _TagDict | None:
    match = config.tag_regex.match(str(tag))

    if match:
        key: str | int = 1 if len(match.groups()) == 1 else "version"
        full = match.group(0)
        log.debug("%r %r %s", tag, config.tag_regex, match)
        log.debug(
            "key %s data %s, %s, %r", key, match.groupdict(), match.groups(), full
        )
        result = _TagDict(
            version=match.group(key),
            prefix=full[: match.start(key)],
            suffix=full[match.end(key) :],
        )

        log.debug("tag %r parsed to %r", tag, result)
        assert result["version"]
        return result
    else:
        log.debug("tag %r did not parse", tag)

        return None


def callable_or_entrypoint(group: str, callable_or_name: str | Any) -> Any:
    log.debug("ep %r %r", group, callable_or_name)

    if callable(callable_or_name):
        return callable_or_name
    from ._entrypoints import iter_entry_points

    for ep in iter_entry_points(group, callable_or_name):
        log.debug("ep found: %s", ep.name)
        return ep.load()


def tag_to_version(
    tag: _VersionT | str, config: _config.Configuration
) -> _VersionT | None:
    """
    take a tag that might be prefixed with a keyword and return only the version part
    """
    log.debug("tag %s", tag)

    tag_dict = _parse_version_tag(tag, config)
    if tag_dict is None or not tag_dict.get("version", None):
        warnings.warn(f"tag {tag!r} no version found")
        return None

    version_str = tag_dict["version"]
    log.debug("version pre parse %s", version_str)

    if suffix := tag_dict.get("suffix", ""):
        warnings.warn(f"tag {tag!r} will be stripped of its suffix {suffix!r}")

    version: _VersionT = config.version_cls(version_str)
    log.debug("version=%r", version)

    return version


def _source_epoch_or_utc_now() -> datetime:
    if "SOURCE_DATE_EPOCH" in os.environ:
        date_epoch = int(os.environ["SOURCE_DATE_EPOCH"])
        return datetime.fromtimestamp(date_epoch, timezone.utc)
    else:
        return datetime.now(timezone.utc)


@dataclasses.dataclass
class ScmVersion:
    """represents a parsed version from scm"""

    tag: _v.Version | _v.NonNormalizedVersion | str
    """the related tag or preformatted version string"""
    config: _config.Configuration
    """the configuration used to parse the version"""
    distance: int = 0
    """the number of commits since the tag"""
    node: str | None = None
    """the shortened node id"""
    dirty: bool = False
    """whether the working copy had uncommitted changes"""
    preformatted: bool = False
    """whether the version string was preformatted"""
    branch: str | None = None
    """the branch name if any"""
    node_date: date | None = None
    """the date of the commit if available"""
    time: datetime = dataclasses.field(default_factory=_source_epoch_or_utc_now)
    """the current time or source epoch time
    only set for unit-testing version schemes
    for real usage it must be `now(utc)` or `SOURCE_EPOCH`
    """

    @property
    def exact(self) -> bool:
        """returns true checked out exactly on a tag and no local changes apply"""
        return self.distance == 0 and not self.dirty

    def __repr__(self) -> str:
        return (
            f"<ScmVersion {self.tag} dist={self.distance} "
            f"node={self.node} dirty={self.dirty} branch={self.branch}>"
        )

    def format_with(self, fmt: str, **kw: object) -> str:
        """format a given format string with attributes of this object"""
        return fmt.format(
            time=self.time,
            tag=self.tag,
            distance=self.distance,
            node=self.node,
            dirty=self.dirty,
            branch=self.branch,
            node_date=self.node_date,
            **kw,
        )

    def format_choice(self, clean_format: str, dirty_format: str, **kw: object) -> str:
        """given `clean_format` and `dirty_format`

        choose one based on `self.dirty` and format it using `self.format_with`"""

        return self.format_with(dirty_format if self.dirty else clean_format, **kw)

    def format_next_version(
        self,
        guess_next: Callable[Concatenate[ScmVersion, _P], str],
        fmt: str = "{guessed}.dev{distance}",
        *k: _P.args,
        **kw: _P.kwargs,
    ) -> str:
        guessed = guess_next(self, *k, **kw)
        return self.format_with(fmt, guessed=guessed)


def _parse_tag(
    tag: _VersionT | str, preformatted: bool, config: _config.Configuration
) -> _VersionT | str:
    if preformatted:
        return tag
    elif not isinstance(tag, config.version_cls):
        version = tag_to_version(tag, config)
        assert version is not None
        return version
    else:
        return tag


def meta(
    tag: str | _VersionT,
    *,
    distance: int = 0,
    dirty: bool = False,
    node: str | None = None,
    preformatted: bool = False,
    branch: str | None = None,
    config: _config.Configuration,
    node_date: date | None = None,
) -> ScmVersion:
    parsed_version = _parse_tag(tag, preformatted, config)
    log.info("version %s -> %s", tag, parsed_version)
    assert parsed_version is not None, "Can't parse version %s" % tag
    return ScmVersion(
        parsed_version,
        distance=distance,
        node=node,
        dirty=dirty,
        preformatted=preformatted,
        branch=branch,
        config=config,
        node_date=node_date,
    )


def guess_next_version(tag_version: ScmVersion) -> str:
    version = _modify_version.strip_local(str(tag_version.tag))
    return _modify_version._bump_dev(version) or _modify_version._bump_regex(version)


def guess_next_dev_version(version: ScmVersion) -> str:
    if version.exact:
        return version.format_with("{tag}")
    else:
        return version.format_next_version(guess_next_version)


def guess_next_simple_semver(
    version: ScmVersion, retain: int, increment: bool = True
) -> str:
    if isinstance(version.tag, _v.Version):
        parts = list(version.tag.release[:retain])
    else:
        try:
            parts = [int(i) for i in str(version.tag).split(".")[:retain]]
        except ValueError:
            raise ValueError(f"{version} can't be parsed as numeric version") from None
    while len(parts) < retain:
        parts.append(0)
    if increment:
        parts[-1] += 1
    while len(parts) < SEMVER_LEN:
        parts.append(0)
    return ".".join(str(i) for i in parts)


def simplified_semver_version(version: ScmVersion) -> str:
    if version.exact:
        return guess_next_simple_semver(version, retain=SEMVER_LEN, increment=False)
    else:
        if version.branch is not None and "feature" in version.branch:
            return version.format_next_version(
                guess_next_simple_semver, retain=SEMVER_MINOR
            )
        else:
            return version.format_next_version(
                guess_next_simple_semver, retain=SEMVER_PATCH
            )


def release_branch_semver_version(version: ScmVersion) -> str:
    if version.exact:
        return version.format_with("{tag}")
    if version.branch is not None:
        # Does the branch name (stripped of namespace) parse as a version?
        branch_ver_data = _parse_version_tag(
            version.branch.split("/")[-1], version.config
        )
        if branch_ver_data is not None:
            branch_ver = branch_ver_data["version"]
            if branch_ver[0] == "v":
                # Allow branches that start with 'v', similar to Version.
                branch_ver = branch_ver[1:]
            # Does the branch version up to the minor part match the tag? If not it
            # might be like, an issue number or something and not a version number, so
            # we only want to use it if it matches.
            tag_ver_up_to_minor = str(version.tag).split(".")[:SEMVER_MINOR]
            branch_ver_up_to_minor = branch_ver.split(".")[:SEMVER_MINOR]
            if branch_ver_up_to_minor == tag_ver_up_to_minor:
                # We're in a release/maintenance branch, next is a patch/rc/beta bump:
                return version.format_next_version(guess_next_version)
    # We're in a development branch, next is a minor bump:
    return version.format_next_version(guess_next_simple_semver, retain=SEMVER_MINOR)


def release_branch_semver(version: ScmVersion) -> str:
    warnings.warn(
        "release_branch_semver is deprecated and will be removed in the future. "
        "Use release_branch_semver_version instead",
        category=DeprecationWarning,
        stacklevel=2,
    )
    return release_branch_semver_version(version)


def only_version(version: ScmVersion) -> str:
    return version.format_with("{tag}")


def no_guess_dev_version(version: ScmVersion) -> str:
    if version.exact:
        return version.format_with("{tag}")
    else:
        return version.format_next_version(_modify_version._dont_guess_next_version)


_DATE_REGEX = re.compile(
    r"""
    ^(?P<date>
        (?P<prefix>[vV]?)
        (?P<year>\d{2}|\d{4})(?:\.\d{1,2}){2})
        (?:\.(?P<patch>\d*))?$
    """,
    re.VERBOSE,
)


def date_ver_match(ver: str) -> Match[str] | None:
    return _DATE_REGEX.match(ver)


def guess_next_date_ver(
    version: ScmVersion,
    node_date: date | None = None,
    date_fmt: str | None = None,
    version_cls: type | None = None,
) -> str:
    """
    same-day -> patch +1
    other-day -> today

    distance is always added as .devX
    """
    match = date_ver_match(str(version.tag))
    if match is None:
        warnings.warn(
            f"{version} does not correspond to a valid versioning date, "
            "assuming legacy version"
        )
        if date_fmt is None:
            date_fmt = "%y.%m.%d"
    else:
        # deduct date format if not provided
        if date_fmt is None:
            date_fmt = "%Y.%m.%d" if len(match.group("year")) == 4 else "%y.%m.%d"
        if prefix := match.group("prefix"):
            if not date_fmt.startswith(prefix):
                date_fmt = prefix + date_fmt

    today = version.time.date()
    head_date = node_date or today
    # compute patch
    if match is None:
        tag_date = today
    else:
        tag_date = (
            datetime.strptime(match.group("date"), date_fmt)
            .replace(tzinfo=timezone.utc)
            .date()
        )
    if tag_date == head_date:
        patch = "0" if match is None else (match.group("patch") or "0")
        patch = int(patch) + 1
    else:
        if tag_date > head_date and match is not None:
            # warn on future times
            warnings.warn(
                f"your previous tag  ({tag_date})"
                f" is ahead your node date ({head_date})"
            )
        patch = 0
    next_version = "{node_date:{date_fmt}}.{patch}".format(
        node_date=head_date, date_fmt=date_fmt, patch=patch
    )
    # rely on the Version object to ensure consistency (e.g. remove leading 0s)
    if version_cls is None:
        version_cls = PkgVersion
    next_version = str(version_cls(next_version))
    return next_version


def calver_by_date(version: ScmVersion) -> str:
    if version.exact and not version.dirty:
        return version.format_with("{tag}")
    # TODO: move the release-X check to a new scheme
    if version.branch is not None and version.branch.startswith("release-"):
        branch_ver = _parse_version_tag(version.branch.split("-")[-1], version.config)
        if branch_ver is not None:
            ver = branch_ver["version"]
            match = date_ver_match(ver)
            if match:
                return ver
    return version.format_next_version(
        guess_next_date_ver,
        node_date=version.node_date,
        version_cls=version.config.version_cls,
    )


def get_local_node_and_date(version: ScmVersion) -> str:
    return _modify_version._format_local_with_time(version, time_format="%Y%m%d")


def get_local_node_and_timestamp(version: ScmVersion) -> str:
    return _modify_version._format_local_with_time(version, time_format="%Y%m%d%H%M%S")


def get_local_dirty_tag(version: ScmVersion) -> str:
    return version.format_choice("", "+dirty")


def get_no_local_node(version: ScmVersion) -> str:
    return ""


def postrelease_version(version: ScmVersion) -> str:
    if version.exact:
        return version.format_with("{tag}")
    else:
        return version.format_with("{tag}.post{distance}")


def format_version(version: ScmVersion) -> str:
    log.debug("scm version %s", version)
    log.debug("config %s", version.config)
    if version.preformatted:
        assert isinstance(version.tag, str)
        return version.tag
    main_version = _entrypoints._call_version_scheme(
        version, "setuptools_scm.version_scheme", version.config.version_scheme, None
    )
    log.debug("version %s", main_version)
    assert main_version is not None
    local_version = _entrypoints._call_version_scheme(
        version, "setuptools_scm.local_scheme", version.config.local_scheme, "+unknown"
    )
    log.debug("local_version %s", local_version)
    return main_version + local_version

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\_cli.py
==================================================
from __future__ import annotations

import argparse
import json
import os
import sys

from typing import Any

from setuptools_scm import Configuration
from setuptools_scm._file_finders import find_files
from setuptools_scm._get_version_impl import _get_version
from setuptools_scm.discover import walk_potential_roots


def main(args: list[str] | None = None) -> int:
    opts = _get_cli_opts(args)
    inferred_root: str = opts.root or "."

    pyproject = opts.config or _find_pyproject(inferred_root)

    try:
        config = Configuration.from_file(
            pyproject,
            root=(os.path.abspath(opts.root) if opts.root is not None else None),
        )
    except (LookupError, FileNotFoundError) as ex:
        # no pyproject.toml OR no [tool.setuptools_scm]
        print(
            f"Warning: could not use {os.path.relpath(pyproject)},"
            " using default configuration.\n"
            f" Reason: {ex}.",
            file=sys.stderr,
        )
        config = Configuration(root=inferred_root)

    version = _get_version(
        config, force_write_version_files=opts.force_write_version_files
    )
    if version is None:
        raise SystemExit("ERROR: no version found for", opts)
    if opts.strip_dev:
        version = version.partition(".dev")[0]

    return command(opts, version, config)


def _get_cli_opts(args: list[str] | None) -> argparse.Namespace:
    prog = "python -m setuptools_scm"
    desc = "Print project version according to SCM metadata"
    parser = argparse.ArgumentParser(prog, description=desc)
    # By default, help for `--help` starts with lower case, so we keep the pattern:
    parser.add_argument(
        "-r",
        "--root",
        default=None,
        help='directory managed by the SCM, default: inferred from config file, or "."',
    )
    parser.add_argument(
        "-c",
        "--config",
        default=None,
        metavar="PATH",
        help="path to 'pyproject.toml' with setuptools_scm config, "
        "default: looked up in the current or parent directories",
    )
    parser.add_argument(
        "--strip-dev",
        action="store_true",
        help="remove the dev/local parts of the version before printing the version",
    )
    parser.add_argument(
        "-N",
        "--no-version",
        action="store_true",
        help="do not include package version in the output",
    )
    output_formats = ["json", "plain", "key-value"]
    parser.add_argument(
        "-f",
        "--format",
        type=str.casefold,
        default="plain",
        help="specify output format",
        choices=output_formats,
    )
    parser.add_argument(
        "-q",
        "--query",
        type=str.casefold,
        nargs="*",
        help="display setuptools_scm settings according to query, "
        "e.g. dist_name, do not supply an argument in order to "
        "print a list of valid queries.",
    )
    parser.add_argument(
        "--force-write-version-files",
        action="store_true",
        help="trigger to write the content of the version files\n"
        "its recommended to use normal/editable installation instead)",
    )
    sub = parser.add_subparsers(title="extra commands", dest="command", metavar="")
    # We avoid `metavar` to prevent printing repetitive information
    desc = "List information about the package, e.g. included files"
    sub.add_parser("ls", help=desc[0].lower() + desc[1:], description=desc)
    return parser.parse_args(args)


# flake8: noqa: C901
def command(opts: argparse.Namespace, version: str, config: Configuration) -> int:
    data: dict[str, Any] = {}

    if opts.command == "ls":
        opts.query = ["files"]

    if opts.query == []:
        opts.no_version = True
        sys.stderr.write("Available queries:\n\n")
        opts.query = ["queries"]
        data["queries"] = ["files", *config.__dataclass_fields__]

    if opts.query is None:
        opts.query = []

    if not opts.no_version:
        data["version"] = version

    if "files" in opts.query:
        data["files"] = find_files(config.root)

    for q in opts.query:
        if q in ["files", "queries", "version"]:
            continue

        try:
            if q.startswith("_"):
                raise AttributeError()
            data[q] = getattr(config, q)
        except AttributeError:
            sys.stderr.write(f"Error: unknown query: '{q}'\n")
            return 1

    if opts.format == "json":
        print(json.dumps(data, indent=2))

    if opts.format == "plain":
        _print_plain(data)

    if opts.format == "key-value":
        _print_key_value(data)

    return 0


def _print_plain(data: dict[str, Any]) -> None:
    version = data.pop("version", None)
    if version:
        print(version)
    files = data.pop("files", [])
    for file_ in files:
        print(file_)
    queries = data.pop("queries", [])
    for query in queries:
        print(query)
    if data:
        print("\n".join(data.values()))


def _print_key_value(data: dict[str, Any]) -> None:
    for key, value in data.items():
        if isinstance(value, str):
            print(f"{key} = {value}")
        else:
            str_value = "\n  ".join(value)
            print(f"{key} = {str_value}")


def _find_pyproject(parent: str) -> str:
    for directory in walk_potential_roots(os.path.abspath(parent)):
        pyproject = os.path.join(directory, "pyproject.toml")
        if os.path.isfile(pyproject):
            return pyproject

    return os.path.abspath(
        "pyproject.toml"
    )  # use default name to trigger the default errors

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\_config.py
==================================================
"""configuration"""

from __future__ import annotations

import dataclasses
import os
import re
import warnings

from pathlib import Path
from typing import Any
from typing import Pattern
from typing import Protocol

from . import _log
from . import _types as _t
from ._integration.pyproject_reading import (
    get_args_for_pyproject as _get_args_for_pyproject,
)
from ._integration.pyproject_reading import read_pyproject as _read_pyproject
from ._overrides import read_toml_overrides
from ._version_cls import Version as _Version
from ._version_cls import _validate_version_cls
from ._version_cls import _VersionT

log = _log.log.getChild("config")

DEFAULT_TAG_REGEX = re.compile(
    r"^(?:[\w-]+-)?(?P<version>[vV]?\d+(?:\.\d+){0,2}[^\+]*)(?:\+.*)?$"
)
"""default tag regex that tries to match PEP440 style versions
with prefix consisting of dashed words"""

DEFAULT_VERSION_SCHEME = "guess-next-dev"
DEFAULT_LOCAL_SCHEME = "node-and-date"


def _check_tag_regex(value: str | Pattern[str] | None) -> Pattern[str]:
    if not value:
        regex = DEFAULT_TAG_REGEX
    else:
        regex = re.compile(value)

    group_names = regex.groupindex.keys()
    if regex.groups == 0 or (regex.groups > 1 and "version" not in group_names):
        warnings.warn(
            "Expected tag_regex to contain a single match group or a group named"
            " 'version' to identify the version part of any tag."
        )

    return regex


class ParseFunction(Protocol):
    def __call__(
        self, root: _t.PathT, *, config: Configuration
    ) -> _t.SCMVERSION | None: ...


def _check_absolute_root(root: _t.PathT, relative_to: _t.PathT | None) -> str:
    log.debug("check absolute root=%s relative_to=%s", root, relative_to)
    if relative_to:
        if (
            os.path.isabs(root)
            and os.path.isabs(relative_to)
            and not os.path.commonpath([root, relative_to]) == root
        ):
            warnings.warn(
                f"absolute root path '{root}' overrides relative_to '{relative_to}'"
            )
        if os.path.isdir(relative_to):
            warnings.warn(
                "relative_to is expected to be a file,"
                f" its the directory {relative_to}\n"
                "assuming the parent directory was passed"
            )
            log.debug("dir %s", relative_to)
            root = os.path.join(relative_to, root)
        else:
            log.debug("file %s", relative_to)
            root = os.path.join(os.path.dirname(relative_to), root)
    return os.path.abspath(root)


@dataclasses.dataclass
class Configuration:
    """Global configuration model"""

    relative_to: _t.PathT | None = None
    root: _t.PathT = "."
    version_scheme: _t.VERSION_SCHEME = DEFAULT_VERSION_SCHEME
    local_scheme: _t.VERSION_SCHEME = DEFAULT_LOCAL_SCHEME
    tag_regex: Pattern[str] = DEFAULT_TAG_REGEX
    parentdir_prefix_version: str | None = None
    fallback_version: str | None = None
    fallback_root: _t.PathT = "."
    write_to: _t.PathT | None = None
    write_to_template: str | None = None
    version_file: _t.PathT | None = None
    version_file_template: str | None = None
    parse: ParseFunction | None = None
    git_describe_command: _t.CMD_TYPE | None = None
    dist_name: str | None = None
    version_cls: type[_VersionT] = _Version
    search_parent_directories: bool = False

    parent: _t.PathT | None = None

    @property
    def absolute_root(self) -> str:
        return _check_absolute_root(self.root, self.relative_to)

    @classmethod
    def from_file(
        cls,
        name: str | os.PathLike[str] = "pyproject.toml",
        dist_name: str | None = None,
        _require_section: bool = True,
        **kwargs: Any,
    ) -> Configuration:
        """
        Read Configuration from pyproject.toml (or similar).
        Raises exceptions when file is not found or toml is
        not installed or the file has invalid format or does
        not contain the [tool.setuptools_scm] section.
        """

        pyproject_data = _read_pyproject(Path(name), require_section=_require_section)
        args = _get_args_for_pyproject(pyproject_data, dist_name, kwargs)

        args.update(read_toml_overrides(args["dist_name"]))
        relative_to = args.pop("relative_to", name)
        return cls.from_data(relative_to=relative_to, data=args)

    @classmethod
    def from_data(
        cls, relative_to: str | os.PathLike[str], data: dict[str, Any]
    ) -> Configuration:
        """
        given configuration data
        create a config instance after validating tag regex/version class
        """
        tag_regex = _check_tag_regex(data.pop("tag_regex", None))
        version_cls = _validate_version_cls(
            data.pop("version_cls", None), data.pop("normalize", True)
        )
        return cls(
            relative_to=relative_to,
            version_cls=version_cls,
            tag_regex=tag_regex,
            **data,
        )

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\_entrypoints.py
==================================================
from __future__ import annotations

import sys

from typing import TYPE_CHECKING
from typing import Any
from typing import Callable
from typing import Iterator
from typing import cast
from typing import overload

from . import _log
from . import version

if TYPE_CHECKING:
    from . import _types as _t
    from ._config import Configuration
    from ._config import ParseFunction


from importlib.metadata import EntryPoint as EntryPoint

if sys.version_info[:2] < (3, 10):
    from importlib.metadata import entry_points as legacy_entry_points

    class EntryPoints:
        _groupdata: list[EntryPoint]

        def __init__(self, groupdata: list[EntryPoint]) -> None:
            self._groupdata = groupdata

        def select(self, name: str) -> EntryPoints:
            return EntryPoints([x for x in self._groupdata if x.name == name])

        def __iter__(self) -> Iterator[EntryPoint]:
            return iter(self._groupdata)

    def entry_points(group: str) -> EntryPoints:
        return EntryPoints(legacy_entry_points()[group])

else:
    from importlib.metadata import EntryPoints
    from importlib.metadata import entry_points


log = _log.log.getChild("entrypoints")


def version_from_entrypoint(
    config: Configuration, *, entrypoint: str, root: _t.PathT
) -> version.ScmVersion | None:
    from .discover import iter_matching_entrypoints

    log.debug("version_from_ep %s in %s", entrypoint, root)
    for ep in iter_matching_entrypoints(root, entrypoint, config):
        fn: ParseFunction = ep.load()
        maybe_version: version.ScmVersion | None = fn(root, config=config)
        log.debug("%s found %r", ep, maybe_version)
        if maybe_version is not None:
            return maybe_version
    return None


def iter_entry_points(group: str, name: str | None = None) -> Iterator[EntryPoint]:
    eps: EntryPoints = entry_points(group=group)
    res = eps if name is None else eps.select(name=name)

    return iter(res)


def _get_ep(group: str, name: str) -> Any | None:
    for ep in iter_entry_points(group, name):
        log.debug("ep found: %s", ep.name)
        return ep.load()
    else:
        return None


def _get_from_object_reference_str(path: str, group: str) -> Any | None:
    # todo: remove for importlib native spelling
    ep = EntryPoint(path, path, group)
    try:
        return ep.load()
    except (AttributeError, ModuleNotFoundError):
        return None


def _iter_version_schemes(
    entrypoint: str,
    scheme_value: _t.VERSION_SCHEMES,
    _memo: set[object] | None = None,
) -> Iterator[Callable[[version.ScmVersion], str]]:
    if _memo is None:
        _memo = set()
    if isinstance(scheme_value, str):
        scheme_value = cast(
            "_t.VERSION_SCHEMES",
            _get_ep(entrypoint, scheme_value)
            or _get_from_object_reference_str(scheme_value, entrypoint),
        )

    if isinstance(scheme_value, (list, tuple)):
        for variant in scheme_value:
            if variant not in _memo:
                _memo.add(variant)
                yield from _iter_version_schemes(entrypoint, variant, _memo=_memo)
    elif callable(scheme_value):
        yield scheme_value


@overload
def _call_version_scheme(
    version: version.ScmVersion,
    entrypoint: str,
    given_value: _t.VERSION_SCHEMES,
    default: str,
) -> str: ...


@overload
def _call_version_scheme(
    version: version.ScmVersion,
    entrypoint: str,
    given_value: _t.VERSION_SCHEMES,
    default: None,
) -> str | None: ...


def _call_version_scheme(
    version: version.ScmVersion,
    entrypoint: str,
    given_value: _t.VERSION_SCHEMES,
    default: str | None,
) -> str | None:
    for scheme in _iter_version_schemes(entrypoint, given_value):
        result = scheme(version)
        if result is not None:
            return result
    return default

==================================================

Folder: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\_file_finders
==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\_get_version_impl.py
==================================================
from __future__ import annotations

import logging
import re
import warnings

from pathlib import Path
from typing import Any
from typing import NoReturn
from typing import Pattern

from . import _config
from . import _entrypoints
from . import _run_cmd
from . import _types as _t
from ._config import Configuration
from ._overrides import _read_pretended_version_for
from ._version_cls import _validate_version_cls
from .version import ScmVersion
from .version import format_version as _format_version

EMPTY_TAG_REGEX_DEPRECATION = DeprecationWarning(
    "empty regex for tag regex is invalid, using default"
)

_log = logging.getLogger(__name__)


def parse_scm_version(config: Configuration) -> ScmVersion | None:
    try:
        if config.parse is not None:
            parse_result = config.parse(config.absolute_root, config=config)
            if parse_result is not None and not isinstance(parse_result, ScmVersion):
                raise TypeError(
                    f"version parse result was {str!r}\n"
                    "please return a parsed version (ScmVersion)"
                )
            return parse_result
        else:
            return _entrypoints.version_from_entrypoint(
                config,
                entrypoint="setuptools_scm.parse_scm",
                root=config.absolute_root,
            )
    except _run_cmd.CommandNotFoundError as e:
        _log.exception("command %s not found while parsing the scm, using fallbacks", e)
        return None


def parse_fallback_version(config: Configuration) -> ScmVersion | None:
    return _entrypoints.version_from_entrypoint(
        config,
        entrypoint="setuptools_scm.parse_scm_fallback",
        root=config.fallback_root,
    )


def parse_version(config: Configuration) -> ScmVersion | None:
    return (
        _read_pretended_version_for(config)
        or parse_scm_version(config)
        or parse_fallback_version(config)
    )


def write_version_files(
    config: Configuration, version: str, scm_version: ScmVersion
) -> None:
    if config.write_to is not None:
        from ._integration.dump_version import dump_version

        dump_version(
            root=config.root,
            version=version,
            scm_version=scm_version,
            write_to=config.write_to,
            template=config.write_to_template,
        )
    if config.version_file:
        from ._integration.dump_version import write_version_to_path

        version_file = Path(config.version_file)
        assert not version_file.is_absolute(), f"{version_file=}"
        # todo: use a better name than fallback root
        assert config.relative_to is not None
        target = Path(config.relative_to).parent.joinpath(version_file)
        write_version_to_path(
            target,
            template=config.version_file_template,
            version=version,
            scm_version=scm_version,
        )


def _get_version(
    config: Configuration, force_write_version_files: bool | None = None
) -> str | None:
    parsed_version = parse_version(config)
    if parsed_version is None:
        return None
    version_string = _format_version(parsed_version)
    if force_write_version_files is None:
        force_write_version_files = True
        warnings.warn(
            "force_write_version_files ought to be set,"
            " presuming the legacy True value",
            DeprecationWarning,
        )

    if force_write_version_files:
        write_version_files(config, version=version_string, scm_version=parsed_version)

    return version_string


def _version_missing(config: Configuration) -> NoReturn:
    raise LookupError(
        f"setuptools-scm was unable to detect version for {config.absolute_root}.\n\n"
        "Make sure you're either building from a fully intact git repository "
        "or PyPI tarballs. Most other sources (such as GitHub's tarballs, a "
        "git checkout without the .git folder) don't contain the necessary "
        "metadata and will not work.\n\n"
        "For example, if you're using pip, instead of "
        "https://github.com/user/proj/archive/master.zip "
        "use git+https://github.com/user/proj.git#egg=proj"
    )


def get_version(
    root: _t.PathT = ".",
    version_scheme: _t.VERSION_SCHEME = _config.DEFAULT_VERSION_SCHEME,
    local_scheme: _t.VERSION_SCHEME = _config.DEFAULT_LOCAL_SCHEME,
    write_to: _t.PathT | None = None,
    write_to_template: str | None = None,
    version_file: _t.PathT | None = None,
    version_file_template: str | None = None,
    relative_to: _t.PathT | None = None,
    tag_regex: str | Pattern[str] = _config.DEFAULT_TAG_REGEX,
    parentdir_prefix_version: str | None = None,
    fallback_version: str | None = None,
    fallback_root: _t.PathT = ".",
    parse: Any | None = None,
    git_describe_command: _t.CMD_TYPE | None = None,
    dist_name: str | None = None,
    version_cls: Any | None = None,
    normalize: bool = True,
    search_parent_directories: bool = False,
) -> str:
    """
    If supplied, relative_to should be a file from which root may
    be resolved. Typically called by a script or module that is not
    in the root of the repository to direct setuptools_scm to the
    root of the repository by supplying ``__file__``.
    """

    version_cls = _validate_version_cls(version_cls, normalize)
    del normalize
    tag_regex = parse_tag_regex(tag_regex)
    config = Configuration(**locals())
    maybe_version = _get_version(config, force_write_version_files=True)

    if maybe_version is None:
        _version_missing(config)
    return maybe_version


def parse_tag_regex(tag_regex: str | Pattern[str]) -> Pattern[str]:
    if isinstance(tag_regex, str):
        if tag_regex == "":
            warnings.warn(EMPTY_TAG_REGEX_DEPRECATION)
            return _config.DEFAULT_TAG_REGEX
        else:
            return re.compile(tag_regex)
    else:
        return tag_regex

==================================================

Folder: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\_integration
==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\_log.py
==================================================
"""
logging helpers, supports vendoring
"""

from __future__ import annotations

import contextlib
import logging
import os
import sys

from typing import IO
from typing import Iterator
from typing import Mapping

log = logging.getLogger(__name__.rsplit(".", 1)[0])
log.propagate = False


class AlwaysStdErrHandler(logging.StreamHandler):  # type: ignore[type-arg]
    def __init___(self) -> None:
        super().__init__(sys.stderr)

    @property  # type: ignore [override]
    def stream(self) -> IO[str]:
        return sys.stderr

    @stream.setter
    def stream(self, value: IO[str]) -> None:
        assert value is sys.stderr


def make_default_handler() -> logging.Handler:
    try:
        from rich.console import Console

        console = Console(stderr=True)
        from rich.logging import RichHandler

        return RichHandler(console=console)
    except ImportError:
        handler = AlwaysStdErrHandler()
        handler.setFormatter(logging.Formatter("%(levelname)s %(name)s %(message)s"))
        return handler


_default_handler = make_default_handler()

log.addHandler(_default_handler)


def _default_log_level(_env: Mapping[str, str] = os.environ) -> int:
    val: str | None = _env.get("SETUPTOOLS_SCM_DEBUG")
    return logging.WARN if val is None else logging.DEBUG


log.setLevel(_default_log_level())


@contextlib.contextmanager
def defer_to_pytest() -> Iterator[None]:
    log.propagate = True
    old_level = log.level
    log.setLevel(logging.NOTSET)
    log.removeHandler(_default_handler)
    try:
        yield
    finally:
        log.addHandler(_default_handler)
        log.propagate = False
        log.setLevel(old_level)


@contextlib.contextmanager
def enable_debug(handler: logging.Handler = _default_handler) -> Iterator[None]:
    log.addHandler(handler)
    old_level = log.level
    log.setLevel(logging.DEBUG)
    old_handler_level = handler.level
    handler.setLevel(logging.DEBUG)
    try:
        yield
    finally:
        log.setLevel(old_level)
        handler.setLevel(old_handler_level)
        if handler is not _default_handler:
            log.removeHandler(handler)

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\_modify_version.py
==================================================
from __future__ import annotations

import re

from . import _types as _t


def strip_local(version_string: str) -> str:
    public = version_string.partition("+")[0]
    return public


def _add_post(version: str) -> str:
    if "post" in version:
        raise ValueError(
            f"{version} already is a post release, refusing to guess the update"
        )
    return f"{version}.post1"


def _bump_dev(version: str) -> str | None:
    if ".dev" not in version:
        return None

    prefix, tail = version.rsplit(".dev", 1)
    if tail != "0":
        raise ValueError(
            "choosing custom numbers for the `.devX` distance "
            "is not supported.\n "
            f"The {version} can't be bumped\n"
            "Please drop the tag or create a new supported one ending in .dev0"
        )
    return prefix


def _bump_regex(version: str) -> str:
    match = re.match(r"(.*?)(\d+)$", version)
    if match is None:
        raise ValueError(
            f"{version} does not end with a number to bump, "
            "please correct or use a custom version scheme"
        )
    else:
        prefix, tail = match.groups()
        return f"{prefix}{int(tail) + 1}"


def _format_local_with_time(version: _t.SCMVERSION, time_format: str) -> str:
    if version.exact or version.node is None:
        return version.format_choice(
            "", "+d{time:{time_format}}", time_format=time_format
        )
    else:
        return version.format_choice(
            "+{node}", "+{node}.d{time:{time_format}}", time_format=time_format
        )


def _dont_guess_next_version(tag_version: _t.SCMVERSION) -> str:
    version = strip_local(str(tag_version.tag))
    return _bump_dev(version) or _add_post(version)

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\_overrides.py
==================================================
from __future__ import annotations

import os
import re

from typing import Any

from . import _config
from . import _log
from . import version
from ._integration.toml import load_toml_or_inline_map

log = _log.log.getChild("overrides")

PRETEND_KEY = "SETUPTOOLS_SCM_PRETEND_VERSION"
PRETEND_KEY_NAMED = PRETEND_KEY + "_FOR_{name}"


def read_named_env(
    *, tool: str = "SETUPTOOLS_SCM", name: str, dist_name: str | None
) -> str | None:
    """ """
    if dist_name is not None:
        # Normalize the dist name as per PEP 503.
        normalized_dist_name = re.sub(r"[-_.]+", "-", dist_name)
        env_var_dist_name = normalized_dist_name.replace("-", "_").upper()
        val = os.environ.get(f"{tool}_{name}_FOR_{env_var_dist_name}")
        if val is not None:
            return val
    return os.environ.get(f"{tool}_{name}")


def _read_pretended_version_for(
    config: _config.Configuration,
) -> version.ScmVersion | None:
    """read a a overridden version from the environment

    tries ``SETUPTOOLS_SCM_PRETEND_VERSION``
    and ``SETUPTOOLS_SCM_PRETEND_VERSION_FOR_$UPPERCASE_DIST_NAME``
    """
    log.debug("dist name: %s", config.dist_name)

    pretended = read_named_env(name="PRETEND_VERSION", dist_name=config.dist_name)

    if pretended:
        # we use meta here since the pretended version
        # must adhere to the pep to begin with
        return version.meta(tag=pretended, preformatted=True, config=config)
    else:
        return None


def read_toml_overrides(dist_name: str | None) -> dict[str, Any]:
    data = read_named_env(name="OVERRIDES", dist_name=dist_name)
    return load_toml_or_inline_map(data)

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\_run_cmd.py
==================================================
from __future__ import annotations

import os
import shlex
import subprocess
import textwrap
import warnings

from typing import TYPE_CHECKING
from typing import Callable
from typing import Final
from typing import Mapping
from typing import Sequence
from typing import TypeVar
from typing import overload

from . import _log
from . import _types as _t

if TYPE_CHECKING:
    BaseCompletedProcess = subprocess.CompletedProcess[str]
else:
    BaseCompletedProcess = subprocess.CompletedProcess

# pick 40 seconds
# unfortunately github CI for windows sometimes needs
# up to 30 seconds to start a command


def _get_timeout(env: Mapping[str, str]) -> int:
    return int(env.get("SETUPTOOLS_SCM_SUBPROCESS_TIMEOUT") or 40)


BROKEN_TIMEOUT: Final[int] = _get_timeout(os.environ)

log = _log.log.getChild("run_cmd")

PARSE_RESULT = TypeVar("PARSE_RESULT")
T = TypeVar("T")


class CompletedProcess(BaseCompletedProcess):
    @classmethod
    def from_raw(
        cls, input: BaseCompletedProcess, strip: bool = True
    ) -> CompletedProcess:
        return cls(
            args=input.args,
            returncode=input.returncode,
            stdout=input.stdout.strip() if strip and input.stdout else input.stdout,
            stderr=input.stderr.strip() if strip and input.stderr else input.stderr,
        )

    @overload
    def parse_success(
        self,
        parse: Callable[[str], PARSE_RESULT],
        default: None = None,
        error_msg: str | None = None,
    ) -> PARSE_RESULT | None: ...

    @overload
    def parse_success(
        self,
        parse: Callable[[str], PARSE_RESULT],
        default: T,
        error_msg: str | None = None,
    ) -> PARSE_RESULT | T: ...

    def parse_success(
        self,
        parse: Callable[[str], PARSE_RESULT],
        default: T | None = None,
        error_msg: str | None = None,
    ) -> PARSE_RESULT | T | None:
        if self.returncode:
            if error_msg:
                log.warning("%s %s", error_msg, self)
            return default
        else:
            return parse(self.stdout)


def no_git_env(env: Mapping[str, str]) -> dict[str, str]:
    # adapted from pre-commit
    # Too many bugs dealing with environment variables and GIT:
    # https://github.com/pre-commit/pre-commit/issues/300
    # In git 2.6.3 (maybe others), git exports GIT_WORK_TREE while running
    # pre-commit hooks
    # In git 1.9.1 (maybe others), git exports GIT_DIR and GIT_INDEX_FILE
    # while running pre-commit hooks in submodules.
    # GIT_DIR: Causes git clone to clone wrong thing
    # GIT_INDEX_FILE: Causes 'error invalid object ...' during commit
    for k, v in env.items():
        if k.startswith("GIT_"):
            log.debug("%s: %s", k, v)
    return {
        k: v
        for k, v in env.items()
        if not k.startswith("GIT_")
        or k in ("GIT_EXEC_PATH", "GIT_SSH", "GIT_SSH_COMMAND")
    }


def avoid_pip_isolation(env: Mapping[str, str]) -> dict[str, str]:
    """
    pip build isolation can break Mercurial
    (see https://github.com/pypa/pip/issues/10635)

    pip uses PYTHONNOUSERSITE and a path in PYTHONPATH containing "pip-build-env-".
    """
    new_env = {k: v for k, v in env.items() if k != "PYTHONNOUSERSITE"}
    if "PYTHONPATH" not in new_env:
        return new_env

    new_env["PYTHONPATH"] = os.pathsep.join(
        [
            path
            for path in new_env["PYTHONPATH"].split(os.pathsep)
            if "pip-build-env-" not in path
        ]
    )
    return new_env


def ensure_stripped_str(str_or_bytes: str | bytes) -> str:
    if isinstance(str_or_bytes, str):
        return str_or_bytes.strip()
    else:
        return str_or_bytes.decode("utf-8", "surrogateescape").strip()


def run(
    cmd: _t.CMD_TYPE,
    cwd: _t.PathT,
    *,
    strip: bool = True,
    trace: bool = True,
    timeout: int | None = None,
    check: bool = False,
) -> CompletedProcess:
    if isinstance(cmd, str):
        cmd = shlex.split(cmd)
    else:
        cmd = [os.fspath(x) for x in cmd]
    cmd_4_trace = " ".join(map(_unsafe_quote_for_display, cmd))
    log.debug("at %s\n    $ %s ", cwd, cmd_4_trace)
    if timeout is None:
        timeout = BROKEN_TIMEOUT
    res = subprocess.run(
        cmd,
        capture_output=True,
        cwd=os.fspath(cwd),
        env=dict(
            avoid_pip_isolation(no_git_env(os.environ)),
            # os.environ,
            # try to disable i18n, but still allow UTF-8 encoded text.
            LC_ALL="C.UTF-8",
            LANGUAGE="",
            HGPLAIN="1",
        ),
        text=True,
        encoding="utf-8",
        timeout=timeout,
    )

    res = CompletedProcess.from_raw(res, strip=strip)
    if trace:
        if res.stdout:
            log.debug("out:\n%s", textwrap.indent(res.stdout, "    "))
        if res.stderr:
            log.debug("err:\n%s", textwrap.indent(res.stderr, "    "))
        if res.returncode:
            log.debug("ret: %s", res.returncode)
    if check:
        res.check_returncode()
    return res


def _unsafe_quote_for_display(item: _t.PathT) -> str:
    # give better results than shlex.join in our cases
    text = os.fspath(item)
    return text if all(c not in text for c in " {[:") else f'"{text}"'


def has_command(
    name: str, args: Sequence[str] = ["version"], warn: bool = True
) -> bool:
    try:
        p = run([name, *args], cwd=".")
        if p.returncode != 0:
            log.error(f"Command '{name}' returned non-zero. This is stderr:")
            log.error(p.stderr)
    except OSError as e:
        log.warning("command %s missing: %s", name, e)
        res = False
    except subprocess.TimeoutExpired as e:
        log.warning("command %s timed out %s", name, e)
        res = False

    else:
        res = not p.returncode
    if not res and warn:
        warnings.warn("%r was not found" % name, category=RuntimeWarning)
    return res


class CommandNotFoundError(LookupError, FileNotFoundError):
    pass


def require_command(name: str) -> None:
    if not has_command(name, warn=False):
        raise CommandNotFoundError(name)

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\_types.py
==================================================
from __future__ import annotations

import os

from typing import TYPE_CHECKING
from typing import Callable
from typing import List
from typing import Sequence
from typing import Tuple
from typing import Union

if TYPE_CHECKING:
    import sys

    if sys.version_info >= (3, 10):
        from typing import TypeAlias
    else:
        from typing_extensions import TypeAlias

    from . import version

PathT: TypeAlias = Union["os.PathLike[str]", str]

CMD_TYPE: TypeAlias = Union[Sequence[PathT], str]

VERSION_SCHEME: TypeAlias = Union[str, Callable[["version.ScmVersion"], str]]
VERSION_SCHEMES: TypeAlias = Union[List[str], Tuple[str, ...], VERSION_SCHEME]
SCMVERSION: TypeAlias = "version.ScmVersion"

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\_version_cls.py
==================================================
from __future__ import annotations

from typing import Type
from typing import Union
from typing import cast

try:
    from packaging.version import InvalidVersion
    from packaging.version import Version as Version
except ImportError:
    from setuptools.extern.packaging.version import InvalidVersion  # type: ignore
    from setuptools.extern.packaging.version import Version as Version  # type: ignore
from . import _log

log = _log.log.getChild("version_cls")


class NonNormalizedVersion(Version):
    """A non-normalizing version handler.

    You can use this class to preserve version verification but skip normalization.
    For example you can use this to avoid git release candidate version tags
    ("1.0.0-rc1") to be normalized to "1.0.0rc1". Only use this if you fully
    trust the version tags.
    """

    def __init__(self, version: str) -> None:
        # parse and validate using parent
        super().__init__(version)

        # store raw for str
        self._raw_version = version

    def __str__(self) -> str:
        # return the non-normalized version (parent returns the normalized)
        return self._raw_version

    def __repr__(self) -> str:
        # same pattern as parent
        return f"<NonNormalizedVersion({self._raw_version!r})>"


def _version_as_tuple(version_str: str) -> tuple[int | str, ...]:
    try:
        parsed_version = Version(version_str)
    except InvalidVersion as e:
        log.error("failed to parse version %s: %s", e, version_str)
        return (version_str,)
    else:
        version_fields: tuple[int | str, ...] = parsed_version.release
        if parsed_version.dev is not None:
            version_fields += (f"dev{parsed_version.dev}",)
        if parsed_version.local is not None:
            version_fields += (parsed_version.local,)
        return version_fields


_VersionT = Union[Version, NonNormalizedVersion]


def import_name(name: str) -> object:
    import importlib

    pkg_name, cls_name = name.rsplit(".", 1)
    pkg = importlib.import_module(pkg_name)
    return getattr(pkg, cls_name)


def _validate_version_cls(
    version_cls: type[_VersionT] | str | None, normalize: bool
) -> type[_VersionT]:
    if not normalize:
        if version_cls is not None:
            raise ValueError(
                "Providing a custom `version_cls` is not permitted when "
                "`normalize=False`"
            )
        return NonNormalizedVersion
    else:
        # Use `version_cls` if provided, default to packaging or pkg_resources
        if version_cls is None:
            return Version
        elif isinstance(version_cls, str):
            try:
                return cast(Type[_VersionT], import_name(version_cls))
            except:  # noqa
                raise ValueError(
                    f"Unable to import version_cls='{version_cls}'"
                ) from None
        else:
            return version_cls

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\__init__.py
==================================================
"""
:copyright: 2010-2023 by Ronny Pfannschmidt
:license: MIT
"""

from __future__ import annotations

from ._config import DEFAULT_LOCAL_SCHEME
from ._config import DEFAULT_VERSION_SCHEME
from ._config import Configuration
from ._get_version_impl import _get_version
from ._get_version_impl import get_version
from ._integration.dump_version import dump_version  # soft deprecated
from ._version_cls import NonNormalizedVersion
from ._version_cls import Version
from .version import ScmVersion

# Public API
__all__ = [
    "DEFAULT_LOCAL_SCHEME",
    "DEFAULT_VERSION_SCHEME",
    "Configuration",
    "NonNormalizedVersion",
    "ScmVersion",
    "Version",
    "_get_version",
    "dump_version",
    # soft deprecated imports, left for backward compatibility
    "get_version",
]

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\__main__.py
==================================================
from __future__ import annotations

from ._cli import main

if __name__ == "__main__":
    raise SystemExit(main())

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\_file_finders\git.py
==================================================
from __future__ import annotations

import logging
import os
import subprocess
import tarfile

from typing import IO

from .. import _types as _t
from .._run_cmd import run as _run
from ..integration import data_from_mime
from . import is_toplevel_acceptable
from . import scm_find_files
from .pathtools import norm_real

log = logging.getLogger(__name__)


def _git_toplevel(path: str) -> str | None:
    try:
        cwd = os.path.abspath(path or ".")
        res = _run(["git", "rev-parse", "HEAD"], cwd=cwd)
        if res.returncode:
            # BAIL if there is no commit
            log.error("listing git files failed - pretending there aren't any")
            return None
        res = _run(
            ["git", "rev-parse", "--show-prefix"],
            cwd=cwd,
        )
        if res.returncode:
            return None
        out = res.stdout[:-1]  # remove the trailing pathsep
        if not out:
            out = cwd
        else:
            # Here, ``out`` is a relative path to root of git.
            # ``cwd`` is absolute path to current working directory.
            # the below method removes the length of ``out`` from
            # ``cwd``, which gives the git toplevel
            assert cwd.replace("\\", "/").endswith(out), f"cwd={cwd!r}\nout={out!r}"
            # In windows cwd contains ``\`` which should be replaced by ``/``
            # for this assertion to work. Length of string isn't changed by replace
            # ``\\`` is just and escape for `\`
            out = cwd[: -len(out)]
        log.debug("find files toplevel %s", out)
        return norm_real(out)
    except subprocess.CalledProcessError:
        # git returned error, we are not in a git repo
        return None
    except OSError:
        # git command not found, probably
        return None


def _git_interpret_archive(fd: IO[bytes], toplevel: str) -> tuple[set[str], set[str]]:
    with tarfile.open(fileobj=fd, mode="r|*") as tf:
        git_files = set()
        git_dirs = {toplevel}
        for member in tf.getmembers():
            name = os.path.normcase(member.name).replace("/", os.path.sep)
            if member.type == tarfile.DIRTYPE:
                git_dirs.add(name)
            else:
                git_files.add(name)
        return git_files, git_dirs


def _git_ls_files_and_dirs(toplevel: str) -> tuple[set[str], set[str]]:
    # use git archive instead of git ls-file to honor
    # export-ignore git attribute

    cmd = ["git", "archive", "--prefix", toplevel + os.path.sep, "HEAD"]
    proc = subprocess.Popen(
        cmd, stdout=subprocess.PIPE, cwd=toplevel, stderr=subprocess.DEVNULL
    )
    assert proc.stdout is not None
    try:
        try:
            return _git_interpret_archive(proc.stdout, toplevel)
        finally:
            # ensure we avoid resource warnings by cleaning up the process
            proc.stdout.close()
            proc.terminate()
    except Exception:
        if proc.wait() != 0:
            log.error("listing git files failed - pretending there aren't any")
        return set(), set()


def git_find_files(path: _t.PathT = "") -> list[str]:
    toplevel = _git_toplevel(os.fspath(path))
    if not is_toplevel_acceptable(toplevel):
        return []
    fullpath = norm_real(path)
    if not fullpath.startswith(toplevel):
        log.warning("toplevel mismatch computed %s vs resolved %s ", toplevel, fullpath)
    git_files, git_dirs = _git_ls_files_and_dirs(toplevel)
    return scm_find_files(path, git_files, git_dirs)


def git_archive_find_files(path: _t.PathT = "") -> list[str]:
    # This function assumes that ``path`` is obtained from a git archive
    # and therefore all the files that should be ignored were already removed.
    archival = os.path.join(path, ".git_archival.txt")
    if not os.path.exists(archival):
        return []

    data = data_from_mime(archival)

    if "$Format" in data.get("node", ""):
        # Substitutions have not been performed, so not a reliable archive
        return []

    log.warning("git archive detected - fallback to listing all files")
    return scm_find_files(path, set(), set(), force_all_files=True)

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\_file_finders\hg.py
==================================================
from __future__ import annotations

import logging
import os
import subprocess

from .. import _types as _t
from .._file_finders import is_toplevel_acceptable
from .._file_finders import scm_find_files
from .._run_cmd import run as _run
from ..integration import data_from_mime
from .pathtools import norm_real

log = logging.getLogger(__name__)


def _hg_toplevel(path: str) -> str | None:
    try:
        return _run(
            ["hg", "root"],
            cwd=(path or "."),
            check=True,
        ).parse_success(norm_real)
    except subprocess.CalledProcessError:
        # hg returned error, we are not in a mercurial repo
        return None
    except OSError:
        # hg command not found, probably
        return None


def _hg_ls_files_and_dirs(toplevel: str) -> tuple[set[str], set[str]]:
    hg_files: set[str] = set()
    hg_dirs = {toplevel}
    res = _run(["hg", "files"], cwd=toplevel)
    if res.returncode:
        return set(), set()
    for name in res.stdout.splitlines():
        name = os.path.normcase(name).replace("/", os.path.sep)
        fullname = os.path.join(toplevel, name)
        hg_files.add(fullname)
        dirname = os.path.dirname(fullname)
        while len(dirname) > len(toplevel) and dirname not in hg_dirs:
            hg_dirs.add(dirname)
            dirname = os.path.dirname(dirname)
    return hg_files, hg_dirs


def hg_find_files(path: str = "") -> list[str]:
    toplevel = _hg_toplevel(path)
    if not is_toplevel_acceptable(toplevel):
        return []
    assert toplevel is not None
    hg_files, hg_dirs = _hg_ls_files_and_dirs(toplevel)
    return scm_find_files(path, hg_files, hg_dirs)


def hg_archive_find_files(path: _t.PathT = "") -> list[str]:
    # This function assumes that ``path`` is obtained from a mercurial archive
    # and therefore all the files that should be ignored were already removed.
    archival = os.path.join(path, ".hg_archival.txt")
    if not os.path.exists(archival):
        return []

    data = data_from_mime(archival)

    if "node" not in data:
        # Ensure file is valid
        return []

    log.warning("hg archive detected - fallback to listing all files")
    return scm_find_files(path, set(), set(), force_all_files=True)

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\_file_finders\pathtools.py
==================================================
from __future__ import annotations

import os

from setuptools_scm import _types as _t


def norm_real(path: _t.PathT) -> str:
    return os.path.normcase(os.path.realpath(path))

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\_file_finders\__init__.py
==================================================
from __future__ import annotations

import itertools
import os

from typing import TYPE_CHECKING
from typing import Callable

from .. import _log
from .. import _types as _t
from .._entrypoints import iter_entry_points
from .pathtools import norm_real

if TYPE_CHECKING:
    import sys

    if sys.version_info >= (3, 10):
        from typing import TypeGuard
    else:
        from typing_extensions import TypeGuard


log = _log.log.getChild("file_finder")


def scm_find_files(
    path: _t.PathT,
    scm_files: set[str],
    scm_dirs: set[str],
    force_all_files: bool = False,
) -> list[str]:
    """ setuptools compatible file finder that follows symlinks

    - path: the root directory from which to search
    - scm_files: set of scm controlled files and symlinks
      (including symlinks to directories)
    - scm_dirs: set of scm controlled directories
      (including directories containing no scm controlled files)
    - force_all_files: ignore ``scm_files`` and ``scm_dirs`` and list everything.

    scm_files and scm_dirs must be absolute with symlinks resolved (realpath),
    with normalized case (normcase)

    Spec here: https://setuptools.pypa.io/en/latest/userguide/extension.html#\
        adding-support-for-revision-control-systems
    """
    realpath = norm_real(path)
    seen: set[str] = set()
    res: list[str] = []
    for dirpath, dirnames, filenames in os.walk(realpath, followlinks=True):
        # dirpath with symlinks resolved
        realdirpath = norm_real(dirpath)

        def _link_not_in_scm(n: str, realdirpath: str = realdirpath) -> bool:
            fn = os.path.join(realdirpath, os.path.normcase(n))
            return os.path.islink(fn) and fn not in scm_files

        if not force_all_files and realdirpath not in scm_dirs:
            # directory not in scm, don't walk it's content
            dirnames[:] = []
            continue
        if os.path.islink(dirpath) and not os.path.relpath(
            realdirpath, realpath
        ).startswith(os.pardir):
            # a symlink to a directory not outside path:
            # we keep it in the result and don't walk its content
            res.append(os.path.join(path, os.path.relpath(dirpath, path)))
            dirnames[:] = []
            continue
        if realdirpath in seen:
            # symlink loop protection
            dirnames[:] = []
            continue
        dirnames[:] = [
            dn for dn in dirnames if force_all_files or not _link_not_in_scm(dn)
        ]
        for filename in filenames:
            if not force_all_files and _link_not_in_scm(filename):
                continue
            # dirpath + filename with symlinks preserved
            fullfilename = os.path.join(dirpath, filename)
            is_tracked = norm_real(fullfilename) in scm_files
            if force_all_files or is_tracked:
                res.append(os.path.join(path, os.path.relpath(fullfilename, realpath)))
        seen.add(realdirpath)
    return res


def is_toplevel_acceptable(toplevel: str | None) -> TypeGuard[str]:
    """ """
    if toplevel is None:
        return False

    ignored: list[str] = os.environ.get("SETUPTOOLS_SCM_IGNORE_VCS_ROOTS", "").split(
        os.pathsep
    )
    ignored = [os.path.normcase(p) for p in ignored]

    log.debug("toplevel: %r\n    ignored %s", toplevel, ignored)

    return toplevel not in ignored


def find_files(path: _t.PathT = "") -> list[str]:
    for ep in itertools.chain(
        iter_entry_points("setuptools_scm.files_command"),
        iter_entry_points("setuptools_scm.files_command_fallback"),
    ):
        command: Callable[[_t.PathT], list[str]] = ep.load()
        res: list[str] = command(path)
        if res:
            return res
    return []

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\_integration\dump_version.py
==================================================
from __future__ import annotations

import warnings

from pathlib import Path

from .. import _types as _t
from .._log import log as parent_log
from .._version_cls import _version_as_tuple
from ..version import ScmVersion

log = parent_log.getChild("dump_version")

TEMPLATES = {
    ".py": """\
# file generated by setuptools_scm
# don't change, don't track in version control
TYPE_CHECKING = False
if TYPE_CHECKING:
    from typing import Tuple, Union
    VERSION_TUPLE = Tuple[Union[int, str], ...]
else:
    VERSION_TUPLE = object

version: str
__version__: str
__version_tuple__: VERSION_TUPLE
version_tuple: VERSION_TUPLE

__version__ = version = {version!r}
__version_tuple__ = version_tuple = {version_tuple!r}
""",
    ".txt": "{version}",
}


def dump_version(
    root: _t.PathT,
    version: str,
    write_to: _t.PathT,
    template: str | None = None,
    scm_version: ScmVersion | None = None,
) -> None:
    assert isinstance(version, str)
    root = Path(root)
    write_to = Path(write_to)
    if write_to.is_absolute():
        # trigger warning on escape
        write_to.relative_to(root)
        warnings.warn(
            f"{write_to=!s} is a absolute path,"
            " please switch to using a relative version file",
            DeprecationWarning,
        )
        target = write_to
    else:
        target = Path(root).joinpath(write_to)
    write_version_to_path(
        target, template=template, version=version, scm_version=scm_version
    )


def _validate_template(target: Path, template: str | None) -> str:
    if template == "":
        warnings.warn(f"{template=} looks like a error, using default instead")
        template = None
    if template is None:
        template = TEMPLATES.get(target.suffix)

    if template is None:
        raise ValueError(
            f"bad file format: {target.suffix!r} (of {target})\n"
            "only *.txt and *.py have a default template"
        )
    else:
        return template


def write_version_to_path(
    target: Path, template: str | None, version: str, scm_version: ScmVersion | None
) -> None:
    final_template = _validate_template(target, template)
    log.debug("dump %s into %s", version, target)
    version_tuple = _version_as_tuple(version)
    if scm_version is not None:
        content = final_template.format(
            version=version,
            version_tuple=version_tuple,
            scm_version=scm_version,
        )
    else:
        content = final_template.format(version=version, version_tuple=version_tuple)

    target.write_text(content, encoding="utf-8")

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\_integration\pyproject_reading.py
==================================================
from __future__ import annotations

import warnings

from pathlib import Path
from typing import NamedTuple

from .. import _log
from .setuptools import read_dist_name_from_setup_cfg
from .toml import TOML_RESULT
from .toml import read_toml_content

log = _log.log.getChild("pyproject_reading")

_ROOT = "root"


class PyProjectData(NamedTuple):
    path: Path
    tool_name: str
    project: TOML_RESULT
    section: TOML_RESULT

    @property
    def project_name(self) -> str | None:
        return self.project.get("name")


def read_pyproject(
    path: Path = Path("pyproject.toml"),
    tool_name: str = "setuptools_scm",
    require_section: bool = True,
) -> PyProjectData:
    defn = read_toml_content(path, None if require_section else {})
    try:
        section = defn.get("tool", {})[tool_name]
    except LookupError as e:
        error = f"{path} does not contain a tool.{tool_name} section"
        if require_section:
            raise LookupError(error) from e
        else:
            log.warning("toml section missing %r", error, exc_info=True)
            section = {}

    project = defn.get("project", {})
    return PyProjectData(path, tool_name, project, section)


def get_args_for_pyproject(
    pyproject: PyProjectData,
    dist_name: str | None,
    kwargs: TOML_RESULT,
) -> TOML_RESULT:
    """drops problematic details and figures the distribution name"""
    section = pyproject.section.copy()
    kwargs = kwargs.copy()
    if "relative_to" in section:
        relative = section.pop("relative_to")
        warnings.warn(
            f"{pyproject.path}: at [tool.{pyproject.tool_name}]\n"
            f"ignoring value relative_to={relative!r}"
            " as its always relative to the config file"
        )
    if "dist_name" in section:
        if dist_name is None:
            dist_name = section.pop("dist_name")
        else:
            assert dist_name == section["dist_name"]
            section.pop("dist_name")
    if dist_name is None:
        # minimal pep 621 support for figuring the pretend keys
        dist_name = pyproject.project_name
    if dist_name is None:
        dist_name = read_dist_name_from_setup_cfg()
    if _ROOT in kwargs:
        if kwargs[_ROOT] is None:
            kwargs.pop(_ROOT, None)
        elif _ROOT in section:
            if section[_ROOT] != kwargs[_ROOT]:
                warnings.warn(
                    f"root {section[_ROOT]} is overridden"
                    f" by the cli arg {kwargs[_ROOT]}"
                )
            section.pop(_ROOT, None)
    return {"dist_name": dist_name, **section, **kwargs}

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\_integration\setuptools.py
==================================================
from __future__ import annotations

import logging
import os
import warnings

from typing import Any
from typing import Callable

import setuptools

from .. import _config

log = logging.getLogger(__name__)


def read_dist_name_from_setup_cfg(
    input: str | os.PathLike[str] = "setup.cfg",
) -> str | None:
    # minimal effort to read dist_name off setup.cfg metadata
    import configparser

    parser = configparser.ConfigParser()
    parser.read([input], encoding="utf-8")
    dist_name = parser.get("metadata", "name", fallback=None)
    return dist_name


def _warn_on_old_setuptools(_version: str = setuptools.__version__) -> None:
    if int(_version.split(".")[0]) < 61:
        warnings.warn(
            RuntimeWarning(
                f"""
ERROR: setuptools=={_version} is used in combination with setuptools_scm>=8.x

Your build configuration is incomplete and previously worked by accident!
setuptools_scm requires setuptools>=61

Suggested workaround if applicable:
 - migrating from the deprecated setup_requires mechanism to pep517/518
   and using a pyproject.toml to declare build dependencies
   which are reliably pre-installed before running the build tools
"""
            )
        )


def _assign_version(
    dist: setuptools.Distribution, config: _config.Configuration
) -> None:
    from .._get_version_impl import _get_version
    from .._get_version_impl import _version_missing

    # todo: build time plugin
    maybe_version = _get_version(config, force_write_version_files=True)

    if maybe_version is None:
        _version_missing(config)
    else:
        assert dist.metadata.version is None
        dist.metadata.version = maybe_version


_warn_on_old_setuptools()


def _log_hookstart(hook: str, dist: setuptools.Distribution) -> None:
    log.debug("%s %r", hook, vars(dist.metadata))


def version_keyword(
    dist: setuptools.Distribution,
    keyword: str,
    value: bool | dict[str, Any] | Callable[[], dict[str, Any]],
) -> None:
    overrides: dict[str, Any]
    if value is True:
        overrides = {}
    elif callable(value):
        overrides = value()
    else:
        assert isinstance(value, dict), "version_keyword expects a dict or True"
        overrides = value

    assert (
        "dist_name" not in overrides
    ), "dist_name may not be specified in the setup keyword "
    dist_name: str | None = dist.metadata.name
    _log_hookstart("version_keyword", dist)

    if dist.metadata.version is not None:
        warnings.warn(f"version of {dist_name} already set")
        return

    if dist_name is None:
        dist_name = read_dist_name_from_setup_cfg()

    config = _config.Configuration.from_file(
        dist_name=dist_name,
        _require_section=False,
        **overrides,
    )
    _assign_version(dist, config)


def infer_version(dist: setuptools.Distribution) -> None:
    _log_hookstart("infer_version", dist)
    log.debug("dist %s %s", id(dist), id(dist.metadata))
    if dist.metadata.version is not None:
        return  # metadata already added by hook
    dist_name = dist.metadata.name
    if dist_name is None:
        dist_name = read_dist_name_from_setup_cfg()
    if not os.path.isfile("pyproject.toml"):
        return
    if dist_name == "setuptools_scm":
        return
    try:
        config = _config.Configuration.from_file(dist_name=dist_name)
    except LookupError as e:
        log.info(e, exc_info=True)
    else:
        _assign_version(dist, config)

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\_integration\toml.py
==================================================
from __future__ import annotations

import sys

from pathlib import Path
from typing import TYPE_CHECKING
from typing import Any
from typing import Callable
from typing import Dict
from typing import TypedDict
from typing import cast

if sys.version_info >= (3, 11):
    from tomllib import loads as load_toml
else:
    from tomli import loads as load_toml

if TYPE_CHECKING:
    if sys.version_info >= (3, 10):
        from typing import TypeAlias
    else:
        from typing_extensions import TypeAlias

from .. import _log

log = _log.log.getChild("toml")

TOML_RESULT: TypeAlias = Dict[str, Any]
TOML_LOADER: TypeAlias = Callable[[str], TOML_RESULT]


def read_toml_content(path: Path, default: TOML_RESULT | None = None) -> TOML_RESULT:
    try:
        data = path.read_text(encoding="utf-8")
    except FileNotFoundError:
        if default is None:
            raise
        else:
            log.debug("%s missing, presuming default %r", path, default)
            return default
    else:
        return load_toml(data)


class _CheatTomlData(TypedDict):
    cheat: dict[str, Any]


def load_toml_or_inline_map(data: str | None) -> dict[str, Any]:
    """
    load toml data - with a special hack if only a inline map is given
    """
    if not data:
        return {}
    elif data[0] == "{":
        data = "cheat=" + data
        loaded: _CheatTomlData = cast(_CheatTomlData, load_toml(data))
        return loaded["cheat"]
    return load_toml(data)

==================================================

File: c:\GH\ras-commander\.eggs\setuptools_scm-8.1.0-py3.12.egg\setuptools_scm\_integration\__init__.py
==================================================

==================================================

File: c:\GH\ras-commander\.gitignore\.gitignore
==================================================
# Ignore the example_projects folder and all its subfolders
example_projects/

# Ignore the Example_Projects_6_5.zip file
Example_Projects_6_5.zip

# Ignore the misc folder and all its subfolders
misc/
ras_commander/__pycache__/
__pycache__/
*.py[cod]
*.so
*.egg-info/
dist/
build/
.pytest_cache/
.venv/
==================================================

File: c:\GH\ras-commander\ai_tools\llmsummarize 1. full repo.py
==================================================
from pathlib import Path

# Get the name of this script
this_script = Path(__file__).name
print(f"Script name: {this_script}")

# Define the subfolder to summarize
summarize_subfolder = Path(__file__).parent.parent
print(f"Subfolder to summarize: {summarize_subfolder}")

# Define the output file name based on the folder name
output_file_name = f"{summarize_subfolder.name}.txt"
output_file_path = Path(__file__).parent / "llm_summary" / output_file_name
print(f"Output file path: {output_file_path}")

# Ensure the output directory exists
output_file_path.parent.mkdir(parents=True, exist_ok=True)
print(f"Output directory ensured to exist: {output_file_path.parent}")

# Define folders to omit
omit_folders = ["Bald Eagle Creek", "__pycache__", ".git", ".github", "tests", "build", "dist", "ras_commander.egg-info", "venv", "example_projects", "llm_summary", "misc",]
print(f"Folders to omit: {omit_folders}")

# Define files or extensions to omit
omit_files = [".pyc", ".pyo", ".pyd", ".dll", ".so", ".dylib", ".exe", ".bat", ".sh", ".log", ".tmp", ".bak", ".swp", ".DS_Store", "Thumbs.db", "example_projects.zip", "Example_Projects_6_5.zip", "example_projects.ipynb",]
print(f"Files or extensions to omit: {omit_files}")

# Open the output file
with open(output_file_path, 'w', encoding='utf-8') as outfile:
    print(f"Opened output file: {output_file_path}")
    # Iterate over all files and subfolders in the summarize_subfolder directory
    for filepath in summarize_subfolder.rglob('*'):
        # Check if the file is not this script, not in the omit_folders, and not in omit_files
        if (filepath.name != this_script and 
            not any(omit_folder in filepath.parts for omit_folder in omit_folders) and
            not any(filepath.suffix == ext or filepath.name == ext for ext in omit_files)):
            # Write the filename or folder name
            if filepath.is_file():
                outfile.write(f"File: {filepath}\n")
                print(f"Writing file: {filepath}")
            else:
                outfile.write(f"Folder: {filepath}\n")
                print(f"Writing folder: {filepath}")
            outfile.write("="*50 + "\n")  # Separator
            
            # If it's a file, open and read the contents of the file
            if filepath.is_file():
                try:
                    with open(filepath, 'r', encoding='utf-8') as infile:
                        content = infile.read()
                        print(f"Reading content of file: {filepath}")
                except UnicodeDecodeError:
                    with open(filepath, 'rb') as infile:
                        content = infile.read()
                        content = content.decode('utf-8', errors='ignore')
                        print(f"Reading and converting content of file: {filepath}")
                
                # Write the contents to the output file
                outfile.write(content)
                print(f"Written content of file: {filepath}")
            
            # Write a separator after the file contents or folder name
            outfile.write("\n" + "="*50 + "\n\n")
            print(f"Written separator for: {filepath}")

print(f"All files and folders have been combined into '{output_file_path}'")
==================================================

File: c:\GH\ras-commander\ai_tools\llmsummarize 2. docs and code only.py
==================================================
from pathlib import Path

# Get the name of this script
this_script = Path(__file__).name
print(f"Script name: {this_script}")

# Define the subfolder to summarize
summarize_subfolder = Path(__file__).parent.parent
print(f"Subfolder to summarize: {summarize_subfolder}")

# Define the output file name based on the folder name
output_file_name = f"{summarize_subfolder.name}_code_only.txt"
output_file_path = Path(__file__).parent / "llm_summary" / output_file_name
print(f"Output file path: {output_file_path}")

# Ensure the output directory exists
output_file_path.parent.mkdir(parents=True, exist_ok=True)
print(f"Output directory ensured to exist: {output_file_path.parent}")

# Define folders to omit
omit_folders = ["Bald Eagle Creek", "__pycache__", ".git", ".github", "tests", "build", "dist", "ras_commander.egg-info", "venv", "example_projects", "llm_summary", "misc", "future", ".github"]
print(f"Folders to omit: {omit_folders}")

# Define files or extensions to omit
omit_files = [".pyc", ".pyo", ".pyd", ".dll", ".so", ".dylib", ".exe", ".bat", ".sh", ".log", ".tmp", ".bak", ".swp", ".DS_Store", "Thumbs.db", "example_projects.zip", "11_accessing_example_projects.ipynb", "Example_Projects_6_5.zip"]
print(f"Files or extensions to omit: {omit_files}")

# Open the output file
with open(output_file_path, 'w', encoding='utf-8') as outfile:
    print(f"Opened output file: {output_file_path}")
    # Iterate over all files and subfolders in the summarize_subfolder directory
    for filepath in summarize_subfolder.rglob('*'):
        # Check if the file is not this script, not in the omit_folders, and not in omit_files
        if (filepath.name != this_script and 
            not any(omit_folder in filepath.parts for omit_folder in omit_folders) and
            not any(filepath.suffix == ext or filepath.name == ext for ext in omit_files)):
            # Write the filename or folder name
            if filepath.is_file():
                outfile.write(f"File: {filepath}\n")
                print(f"Writing file: {filepath}")
            else:
                outfile.write(f"Folder: {filepath}\n")
                print(f"Writing folder: {filepath}")
            outfile.write("="*50 + "\n")  # Separator
            
            # If it's a file, open and read the contents of the file
            if filepath.is_file():
                try:
                    with open(filepath, 'r', encoding='utf-8') as infile:
                        content = infile.read()
                        print(f"Reading content of file: {filepath}")
                except UnicodeDecodeError:
                    with open(filepath, 'rb') as infile:
                        content = infile.read()
                        content = content.decode('utf-8', errors='ignore')
                        print(f"Reading and converting content of file: {filepath}")
                
                # Write the contents to the output file
                outfile.write(content)
                print(f"Written content of file: {filepath}")
            
            # Write a separator after the file contents or folder name
            outfile.write("\n" + "="*50 + "\n\n")
            print(f"Written separator for: {filepath}")

print(f"All files and folders have been combined into '{output_file_path}'")
==================================================

File: c:\GH\ras-commander\ai_tools\llmsummarize 3. documentation and docstrings.py
==================================================
from pathlib import Path
import ast

# Get the name of this script
this_script = Path(__file__).name
print(f"Script name: {this_script}")

# Define the subfolder to summarize
summarize_subfolder = Path(__file__).parent.parent
print(f"Subfolder to summarize: {summarize_subfolder}")

# Define the output file name based on the folder name
output_file_name = f"{summarize_subfolder.name}_code_structure.txt"
output_file_path = Path(__file__).parent / "llm_summary" / output_file_name
print(f"Output file path: {output_file_path}")

# Ensure the output directory exists
output_file_path.parent.mkdir(parents=True, exist_ok=True)
print(f"Output directory ensured to exist: {output_file_path.parent}")

# Define folders to omit
omit_folders = ["Bald Eagle Creek", "__pycache__", ".git", ".github", "tests", "build", "dist", "ras_commander.egg-info", "venv", "example_projects", "llm_summary", "misc", "future", ".github"]
print(f"Folders to omit: {omit_folders}")

# Define files or extensions to omit
omit_files = [".pyc", ".pyo", ".pyd", ".dll", ".so", ".dylib", ".exe", ".bat", ".sh", ".log", ".tmp", ".bak", ".swp", ".DS_Store", "Thumbs.db", "example_projects.zip", "11_accessing_example_projects.ipynb", "Example_Projects_6_5.zip"]
print(f"Files or extensions to omit: {omit_files}")

def extract_function_structure(node):
    if isinstance(node, ast.FunctionDef):
        docstring = ast.get_docstring(node)
        if docstring:
            return f"def {node.name}({', '.join(arg.arg for arg in node.args.args)}):\n    \"\"\"{docstring}\"\"\"\n"
        else:
            return f"def {node.name}({', '.join(arg.arg for arg in node.args.args)}):\n    pass\n"
    return ""

def process_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        content = file.read()
    
    tree = ast.parse(content)
    function_structures = []
    for node in ast.walk(tree):
        function_structures.append(extract_function_structure(node))
    
    return ''.join(function_structures)

# Open the output file
with open(output_file_path, 'w', encoding='utf-8') as outfile:
    print(f"Opened output file: {output_file_path}")
    # Iterate over all files and subfolders in the summarize_subfolder directory
    for filepath in summarize_subfolder.rglob('*'):
        # Check if the file is not this script, not in the omit_folders, and not in omit_files
        if (filepath.name != this_script and 
            not any(omit_folder in filepath.parts for omit_folder in omit_folders) and
            not any(filepath.suffix == ext or filepath.name == ext for ext in omit_files)):
            # Write the filename or folder name
            if filepath.is_file():
                outfile.write(f"File: {filepath}\n")
                print(f"Writing file: {filepath}")
            else:
                outfile.write(f"Folder: {filepath}\n")
                print(f"Writing folder: {filepath}")
            outfile.write("="*50 + "\n")  # Separator
            
            # If it's a file, process and write the function structures
            if filepath.is_file() and filepath.suffix == '.py':
                try:
                    function_structures = process_file(filepath)
                    outfile.write(function_structures)
                    print(f"Written function structures of file: {filepath}")
                except Exception as e:
                    print(f"Error processing file {filepath}: {str(e)}")
            
            # Write a separator after the file contents or folder name
            outfile.write("\n" + "="*50 + "\n\n")
            print(f"Written separator for: {filepath}")

print(f"All files and folders have been processed into '{output_file_path}'")
==================================================

File: c:\GH\ras-commander\ai_tools\ras-commander_gpt_instructions.txt
==================================================
# RAS Commander (ras-commander) Coding Assistant

## Overview

This Coding Assistant helps you write efficient and well-structured Python code for working with HEC-RAS projects using the RAS Commander (ras-commander) library.

**Key Features:**

* **Automates HEC-RAS tasks:** Streamlines project setup, plan execution, data management, and more.
* **Pythonic interface:** Leverages familiar Python libraries like pandas and pathlib for intuitive coding.
* **Flexible execution:** Supports single plan, sequential, and parallel execution modes.
* **Built-in examples:** Provides access to HEC-RAS example projects for learning and testing.

**Core Concepts:**

* **RAS Objects:** Represent HEC-RAS projects and their components (plans, geometry, flow files).
* **Project Initialization:** Use `init_ras_project()` to set up a project, choosing between global and custom instances.
* **File Handling:** pathlib.Path ensures consistent file path management across operating systems.
* **Data Management:** Pandas DataFrames organize project data for efficient manipulation.
* **Execution Modes:** Choose from single, sequential, or parallel execution based on project needs.
* **Utility Functions:** RasUtils provides common file operations and project management tasks.

## Classes, Functions and Arguments for ras_commander

Class/Function | Required Arguments | Optional Arguments
---------------|--------------------|--------------------|
RasPrj | | |
init_ras_project | ras_project_folder, ras_version | ras_instance
get_ras_exe | ras_version | - |
RasPlan | | |
set_geom | plan_number, new_geom | ras_object |
set_steady | plan_number, new_steady_flow_number | ras_object |
set_unsteady | plan_number, new_unsteady_flow_number | ras_object |
set_num_cores | plan_number, num_cores | ras_object |
clone_plan | template_plan | new_plan_shortid, ras_object |
RasGeo | | |
clear_geompre_files | | plan_files, ras_object |
RasUnsteady | | |
update_unsteady_parameters | unsteady_file, modifications | ras_object |
RasCmdr | | |
compute_plan | plan_number | dest_folder, ras_object, clear_geompre, num_cores, overwrite_dest |
compute_parallel | | plan_number, max_workers, num_cores, ras_object, dest_folder, overwrite_dest |
compute_test_mode | | plan_number, dest_folder_suffix, clear_geompre, num_cores, ras_object, overwrite_dest |
RasUtils | | |
create_backup | file_path | backup_suffix, ras_object |
restore_from_backup | backup_path | remove_backup, ras_object |
update_plan_file | plan_number_or_path, file_type, entry_number | ras_object |
RasExamples | | |
extract_project | project_names | - |

## Coding Assistance Rules:

Your role is building, refactoring and debugging Python scripts using Python 3.9+, focusing on automation tasks for HEC-RAS projects.

1. Prefer default libraries where possible, especially pathlib for file operations.
2. Use r-strings for file and directory path inputs.
3. Use f-strings for string formatting and concatenation.
4. Always use pathlib over os for manipulation of file and directory paths.
5. Print DataFrame names and variable names before displaying DataFrames.
6. Prefer pandas for data manipulation and analysis tasks.
7. Use matplotlib or bokeh for visualization when needed.
8. Always include comments for code readability and explain complex operations.
9. Use logging for informative output and debugging information.
10. Follow PEP 8 conventions for code style.
11. Provide clear error handling and user feedback.
12. When using RAS Commander functions, explain their purpose and key arguments.
13. Encourage consistent use of either global 'ras' object or custom instances throughout scripts.
14. Highlight best practices for parallel execution and performance optimization.
15. Suggest using RasExamples for testing and learning purposes when appropriate.

When revising code, write planning steps as comments before implementation, labeled as:
## Explicit Planning and Reasoning for Revisions

For geodataframes, use the 'union_all()' method instead of the deprecated 'unary_union' attribute.

Note for pandas >= 2.0: Use pd.concat instead of the removed append method.

Always provide full code segments with no elides.

## Knowledge Files

When coding new RAS workflows, always refer to the Comprehensive Library Guide via retrieval: Comprehensive_Library_Guide.md

When coding new library functions, always refer to the Style Guide  via retrieval: 
STYLE_GUIDE.md

You have a text file with the entire repository's contents, that can be used for file search and retrieval. 

You also have a .zip file with the entire RAS-Commander library from github, containing full copies of all files.  Use your code interpreter to extract and read existing files in their entirety whenever your chunked retrieval is incomplete.  You can read up to 20,000 characters at a time (usually enough for the whole file). 

# Now, Analyze and Respond to the User's Query

When revising code, always provide full code segments without elisions.

-----
==================================================

File: c:\GH\ras-commander\ai_tools\rascommander_code_assistant.ipynb
==================================================
{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# RAS-Commander Code Assistant\n",
    "\n",
    "Alpha, this only works with Claude 3.5 Sonnet for now\n",
    "\n",
    "Future devlopement will include multi-turn support and ability to select between different models\n",
    "\n",
    "Provide your own API key to make this work.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "# User query\n",
    "user_query = \"\"\"   Make a table for each class file in the library with all functions, their arguments (with typing/expected input), and a short summary of the function's purpose.\n",
    "\n",
    "\"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define files, folders and extensions to omit\n",
    "omit_folders = [\n",
    "    \"Bald Eagle Creek\", \n",
    "    \"__pycache__\", \n",
    "    \".git\", \n",
    "    \".github\", \n",
    "    \"tests\", \n",
    "    \"build\", \n",
    "    \"dist\", \n",
    "    \"ras_commander.egg-info\", \n",
    "    \"venv\", \n",
    "    \"example_projects\", \n",
    "    \"llm_summary\", \"misc\", \"future\", \"ai_tools\"\n",
    "]\n",
    "\n",
    "# Define file extensions to omit\n",
    "omit_extensions = [\n",
    "    # Common image file extensions\n",
    "    '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.webp', '.svg', '.ico',\n",
    "    # Other binary file extensions\n",
    "    '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx',\n",
    "    '.zip', '.rar', '.7z', '.tar', '.gz',\n",
    "    '.exe', '.dll', '.so', '.dylib',\n",
    "    '.pyc', '.pyo', '.pyd',  # Python bytecode and compiled files\n",
    "    '.class',  # Java bytecode\n",
    "    '.log', '.tmp', '.bak', '.swp',  # Temporary and backup files\n",
    "    '.bat', '.sh',  # Script files\n",
    "]\n",
    "\n",
    "# Define files to omit based on keywords\n",
    "omit_files = [\n",
    "    'FunctionList.md',\n",
    "    'DS_Store',\n",
    "    'Thumbs.db',\n",
    "    'llmsummarize'\n",
    "    'example_projects.zip',\n",
    "    '11_accessing_example_projects.ipynb',\n",
    "    'Example_Projects_6_5.zip'\n",
    "    'github_code_assistant.ipynb',\n",
    "    'example_projects.ipynb',\n",
    "    '11_Using_RasExamples.ipynb',\n",
    "    'example_projects.csv',\n",
    "    'rascommander_code_assistant.ipynb',\n",
    "    'RasExamples.py'\n",
    "]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Successfully imported pandas\n",
      "Successfully imported anthropic\n",
      "Successfully imported tiktoken\n",
      "Successfully imported IPython.display\n",
      "Successfully imported astor\n",
      "All required packages have been installed and imported successfully.\n"
     ]
    }
   ],
   "source": [
    "# Install necessary packages\n",
    "def install_and_import(package_name, import_name=None):\n",
    "    import subprocess\n",
    "    import sys\n",
    "    if import_name is None:\n",
    "        import_name = package_name\n",
    "    try:\n",
    "        __import__(import_name)\n",
    "    except ImportError:\n",
    "        subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", package_name])\n",
    "        __import__(import_name)\n",
    "    print(f\"Successfully imported {import_name}\")\n",
    "\n",
    "install_and_import(\"pandas\")\n",
    "install_and_import(\"anthropic\")\n",
    "install_and_import(\"tiktoken\")\n",
    "install_and_import(\"IPython\", \"IPython.display\")\n",
    "install_and_import(\"astor\")\n",
    "\n",
    "import os\n",
    "from pathlib import Path\n",
    "import pandas as pd\n",
    "import anthropic\n",
    "import tiktoken\n",
    "import astor\n",
    "from IPython.display import display, clear_output\n",
    "\n",
    "print(\"All required packages have been installed and imported successfully.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Set API Key\n",
    "#os.environ[\"ANTHROPIC_API_KEY\"] = 'YOUR KEY HERE'\n",
    "\n",
    "\n",
    "# Alternately, you can set the key from the file Anthropic_API_Key.txt\n",
    "with open('C:\\SCRATCH\\Anthropic_API_Key.txt', 'r') as file:\n",
    "    os.environ[\"ANTHROPIC_API_KEY\"] = file.read().strip()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "System message loaded successfully.\n"
     ]
    }
   ],
   "source": [
    "# Define system message from the ras_commander .cursorrules file\n",
    "from pathlib import Path\n",
    "\n",
    "def read_system_message():\n",
    "    # Get the current notebook's directory\n",
    "    current_dir = Path.cwd()\n",
    "    \n",
    "    # Path to the .cursorrules file (assuming it's in the parent directory)\n",
    "    cursor_rules_path = current_dir.parent / '.cursorrules'\n",
    "\n",
    "    # Check if .cursorrules exists\n",
    "    if not cursor_rules_path.exists():\n",
    "        raise FileNotFoundError(\"This notebook expects to be in a directory within the ras_commander repo which has a .cursorrules file in its parent directory.\")\n",
    "\n",
    "    # Read the .cursorrules file as plain text\n",
    "    with open(cursor_rules_path, 'r') as f:\n",
    "        system_message = f.read().strip()\n",
    "\n",
    "    if not system_message:\n",
    "        raise ValueError(\"No system message found in .cursorrules file.\")\n",
    "\n",
    "    return system_message\n",
    "\n",
    "# Read the system message from .cursorrules\n",
    "system_message = read_system_message()\n",
    "\n",
    "print(\"System message loaded successfully.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Context folder set to: c:\\GH\\ras_commander\n"
     ]
    }
   ],
   "source": [
    "# Define folder as the parent folder (since this notebook lives in the ai_tools folder)\n",
    "# Get the current notebook's directory\n",
    "current_dir = Path.cwd()\n",
    "\n",
    "# Set the context folder to the parent of the current directory\n",
    "context_folder = current_dir.parent\n",
    "\n",
    "print(f\"Context folder set to: {context_folder}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Notebook name: ai_tools\n",
      "Subfolder to summarize: c:\\GH\\ras_commander\n",
      "Output file path: c:\\GH\\ras_commander\\llm_summary\\ras_commander_code_only.txt\n",
      "Output directory ensured to exist: c:\\GH\\ras_commander\\llm_summary\n",
      "Opened output file: c:\\GH\\ras_commander\\llm_summary\\ras_commander_code_only.txt\n",
      "All files and folders have been combined into 'c:\\GH\\ras_commander\\llm_summary\\ras_commander_code_only.txt'\n",
      "Notebook name: ai_tools\n",
      "Subfolder to summarize: c:\\GH\\ras_commander\n",
      "Output file path: c:\\GH\\ras_commander\\llm_summary\\ras_commander_code_only_stripped.txt\n",
      "Output directory ensured to exist: c:\\GH\\ras_commander\\llm_summary\n",
      "Opened output file: c:\\GH\\ras_commander\\llm_summary\\ras_commander_code_only_stripped.txt\n",
      "All files and folders have been combined into 'c:\\GH\\ras_commander\\llm_summary\\ras_commander_code_only_stripped.txt'\n"
     ]
    }
   ],
   "source": [
    "# Function to compile codebase, omitting specified folders, extensions, and files\n",
    "\n",
    "import tiktoken\n",
    "from pathlib import Path\n",
    "\n",
    "def strip_code_from_functions(content):\n",
    "    \"\"\"\n",
    "    Strip the code from functions, leaving only function signatures and docstrings.\n",
    "    \n",
    "    Args:\n",
    "    content (str): The content of a Python file.\n",
    "    \n",
    "    Returns:\n",
    "    str: The content with function bodies removed.\n",
    "    \"\"\"\n",
    "    import ast\n",
    "    import astor\n",
    "\n",
    "    class FunctionStripper(ast.NodeTransformer):\n",
    "        def visit_FunctionDef(self, node):\n",
    "            # Keep the function signature and docstring (if present)\n",
    "            new_node = ast.FunctionDef(\n",
    "                name=node.name,\n",
    "                args=node.args,\n",
    "                body=[ast.Pass()],  # Replace the body with a pass statement\n",
    "                decorator_list=node.decorator_list,\n",
    "                returns=node.returns\n",
    "            )\n",
    "            # If there's a docstring, keep it\n",
    "            if (len(node.body) > 0 and isinstance(node.body[0], ast.Expr) and\n",
    "                isinstance(node.body[0].value, ast.Str)):\n",
    "                new_node.body = [node.body[0], ast.Pass()]\n",
    "            return new_node\n",
    "\n",
    "    try:\n",
    "        tree = ast.parse(content)\n",
    "        stripped_tree = FunctionStripper().visit(tree)\n",
    "        return astor.to_source(stripped_tree)\n",
    "    except SyntaxError:\n",
    "        # If parsing fails, return the original content\n",
    "        return content\n",
    "\n",
    "def combine_files(summarize_subfolder, omit_folders, omit_extensions, omit_files, strip_code=False):\n",
    "    combined_text = \"\"\n",
    "    file_token_counts = {}\n",
    "    \n",
    "    # Get the name of this notebook\n",
    "    this_notebook = Path.cwd().name\n",
    "    print(f\"Notebook name: {this_notebook}\")\n",
    "\n",
    "    # Ensure summarize_subfolder is a Path object\n",
    "    summarize_subfolder = Path(summarize_subfolder)\n",
    "    print(f\"Subfolder to summarize: {summarize_subfolder}\")\n",
    "\n",
    "    # Define the output file name based on the folder name\n",
    "    output_file_name = f\"{summarize_subfolder.name}_code_only{'_stripped' if strip_code else ''}.txt\"\n",
    "    output_file_path = Path.cwd().parent / \"llm_summary\" / output_file_name\n",
    "    print(f\"Output file path: {output_file_path}\")\n",
    "\n",
    "    # Ensure the output directory exists\n",
    "    output_file_path.parent.mkdir(parents=True, exist_ok=True)\n",
    "    print(f\"Output directory ensured to exist: {output_file_path.parent}\")\n",
    "\n",
    "    # Initialize tokenizer\n",
    "    enc = tiktoken.encoding_for_model(\"gpt-3.5-turbo\")\n",
    "\n",
    "    # Open the output file\n",
    "    with open(output_file_path, 'w', encoding='utf-8') as outfile:\n",
    "        print(f\"Opened output file: {output_file_path}\")\n",
    "        # Iterate over all files and subfolders in the summarize_subfolder directory\n",
    "        for filepath in summarize_subfolder.rglob('*'):\n",
    "            # Check if the file is not this notebook, not in the omit_folders, not in omit_extensions, and not in omit_files\n",
    "            if (filepath.name != this_notebook and \n",
    "                not any(omit_folder in filepath.parts for omit_folder in omit_folders) and\n",
    "                filepath.suffix.lower() not in omit_extensions and\n",
    "                not any(omit_file in filepath.name for omit_file in omit_files)):\n",
    "                # Write the filename or folder name\n",
    "                if filepath.is_file():\n",
    "                    outfile.write(f\"File: {filepath}\\n\")\n",
    "                else:\n",
    "                    outfile.write(f\"Folder: {filepath}\\n\")\n",
    "                outfile.write(\"=\"*50 + \"\\n\")  # Separator\n",
    "                \n",
    "                # If it's a file, open and read the contents of the file\n",
    "                if filepath.is_file():\n",
    "                    try:\n",
    "                        with open(filepath, 'r', encoding='utf-8') as infile:\n",
    "                            content = infile.read()\n",
    "                    except UnicodeDecodeError:\n",
    "                        with open(filepath, 'rb') as infile:\n",
    "                            content = infile.read()\n",
    "                            content = content.decode('utf-8', errors='ignore')\n",
    "                    \n",
    "                    # Strip code if the option is enabled and it's a Python file\n",
    "                    if strip_code and filepath.suffix.lower() == '.py':\n",
    "                        content = strip_code_from_functions(content)\n",
    "                    \n",
    "                    # Write the contents to the output file\n",
    "                    outfile.write(content)\n",
    "                    \n",
    "                    # Count tokens for this file\n",
    "                    file_tokens = len(enc.encode(content))\n",
    "                    file_token_counts[str(filepath)] = file_tokens\n",
    "                \n",
    "                # Write a separator after the file contents or folder name\n",
    "                outfile.write(\"\\n\" + \"=\"*50 + \"\\n\\n\")\n",
    "            else:\n",
    "                dummy = 0\n",
    "\n",
    "    print(f\"All files and folders have been combined into '{output_file_path}'\")\n",
    "\n",
    "    # Count total tokens\n",
    "    with open(output_file_path, 'r', encoding='utf-8') as f:\n",
    "        combined_text = f.read()\n",
    "    token_count = len(enc.encode(combined_text))\n",
    "    \n",
    "    return combined_text, token_count, file_token_counts\n",
    "\n",
    "\n",
    "# Combine files while keeping code\n",
    "combined_text, token_count, file_token_counts = combine_files(context_folder, omit_folders, omit_extensions, omit_files)\n",
    "\n",
    "# Combine files while stripping code\n",
    "combined_text, token_count, file_token_counts = combine_files(context_folder, omit_folders, omit_extensions, omit_files, strip_code=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Top 20 files by token count:\n",
      "c:\\GH\\ras_commander\\future_dev_roadmap.ipynb: 7807 tokens\n",
      "c:\\GH\\ras_commander\\ras_commander\\RasPlan.py: 3796 tokens\n",
      "c:\\GH\\ras_commander\\Comprehensive_Library_Guide.md: 2391 tokens\n",
      "c:\\GH\\ras_commander\\README.md: 2071 tokens\n",
      "c:\\GH\\ras_commander\\ras_commander\\RasPrj.py: 1711 tokens\n",
      "c:\\GH\\ras_commander\\ras_commander\\RasUtils.py: 1507 tokens\n",
      "c:\\GH\\ras_commander\\STYLE_GUIDE.md: 1461 tokens\n",
      "c:\\GH\\ras_commander\\ras_commander\\RasCommander.py: 1392 tokens\n",
      "c:\\GH\\ras_commander\\ras_commander\\README.md: 1250 tokens\n",
      "c:\\GH\\ras_commander\\examples\\14_Core_Sensitivity.ipynb: 1174 tokens\n",
      "c:\\GH\\ras_commander\\.cursorrules: 1107 tokens\n",
      "c:\\GH\\ras_commander\\examples\\02_plan_operations.py: 484 tokens\n",
      "c:\\GH\\ras_commander\\ras_commander\\RasGeo.py: 387 tokens\n",
      "c:\\GH\\ras_commander\\ras_commander\\__init__.py: 241 tokens\n",
      "c:\\GH\\ras_commander\\pyproject.toml: 239 tokens\n",
      "c:\\GH\\ras_commander\\examples\\07_sequential_plan_execution.py: 239 tokens\n",
      "c:\\GH\\ras_commander\\examples\\09_specifying_plans.py: 239 tokens\n",
      "c:\\GH\\ras_commander\\updated_pyproject.toml: 198 tokens\n",
      "c:\\GH\\ras_commander\\ras_commander\\RasUnsteady.py: 196 tokens\n",
      "c:\\GH\\ras_commander\\examples\\13_multiple_project_operations.py: 194 tokens\n"
     ]
    }
   ],
   "source": [
    "# Sort files by token count and get top 20\n",
    "top_20_files = sorted(file_token_counts.items(), key=lambda x: x[1], reverse=True)[:20]\n",
    "\n",
    "print(\"\\nTop 20 files by token count:\")\n",
    "for file, count in top_20_files:\n",
    "    print(f\"{file}: {count} tokens\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Combined text token count: 30526\n"
     ]
    }
   ],
   "source": [
    "# Check the total token count\n",
    "print(f\"Combined text token count: {token_count}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Pricing DataFrame:\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Model</th>\n",
       "      <th>Input ($/MTok)</th>\n",
       "      <th>Output ($/MTok)</th>\n",
       "      <th>Prompt Caching Write ($/MTok)</th>\n",
       "      <th>Prompt Caching Read ($/MTok)</th>\n",
       "      <th>Context Window</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>Claude 3.5 Sonnet</td>\n",
       "      <td>3</td>\n",
       "      <td>15</td>\n",
       "      <td>3.75</td>\n",
       "      <td>0.3</td>\n",
       "      <td>200000</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "               Model  Input ($/MTok)  Output ($/MTok)  \\\n",
       "0  Claude 3.5 Sonnet               3               15   \n",
       "\n",
       "   Prompt Caching Write ($/MTok)  Prompt Caching Read ($/MTok)  Context Window  \n",
       "0                           3.75                           0.3          200000  "
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Estimated cost: $0.2146\n"
     ]
    }
   ],
   "source": [
    "# Set up Anthropic client\n",
    "def stream_response(client, full_prompt, max_tokens=4096):\n",
    "    response_text = \"\"\n",
    "    with client.messages.stream(\n",
    "        max_tokens=max_tokens,\n",
    "        messages=[\n",
    "            {\"role\": \"user\", \"content\": full_prompt}\n",
    "        ],\n",
    "        model=\"claude-3-sonnet-20240229\"\n",
    "    ) as stream:\n",
    "        for text in stream.text_stream:\n",
    "            response_text += text\n",
    "            clear_output(wait=True)\n",
    "            print(\"Claude's response:\")\n",
    "            print(response_text)\n",
    "            \n",
    "    return response_text\n",
    "\n",
    "def estimate_cost(input_tokens, output_tokens, pricing_df):\n",
    "    model = \"Claude 3.5 Sonnet\"\n",
    "    input_cost = (input_tokens / 1e6) * pricing_df.loc[pricing_df['Model'] == model, 'Input ($/MTok)'].values[0]\n",
    "    output_cost = (output_tokens / 1e6) * pricing_df.loc[pricing_df['Model'] == model, 'Output ($/MTok)'].values[0]\n",
    "    return input_cost + output_cost\n",
    "\n",
    "\n",
    "# Set up Anthropic client\n",
    "client = anthropic.Anthropic(api_key=os.environ.get(\"ANTHROPIC_API_KEY\"))\n",
    "\n",
    "# Create pricing dataframe\n",
    "pricing_data = {\n",
    "    \"Model\": [\"Claude 3.5 Sonnet\"],\n",
    "    \"Input ($/MTok)\": [3],\n",
    "    \"Output ($/MTok)\": [15],\n",
    "    \"Prompt Caching Write ($/MTok)\": [3.75],\n",
    "    \"Prompt Caching Read ($/MTok)\": [0.30],\n",
    "    \"Context Window\": [200000]\n",
    "}\n",
    "\n",
    "pricing_df = pd.DataFrame(pricing_data)\n",
    "print(\"Pricing DataFrame:\")\n",
    "display(pricing_df)\n",
    "\n",
    "# Combine system message, context, and user query\n",
    "full_prompt = f\"{system_message}\\n\\nContext:\\n{combined_text}\\n\\n\\n\\n\\nUser Query: {user_query}\"\n",
    "\n",
    "# Estimate cost\n",
    "enc = tiktoken.encoding_for_model(\"gpt-3.5-turbo\")\n",
    "input_tokens = token_count + len(enc.encode(user_query))\n",
    "output_tokens = 8192 # assuming full response\n",
    "estimated_cost = estimate_cost(input_tokens, output_tokens, pricing_df)\n",
    "\n",
    "print(f\"\\nEstimated cost: ${estimated_cost:.4f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### See the cost per message above, and add additional file/folder filters if desired"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "ename": "ValueError",
     "evalue": "This is a test error to prevent automatically querying model and incurring costs",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[11], line 2\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[38;5;66;03m# raise error to prevent automatically querying model and incurring costs\u001b[39;00m\n\u001b[1;32m----> 2\u001b[0m \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mValueError\u001b[39;00m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mThis is a test error to prevent automatically querying model and incurring costs\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n",
      "\u001b[1;31mValueError\u001b[0m: This is a test error to prevent automatically querying model and incurring costs"
     ]
    }
   ],
   "source": [
    "# raise error to prevent automatically querying model and incurring costs\n",
    "raise ValueError(\"This is a test error to prevent automatically querying model and incurring costs\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Claude's response:\n",
      "Sure, here's a table for each class file in the ras_commander library, with all functions, their arguments (with typing/expected input), and a short summary of the function's purpose.\n",
      "\n",
      "1. `RasCommander.py`\n",
      "\n",
      "| Function | Arguments | Summary |\n",
      "|----------|-----------|---------|\n",
      "| `compute_plan` | `plan_number: str`, `compute_folder: Optional[Union[str, Path]] = None`, `ras_object: Optional[RasPrj] = None` | Execute a HEC-RAS plan. |\n",
      "| `compute_test_mode` | `plan_numbers: Optional[List[str]] = None`, `folder_suffix: str = '[Test]'`, `clear_geompre: bool = False`, `max_cores: Optional[int] = None`, `ras_object: Optional[RasPrj] = None` | Execute HEC-RAS plans in test mode. |\n",
      "| `compute_parallel` | `plan_numbers: Optional[List[str]] = None`, `max_workers: int = 2`, `cores_per_run: int = 2`, `ras_object: Optional[RasPrj] = None`, `dest_folder: Optional[Union[str, Path]] = None` | Execute HEC-RAS plans in parallel using multiple worker threads. |\n",
      "| `worker_thread` | `worker_id: int` | A worker thread function for parallel execution. |\n",
      "\n",
      "2. `RasGeo.py`\n",
      "\n",
      "| Function | Arguments | Summary |\n",
      "|----------|-----------|---------|\n",
      "| `clear_geompre_files` | `plan_files: Optional[Union[str, Path, List[Union[str, Path]]]] = None`, `ras_object: Optional[RasPrj] = None` | Clear HEC-RAS geometry preprocessor files. |\n",
      "\n",
      "3. `RasPlan.py`\n",
      "\n",
      "| Function | Arguments | Summary |\n",
      "|----------|-----------|---------|\n",
      "| `set_geom` | `plan_number: Union[str, int]`, `new_geom: Union[str, int]`, `ras_object: Optional[RasPrj] = None` | Set the geometry for the specified plan. |\n",
      "| `set_steady` | `plan_number: str`, `new_steady_flow_number: str`, `ras_object: Optional[RasPrj] = None` | Apply a steady flow file to a plan file. |\n",
      "| `set_unsteady` | `plan_number: str`, `new_unsteady_flow_number: str`, `ras_object: Optional[RasPrj] = None` | Apply an unsteady flow file to a plan file. |\n",
      "| `set_num_cores` | `plan_number: Union[str, Path]`, `num_cores: int`, `ras_object: Optional[RasPrj] = None` | Update the maximum number of cores to use in the HEC-RAS plan file. |\n",
      "| `set_geom_preprocessor` | `file_path: Union[str, Path]`, `run_htab: int`, `use_ib_tables: int`, `ras_object: Optional[RasPrj] = None` | Update the simulation plan file to modify the 'Run HTab' and 'UNET Use Existing IB Tables' settings. |\n",
      "| `get_results_path` | `plan_number: str`, `ras_object: Optional[RasPrj] = None` | Retrieve the results file path for a given HEC-RAS plan number. |\n",
      "| `get_plan_path` | `plan_number: str`, `ras_object: Optional[RasPrj] = None` | Return the full path for a given plan number. |\n",
      "| `get_flow_path` | `flow_number: str`, `ras_object: Optional[RasPrj] = None` | Return the full path for a given flow number. |\n",
      "| `get_unsteady_path` | `unsteady_number: str`, `ras_object: Optional[RasPrj] = None` | Return the full path for a given unsteady number. |\n",
      "| `get_geom_path` | `geom_number: str`, `ras_object: Optional[RasPrj] = None` | Return the full path for a given geometry number. |\n",
      "| `clone_plan` | `template_plan: str`, `new_plan_shortid: Optional[str] = None`, `ras_object: Optional[RasPrj] = None` | Create a new plan file based on a template and update the project file. |\n",
      "| `clone_unsteady` | `template_unsteady: str`, `ras_object: Optional[RasPrj] = None` | Copy unsteady flow files from a template, find the next unsteady number, and update the project file accordingly. |\n",
      "| `clone_steady` | `template_flow: str`, `ras_object: Optional[RasPrj] = None` | Copy steady flow files from a template, find the next flow number, and update the project file accordingly. |\n",
      "| `clone_geom` | `template_geom: str`, `ras_object: Optional[RasPrj] = None` | Copy geometry files from a template, find the next geometry number, and update the project file accordingly. |\n",
      "| `get_next_number` | `existing_numbers: List[str]` | Determine the next available number from a list of existing numbers. |\n",
      "\n",
      "4. `RasPrj.py`\n",
      "\n",
      "| Function | Arguments | Summary |\n",
      "|----------|-----------|---------|\n",
      "| `__init__` | - | Initialize a RasPrj instance. |\n",
      "| `initialize` | `project_folder: Union[str, Path]`, `ras_exe_path: Union[str, Path]` | Initialize a RasPrj instance with the given project folder and RAS executable path. |\n",
      "| `_load_project_data` | - | Load project data from the HEC-RAS project file. |\n",
      "| `_get_prj_entries` | `entry_type: str` | Extract entries of a specific type from the HEC-RAS project file. |\n",
      "| `is_initialized` | - | Check if the RasPrj instance has been initialized. |\n",
      "| `check_initialized` | - | Ensure that the RasPrj instance has been initialized. |\n",
      "| `find_ras_prj` | `folder_path: Union[str, Path]` | Find the appropriate HEC-RAS project file (.prj) in the given folder. |\n",
      "| `get_project_name` | - | Get the name of the HEC-RAS project. |\n",
      "| `get_prj_entries` | `entry_type: str` | Get entries of a specific type from the HEC-RAS project. |\n",
      "| `get_plan_entries` | - | Get all plan entries from the HEC-RAS project. |\n",
      "| `get_flow_entries` | - | Get all flow entries from the HEC-RAS project. |\n",
      "| `get_unsteady_entries` | - | Get all unsteady flow entries from the HEC-RAS project. |\n",
      "| `get_geom_entries` | - | Get all geometry entries from the HEC-RAS project. |\n",
      "| `get_hdf_entries` | - | Get HDF entries for plans that have results. |\n",
      "| `print_data` | - | Print all RAS Object data for this instance. |\n",
      "| `init_ras_project` | `ras_project_folder: str`, `ras_version: str`, `ras_instance: Optional[RasPrj] = None` | Initialize a RAS project. |\n",
      "| `get_ras_exe` | `ras_version: str` | Determine the HEC-RAS executable path based on the input. |\n",
      "\n",
      "5. `RasUnsteady.py`\n",
      "\n",
      "| Function | Arguments | Summary |\n",
      "|----------|-----------|---------|\n",
      "| `update_unsteady_parameters` | `unsteady_file: Union[str, Path]`, `modifications: Dict[str, Any]`, `ras_object: Optional[RasPrj] = None` | Modify parameters in an unsteady flow file. |\n",
      "\n",
      "6. `RasUtils.py`\n",
      "\n",
      "| Function | Arguments | Summary |\n",
      "|----------|-----------|---------|\n",
      "| `create_backup` | `file_path: Path`, `backup_suffix: str = '_backup'`, `ras_object: Optional[RasPrj] = None` | Create a backup of the specified file. |\n",
      "| `restore_from_backup` | `backup_path: Path`, `remove_backup: bool = True`, `ras_object: Optional[RasPrj] = None` | Restore a file from its backup. |\n",
      "| `create_directory` | `directory_path: Path`, `ras_object: Optional[RasPrj] = None` | Ensure that a directory exists, creating it if necessary. |\n",
      "| `find_files_by_extension` | `extension: str`, `ras_object: Optional[RasPrj] = None` | List all files in the project directory with a specific extension. |\n",
      "| `get_file_size` | `file_path: Path`, `ras_object: Optional[RasPrj] = None` | Get the size of a file in bytes. |\n",
      "| `get_file_modification_time` | `file_path: Path`, `ras_object: Optional[RasPrj] = None` | Get the last modification time of a file. |\n",
      "| `get_plan_path` | `current_plan_number_or_path: Union[str, Path]`, `ras_object: Optional[RasPrj] = None` | Get the path for a plan file with a given plan number or path. |\n",
      "| `remove_with_retry` | `path: Path`, `max_attempts: int = 5`, `initial_delay: float = 1.0`, `is_folder: bool = True`, `ras_object: Optional[RasPrj] = None` | Attempts to remove a file or folder with retry logic and exponential backoff. |\n",
      "| `update_plan_file` | `plan_number_or_path: Union[str, Path]`, `file_type: str`, `entry_number: int`, `ras_object: Optional[RasPrj] = None` | Update a plan file with a new file reference. |\n",
      "| `check_file_access` | `file_path: Union[str, Path]`, `mode: str = 'r'` | Check if a file can be accessed with the specified mode. |\n",
      "\n",
      "7. `RasExamples.py`\n",
      "\n",
      "| Function | Arguments | Summary |\n",
      "|----------|-----------|---------|\n",
      "| `__init__` | - | Initialize the RasExamples class. |\n",
      "| `get_example_projects` | `version_number: Optional[str] = None` | Get the available example projects for the specified version. |\n",
      "| `list_categories` | - | List the available categories of example projects. |\n",
      "| `list_projects` | `category: Optional[str] = None` | List the available example projects in a given category. |\n",
      "| `extract_project` | `project_names: Union[str, List[str]]` | Extract the specified example project(s) to the local file system. |\n",
      "| `clean_projects_directory` | - | Clean the directory where example projects are extracted. |\n",
      "\n",
      "Please note that these tables are based on the code provided, and the actual implementation details may vary.\n"
     ]
    }
   ],
   "source": [
    "# Stream Claude's response\n",
    "response_text = stream_response(client, full_prompt)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "-----"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Example Response"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Claude's response:\n",
    "Sure, I'll review the code and identify any duplicate or redundant sections that can be removed or consolidated to reduce the overall size of the library.\n",
    "\n",
    "1. `RasFolderInit.py`:\n",
    "   - The `get_plan_entries`, `get_flow_entries`, `get_unsteady_entries`, and `get_geom_entries` functions follow a similar pattern. They can be consolidated into a single function that takes a file type as an argument.\n",
    "   - The `find_ras_prj` function could potentially be merged with the `get_project_name` function, as they both operate on project file paths.\n",
    "\n",
    "2. `RasPlan.py`:\n",
    "   - The `get_plan_path`, `get_flow_path`, `get_unsteady_path`, and `get_geom_path` functions are very similar and could be combined into a single function that takes a file type and number as arguments.\n",
    "   - The `set_geom`, `set_flow`, and `set_unsteady` functions have a lot of overlapping code, particularly for updating plan files. These could be consolidated into a single function that takes the file type and number as arguments.\n",
    "\n",
    "3. `RasUtils.py`:\n",
    "   - The `create_backup` and `restore_from_backup` functions have some overlap in their logic and could potentially be combined into a single function with an additional argument to specify whether to create or restore a backup.\n",
    "   - The `remove_file` function could be merged with `remove_folder_with_retry` by adding an optional argument to handle file removal.\n",
    "\n",
    "4. `RasCommander.py`:\n",
    "   - The `compute_plan` and `compute_plan_from_folder` functions have a lot of overlapping code. These could be combined into a single function with an optional argument to specify the folder path.\n",
    "\n",
    "5. `RasPrj.py`:\n",
    "   - The `find_ras_prj` function is already present in `RasFolderInit.py`, so it could be removed from this module.\n",
    "   - The `load_project_data` function is not used anywhere else in the codebase, so it could be removed unless it has a planned future use.\n",
    "\n",
    "After consolidating these functions and removing any redundant code, the overall size of the library should be reduced. However, it's important to ensure that the functionality remains intact and that any changes are thoroughly tested.\n",
    "\n",
    "Estimated cost: $0.2435\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "freshcmdr_311",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}

==================================================

File: c:\GH\ras-commander\ai_tools\README.md
==================================================
# AI Tools and Scripts for the RAS Commander Repository

This folder contains AI tools and scripts for the RAS Commander repository.

==================================================

File: c:\GH\ras-commander\examples\01_project_initialization.py
==================================================
# 01_project_initialization.py

#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek", "BaldEagleCrkMulti2D", "Muncie"])

#### --- START OF SCRIPT --- ####

# RAS Commander Library Notes:
# 1. This example demonstrates both the default global 'ras' object and custom ras objects.
# 2. The global 'ras' object is suitable for simple scripts working with a single project.
# 3. Custom ras objects are recommended for complex scripts or when working with multiple projects.
# 4. The init_ras_project function initializes a project and sets up the ras object.
# 5. Each ras object contains information about its project, including plan, geometry, and flow files.

# Best Practices:
# 1. For simple scripts working with a single project, using the global 'ras' object is fine.
# 2. For complex scripts or when working with multiple projects, create and use separate ras objects.
# 3. Be consistent in your approach: don't mix global and non-global ras object usage in the same script.
# 4. Use descriptive names for custom ras objects to clearly identify different projects.

def main():
    # Get the current script's directory
    current_dir = Path(__file__).parent
    
    # Define paths to example projects
    bald_eagle_path = current_dir.parent / "examples" / "example_projects" / "Balde Eagle Creek"
    multi_2d_path = current_dir.parent / "examples" / "example_projects" / "BaldEagleCrkMulti2D"
    muncie_path = current_dir.parent / "examples" / "example_projects" / "Muncie"

    print("Example Set 1: Using the default global 'ras' object")
    print("-----------------------------------------------------")

    # Initialize using the global RAS instance
    print("Step 1: Initializing with global RAS instance")
    init_ras_project(bald_eagle_path, "6.5") # This will set the global 'ras' object
    ras.print_data()  # Using the class method

    # Demonstrate accessing specific data
    print("\nStep 2: Demonstrating accessing specific data")
    print("Global RAS instance (Bald Eagle Creek) first plan file:")
    print(ras.plan_df.iloc[0] if not ras.plan_df.empty else "No plan files")
    
    print("\nStep 3: Accessing All RAS Object Data")
    print(f"Project Name: {ras.get_project_name()}")
    print(f"Project Folder: {ras.project_folder}")
    print(f"PRJ File: {ras.prj_file}")
    print(f"HEC-RAS Executable Path: {ras.ras_exe_path}")
    
    print("\nPlan Files DataFrame:")
    print(ras.plan_df)
    
    print("\nFlow Files DataFrame:")
    print(ras.flow_df)
    
    print("\nUnsteady Flow Files DataFrame:")
    print(ras.unsteady_df)
    
    print("\nGeometry Files DataFrame:")
    print(ras.geom_df)
    
    print("\nHDF Entries DataFrame:")
    print(ras.get_hdf_entries())

    print("\nExample Set 2: Using custom ras objects")
    print("-----------------------------------------------------")

    # Initialize multiple project instances
    print("Step 1: Initializing multiple project instances")
    multi_2d_project = init_ras_project(multi_2d_path, "6.5")
    muncie_project = init_ras_project(muncie_path, "6.5")

    print("\nMulti2D project data:")    
    multi_2d_project.print_data()
    print("\nMuncie project data:")
    muncie_project.print_data()

    # Demonstrate accessing specific data from custom ras objects
    print("\nStep 2: Accessing specific data from custom ras objects")
    print("Multi2D project first geometry file:")
    print(multi_2d_project.geom_df.iloc[0] if not multi_2d_project.geom_df.empty else "No geometry files")
    
    print("\nMuncie project first unsteady flow file:")
    print(muncie_project.unsteady_df.iloc[0] if not muncie_project.unsteady_df.empty else "No unsteady flow files")

    print("\nStep 3: Accessing All RAS Object Data for Multi2D Project")
    print(f"Project Name: {multi_2d_project.get_project_name()}")
    print(f"Project Folder: {multi_2d_project.project_folder}")
    print(f"PRJ File: {multi_2d_project.prj_file}")
    print(f"HEC-RAS Executable Path: {multi_2d_project.ras_exe_path}")
    
    print("\nPlan Files DataFrame:")
    print(multi_2d_project.plan_df)
    
    print("\nFlow Files DataFrame:")
    print(multi_2d_project.flow_df)
    
    print("\nUnsteady Flow Files DataFrame:")
    print(multi_2d_project.unsteady_df)
    
    print("\nGeometry Files DataFrame:")
    print(multi_2d_project.geom_df)
    
    print("\nHDF Entries DataFrame:")
    print(multi_2d_project.get_hdf_entries())

    print("\nExample of simplified import (not recommended for complex scripts)")
    print("-----------------------------------------------------")
    print("from ras_commander import *")
    print("# This allows you to use all functions and classes without prefixes")
    print("# For example: compute_plan() instead of RasCmdr.compute_plan()")
    print("# Note: This approach can lead to naming conflicts and is generally not recommended for larger scripts")

if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\02_plan_operations.py
==================================================
# 02_plan_operations.py

#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek"])

#### --- START OF SCRIPT --- ####

"""
This script demonstrates the process of initializing a HEC-RAS project and performing various operations on plans, geometries, and unsteady flows using the functions within the RasPlan Class.

Process Flow:
1. Project Initialization: Initialize a HEC-RAS project by specifying the project path and version.
2. Plan Cloning: Clone an existing plan, creating a new plan entry.
3. Geometry Cloning: Clone a geometry associated with the original plan, generating a new geometry entry.
4. Unsteady Flow Cloning: Clone an unsteady flow, creating a new unsteady flow entry.
5. Plan Configuration:
   a. Set the cloned geometry for the new plan.
   b. Set the cloned unsteady flow for the new plan.
   c. Update the number of cores to be used for the new plan.
   d. Configure geometry preprocessor options for the new plan.
6. Plan Computation: Compute the new plan and verify successful execution.
7. Results Verification: Check the HDF entries to confirm that results were written.

Additional operations that could be demonstrated:
8. Plan Modification: Update specific parameters in the plan file (e.g., simulation time, output intervals).
9. Geometry Editing: Modify cross-sections, manning's n values, or other geometry data.
10. Unsteady Flow Modification: Adjust boundary conditions or initial conditions.
11. Batch Operations: Perform operations on multiple plans simultaneously.
12. Error Handling: Demonstrate how to handle and report errors during plan operations.
13. Results Analysis: Extract and analyze key output values from the computed plan.
"""

# RAS Commander Library Notes:
# 1. This example uses the default global 'ras' object for simplicity.
# 2. If you need to work with multiple projects, use separate ras objects for each project.
# 3. Once you start using non-global ras objects, stick with that approach throughout your script.

# Best Practices:
# 1. For simple scripts working with a single project, using the global 'ras' object is fine.
# 2. For complex scripts or when working with multiple projects, create and use separate ras objects.
# 3. Be consistent in your approach: don't mix global and non-global ras object usage in the same script.

def main():
    # Initialize the project
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Balde Eagle Creek"
    init_ras_project(project_path, "6.5")

    print("Initial plan files:")
    print(ras.plan_df)
    print()

    # Step 1: Clone a plan
    print("Step 1: Cloning a plan")
    new_plan_number = RasPlan.clone_plan("01")
    print(f"New plan created: {new_plan_number}")
    print("Updated plan files:")
    print(ras.plan_df)
    print()
    
    # Step 2: Clone a geometry
    print("Step 2: Cloning a geometry")
    new_geo_number = RasPlan.clone_geom("01")
    print(f"New geometry created: {new_geo_number}")
    print("Updated geometry files:")
    print(ras.geom_df)
    print()
    
    # Step 3: Clone an unsteady flow
    print("Step 3: Cloning an unsteady flow")
    new_unsteady_number = RasPlan.clone_unsteady("02")
    print(f"New unsteady flow created: {new_unsteady_number}")
    print("Updated unsteady flow files:")
    print(ras.unsteady_df)
    print()

    # Step 4: Set geometry for the cloned plan
    print("Step 4: Setting geometry for a plan")
    RasPlan.set_geom(new_plan_number, new_geo_number)
    plan_path = RasPlan.get_plan_path(new_plan_number)
    print(f"Updated geometry for plan {new_plan_number}")
    print(f"Plan file path: {plan_path}")
    print()

    # Step 5: Set unsteady flow for the cloned plan
    print("Step 5: Setting unsteady flow for a plan")
    RasPlan.set_unsteady(new_plan_number, new_unsteady_number)
    print(f"Updated unsteady flow for plan {new_plan_number}")
    print()

    # Step 6: Set the number of cores for the cloned plan
    print("Step 6: Setting the number of cores for a plan")
    RasPlan.set_num_cores(new_plan_number, 2)
    print(f"Updated number of cores for plan {new_plan_number}")
    print()

    # Step 7: Set geometry preprocessor options for the cloned plan
    print("Step 7: Setting geometry preprocessor options")
    RasPlan.set_geom_preprocessor(plan_path, run_htab=-1, use_ib_tables=-1)
    print(f"Updated geometry preprocessor options for plan {new_plan_number}")
    
    # Step 8: Compute the cloned plan
    print("Step 8: Computing the cloned plan")
    success = RasCmdr.compute_plan(new_plan_number)
    print(f"Computing plan {new_plan_number}")
    if success:
        print(f"Plan {new_plan_number} computed successfully")
    else:
        print(f"Failed to compute plan {new_plan_number}")
    print()
    
    # Step 9: Get the HDF entries for the cloned plan to prove that the results were written
    print("Step 9: Retrieving HDF entries for the cloned plan")
    # Refresh the plan entries to ensure we have the latest data
    ras.plan_df = ras.get_plan_entries()
    hdf_entries = ras.get_hdf_entries()
    if not hdf_entries.empty:
        print("HDF entries for the cloned plan:")
        print(hdf_entries)
    else:
        print("No HDF entries found. This could mean the plan hasn't been computed successfully or the results haven't been written yet.")
    
    # Display the plan entries to see if the HDF path is populated
    print("\nCurrent plan entries:")
    print(ras.plan_df)
    
if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\03_geometry_operations.py
==================================================
# 03_geometry_operations.py

#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Muncie"])

#### --- START OF SCRIPT --- ####

# RAS Commander Library Notes:
# 1. This example uses the default global 'ras' object for simplicity.
# 2. If you need to work with multiple projects, use separate ras objects for each project.
# 3. Once you start using non-global ras objects, stick with that approach throughout your script.
# 4. The RasGeo class provides methods for working with geometry files and preprocessor operations.

# Best Practices:
# 1. For simple scripts working with a single project, using the global 'ras' object is fine.
# 2. For complex scripts or when working with multiple projects, create and use separate ras objects.
# 3. Be consistent in your approach: don't mix global and non-global ras object usage in the same script.
# 4. Always clear geometry preprocessor files before making significant changes to ensure clean results.

def main():
    # Initialize the project
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Muncie"
    init_ras_project(project_path, "6.5")

    print("Initial plan files:")
    print(ras.plan_df)
    print()

    # Step 1: Clone a plan
    print("Step 1: Cloning a plan")
    new_plan_number = RasPlan.clone_plan("01")
    print(f"New plan created: {new_plan_number}")
    print("Updated plan files:")
    print(ras.plan_df)
    print()

    # Step 2: Clone a geometry file and assign it to the cloned plan
    print("Step 2: Cloning a geometry file and assigning it to the cloned plan")
    new_geom_number = RasPlan.clone_geom("01")
    print(f"New geometry created: {new_geom_number}")
    print(f"Now set the new geometry to the new plan")
    RasPlan.set_geom(new_plan_number, new_geom_number)
    print(f"New geometry {new_geom_number} assigned to plan {new_plan_number}")
    print("Updated geometry files:")
    print(ras.geom_df)
    print()

    # Step 3: Clear geometry preprocessor files for the cloned plan
    print("Step 3: Clearing geometry preprocessor files for the cloned plan")
    plan_path = RasPlan.get_plan_path(new_plan_number)
    RasGeo.clear_geompre_files(plan_path)
    print(f"Cleared geometry preprocessor files for plan {new_plan_number}")
    print()

    # Step 4: Clear geometry preprocessor files for all plans
    print("Step 4: Clearing geometry preprocessor files for all plans")
    RasGeo.clear_geompre_files()
    print("Cleared geometry preprocessor files for all plans")
    print()

    # Step 5: Print the updated plan information
    print("Step 5: Updated plan information")
    plan_df = ras.get_plan_entries()
    print(plan_df)
    print()

    # Step 6: Compute the cloned plan with new geometry and core count
    print("Step 6: Computing the cloned plan")
    success = RasCmdr.compute_plan(new_plan_number)
    print(f"Computing plan {new_plan_number}")
    if success:
        print(f"Plan {new_plan_number} computed successfully")
    else:
        print(f"Failed to compute plan {new_plan_number}")
        
    # Step 7: Get and print results paths
    print("\nStep 7: Getting results paths")
    for plan_number in [new_plan_number, "01"]:  # Check both the new plan and the original plan
        results_path = RasPlan.get_results_path(plan_number)
        if results_path:
            print(f"Results for plan {plan_number} are located at: {results_path}")
        else:
            print(f"No results found for plan {plan_number}")
        

if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\04_unsteady_flow_operations.py
==================================================
# 04_unsteady_flow_operations.py

#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek"])

#### --- START OF SCRIPT --- ####

"""
This script demonstrates the process of initializing a HEC-RAS project and performing various operations on unsteady flow plans using the ras-commander library.

Process Flow:
1. Project Initialization: Initialize a HEC-RAS project by specifying the project path and version.
2. Plan Cloning: Clone an existing plan, creating a new plan entry.
3. Unsteady Flow Parameter Updates: Modify various unsteady flow parameters in the new plan.
4. Plan Computation: Compute the new plan and verify successful execution.

Note: This example uses the default global 'ras' object for simplicity. For complex scripts or when working with
multiple projects, it's recommended to create and use separate ras objects.
"""

def main():
    # Initialize the project using the global 'ras' object
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Balde Eagle Creek"
    init_ras_project(project_path, "6.5")

    print("Initial plan files:")
    print(ras.plan_df)
    print()

    # Step 1: Clone a plan
    print("Step 1: Cloning a plan")
    new_plan_number = RasPlan.clone_plan("01")
    print(f"New plan created: {new_plan_number}")
    print("Updated plan files:")
    print(ras.plan_df)
    print()

    # Step 2: Get the plan file path
    plan_path = RasPlan.get_plan_path(new_plan_number)

    # Step 3: Update unsteady flow parameters individually
    print("Step 3: Updating unsteady flow parameters individually")
    RasUnsteady.update_unsteady_parameters(plan_path, {"Simulation Date": "01JAN2023,0000,05JAN2023,2400"})
    RasUnsteady.update_unsteady_parameters(plan_path, {"Computation Interval": "1MIN"})
    RasUnsteady.update_unsteady_parameters(plan_path, {"Output Interval": "15MIN"})
    print("Updated parameters individually")
    print()

    # Step 4: Update unsteady flow parameters in batch
    print("Step 4: Updating unsteady flow parameters in batch")
    batch_modifications = {
        "Mapping Interval": "30MIN",
        "Hydrograph Output Interval": "1HOUR",
        "Detailed Output Interval": "1HOUR"
    }
    RasUnsteady.update_unsteady_parameters(plan_path, batch_modifications)
    print("Updated parameters in batch")
    print()

    # Step 5: Verify changes
    print("Step 5: Verifying changes")
    with open(plan_path, 'r') as f:
        content = f.read()
        for param in ["Simulation Date", "Computation Interval", "Output Interval", 
                      "Mapping Interval", "Hydrograph Output Interval", "Detailed Output Interval"]:
            for line in content.split('\n'):
                if line.startswith(param):
                    print(f"Updated {line}")
                    break
    print()

    # Step 6: Compute the updated plan
    print("Step 6: Computing the updated plan")
    success = RasCmdr.compute_plan(new_plan_number)
    if success:
        print(f"Plan {new_plan_number} computed successfully")
    else:
        print(f"Failed to compute plan {new_plan_number}")

if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\05_utility_functions.py
==================================================
# 05_utility_functions.py

#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek"])

#### --- START OF SCRIPT --- ####

# RAS Commander (ras-commander) Library Notes:
# 1. This example uses the default global 'ras' object for simplicity.
# 2. If you need to work with multiple projects, use separate ras objects for each project.
# 3. Once you start using non-global ras objects, stick with that approach throughout your script.
# 4. The RasUtils class provides various utility functions for working with HEC-RAS projects.

# Best Practices:
# 1. For simple scripts working with a single project, using the global 'ras' object is fine.
# 2. For complex scripts or when working with multiple projects, create and use separate ras objects.
# 3. Be consistent in your approach: don't mix global and non-global ras object usage in the same script.

def main():
    # Initialize the project
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Balde Eagle Creek"
    init_ras_project(project_path, "6.5")
    plan_number = "01"

    # Example 1: Get plan path using RasUtils
    print("Example 1: Getting plan path")
    plan_path = RasUtils.get_plan_path(plan_number)
    print(f"Path for plan {plan_number} is: {plan_path}")
    
    # Example 2: Get geometry path using RasPlan
    print("\nExample 2: Getting geometry path")
    geom_number = "01"
    geom_path = RasPlan.get_geom_path(geom_number)
    print(f"Path for geometry {geom_number} is: {geom_path}")
    
    # Example 3: Get unsteady flow path using RasPlan
    print("\nExample 3: Getting unsteady flow path")
    unsteady_number = "01"
    unsteady_path = RasPlan.get_unsteady_path(unsteady_number)
    print(f"Path for unsteady flow {unsteady_number} is: {unsteady_path}")
    
    # Example 4: Get project name
    print("\nExample 4: Getting project name")
    project_name = ras.get_project_name()
    print(f"Project name: {project_name}")


if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\06_single_plan_execution.py
==================================================
#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Define the "example_projects" folder in the same directory as the script
examples_path = Path(__file__).parent / "example_projects"

# Delete the project if it exists
if examples_path.exists():
    import shutil
    shutil.rmtree(examples_path)

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek"])

#### --- START OF SCRIPT --- ####

# ras-commander Library Notes:
# 1. This example uses the default global 'ras' object for simplicity.
# 2. If you need to work with multiple projects, use separate ras objects for each project.
# 3. Once you start using non-global ras objects, stick with that approach throughout your script.

# Best Practices:
# 1. For simple scripts working with a single project, using the global 'ras' object is fine.
# 2. For complex scripts or when working with multiple projects, create and use separate ras objects.
# 3. Be consistent in your approach: don't mix global and non-global ras object usage in the same script.

def main():
    # Initialize the project using the global 'ras' object
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Balde Eagle Creek"
    init_ras_project(project_path, "6.5")

    print("Available plans:")
    print(ras.plan_df)
    print()

    # Example 1: Execute a single plan
    print("Example 1: Executing a single plan")
    plan_number = "01"
    success = RasCmdr.compute_plan(plan_number)
    if success:
        print(f"Plan {plan_number} executed successfully")
    else:
        print(f"Plan {plan_number} execution failed")
    print()
    

    # Example 2: Execute a plan in a separate destination folder
    print("Example 2: Executing a plan in a separate destination folder")
    plan_number = "02"
    dest_folder = project_path.parent / "compute_test_2"
    success = RasCmdr.compute_plan(plan_number, dest_folder=dest_folder)
    if success:
        print(f"Plan {plan_number} executed successfully in {dest_folder}")
    else:
        print(f"Plan {plan_number} execution failed in {dest_folder}")
    print()

    # Example 3: Get and print results path
    print("Example 3: Getting results path")
    results_path = RasPlan.get_results_path(plan_number)
    if results_path:
        print(f"Results for plan {plan_number} are located at: {results_path}")
    else:
        print(f"No results found for plan {plan_number}")
    print()    

    # Example 4: Execute a plan with cleared geometry preprocessor files
    print("Example 4: Executing a plan with cleared geometry preprocessor files")
    plan_number = "03"
    dest_folder = project_path.parent / "compute_test_3"
    success = RasCmdr.compute_plan(plan_number, dest_folder=dest_folder, clear_geompre=True)
    if success:
        print(f"Plan {plan_number} executed successfully with cleared geometry preprocessor files")
    else:
        print(f"Plan {plan_number} execution failed")
    print()
    

    # Example 5: Execute a plan with a specified number of cores, overwriting compute_test_3
    print("Example 5: Executing a plan with a specified number of cores, overwriting compute_test_3")
    plan_number = "01"
    num_cores = 2  # Specify the number of cores to use
    success = RasCmdr.compute_plan(plan_number, dest_folder=dest_folder, num_cores=num_cores, overwrite_dest=True)
    if success:
        print(f"Plan {plan_number} executed successfully using {num_cores} cores")
    else:
        print(f"Plan {plan_number} execution failed")
    print()
    

    # Example 6: Execute a plan with all new options combined
    print("Example 6: Executing a plan with all new options combined")
    plan_number = "02"
    dest_folder = project_path.parent / "compute_test_all_options"
    num_cores = 4
    
    success = RasCmdr.compute_plan(
        plan_number,
        dest_folder=dest_folder,
        clear_geompre=True,
        num_cores=num_cores
    )
    if success:
        print(f"Plan {plan_number} executed successfully with all options:")
        print(f"- Destination folder: {dest_folder}")
        print(f"- Cleared geometry preprocessor files")
        print(f"- Used {num_cores} cores")
    else:
        print(f"Plan {plan_number} execution failed")

if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\07_sequential_plan_execution.py
==================================================
#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Housekeeping Note: 
# For all of the functions that do batched execution (sequential or parallel), they are careful not to overwrite existing folders
# So if you want your script to be repeatable, you need to make sure you delete the folders before running again.
# Otherwise an error will be raised to prevent overwriting any results from your previous runs.
# This will not be done by the example projects routines, which only overwrite the source folder for repeatability. 
    
import shutil
from pathlib import Path
# Define the keys to search for in folder names
# Delete example projects folder
current_file = Path(__file__).resolve()
current_dir = current_file.parent
delete_folder_path = current_dir / "example_projects"

if delete_folder_path.exists():
    print(f"Removing existing folder: {delete_folder_path}")
    shutil.rmtree(delete_folder_path)
else:
    print(f"Folder not found: {delete_folder_path}")

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek"])

#### --- START OF SCRIPT --- ####

# ras-commander Library Notes:
# 1. This example uses the default global 'ras' object for simplicity.
# 2. If you need to work with multiple projects, use separate ras objects for each project.
# 3. Once you start using non-global ras objects, stick with that approach throughout your script.

# Best Practices:
# 1. For simple scripts working with a single project, using the global 'ras' object is fine.
# 2. For complex scripts or when working with multiple projects, create and use separate ras objects.
# 3. Be consistent in your approach: don't mix global and non-global ras object usage in the same script.
# 4. For functions that do batched execution (sequential or parallel), they are careful not to overwrite existing folders.
# 5. If you want your script to be repeatable, make sure to delete the folders before running again.

def main():
    # Initialize the project using the global 'ras' object
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Balde Eagle Creek"
    init_ras_project(project_path, "6.5")

    print("Available plans:")
    print(ras.plan_df)
    print()

    # Example 1: Sequential execution of all plans with overwrite_dest
    print("Example 1: Sequential execution of all plans with overwrite_dest")
    RasCmdr.compute_test_mode(
        dest_folder_suffix="[AllSequential]",
        overwrite_dest=True
    )
    print("Sequential execution of all plans completed with overwrite_dest")
    print()
    
    # Example 2: Sequential execution of specific plans with clearing geompre files and overwrite_dest
    print("Example 2: Sequential execution of specific plans with clearing geompre files and overwrite_dest")
    RasCmdr.compute_test_mode(
        plan_number=["01", "02"],
        dest_folder_suffix="[SpecificSequentialClearGeompre]",
        clear_geompre=True,
        overwrite_dest=True
    )
    print("Sequential execution of specific plans completed with clearing geompre files and overwrite_dest")
    print()

    # Example 3: Demonstrate clearing geompre files for specific plans
    print("Example 3: Clearing geompre files for specific plans")
    plan_files = [RasPlan.get_plan_path("01"), RasPlan.get_plan_path("02")]
    RasGeo.clear_geompre_files(plan_files)
    print("Geometry preprocessor files cleared for specific plans")
    print()

    # Example 4: Demonstrate clearing all geompre files
    print("Example 4: Clearing all geompre files")
    RasGeo.clear_geompre_files()
    print("All geometry preprocessor files cleared")

if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\08_parallel_execution.py
==================================================
#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path
import shutil

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek"])

#### --- START OF SCRIPT --- ####

# ras-commander Library Notes:
# 1. This example uses the default global 'ras' object for simplicity.
# 2. If you need to work with multiple projects, use separate ras objects for each project.
# 3. Once you start using non-global ras objects, stick with that approach throughout your script.
# 4. For functions that do batched execution (sequential or parallel), they are careful not to overwrite existing folders.
# 5. If you want your script to be repeatable, make sure to delete the folders before running again.

# Best Practices:
# 1. For simple scripts working with a single project, using the global 'ras' object is fine.
# 2. For complex scripts or when working with multiple projects, create and use separate ras objects.
# 3. Be consistent in your approach: don't mix global and non-global ras object usage in the same script.
# 4. When using parallel execution, consider the number of cores available on your machine.
# 5. Use the dest_folder argument to keep your project folder clean and organized.

def main():
    # Initialize the project using the global 'ras' object
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Balde Eagle Creek"
    init_ras_project(project_path, "6.5")

    print("Available plans:")
    print(ras.plan_df)
    print()

    # Example 1: Parallel execution of all plans with overwrite_dest
    print("Example 1: Parallel execution of all plans with overwrite_dest")
    compute_folder = project_path.parent / "compute_test_parallel"
    results_all = RasCmdr.compute_parallel(
        max_workers=3,
        num_cores=2,
        dest_folder=compute_folder,
        overwrite_dest=True
    )
    print("Parallel execution of all plans results:")
    for plan_number, success in results_all.items():
        print(f"Plan {plan_number}: {'Successful' if success else 'Failed'}")
    print()

    # Example 2: Parallel execution of specific plans with overwrite_dest
    print("Example 2: Parallel execution of specific plans with overwrite_dest")
    specific_plans = ["01", "02"]
    specific_compute_folder = project_path.parent / "compute_test_parallel_specific"
    results_specific = RasCmdr.compute_parallel(
        plan_number=specific_plans,
        max_workers=2,
        num_cores=2,
        dest_folder=specific_compute_folder,
        overwrite_dest=True
    )
    print("Parallel execution of specific plans results:")
    for plan_number, success in results_specific.items():
        print(f"Plan {plan_number}: {'Successful' if success else 'Failed'}")
    print()

    # Example 3: Get and print results paths
    print("Example 3: Getting results paths")
    for plan_number in specific_plans:
        results_path = RasPlan.get_results_path(plan_number)
        if results_path:
            print(f"Results for plan {plan_number} are located at: {results_path}")
        else:
            print(f"No results found for plan {plan_number}")

if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\09_specifying_plans.py
==================================================
#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Housekeeping Note: 
# For all of the functions that do batched execution (sequential or parallel), they are careful not to overwrite existing folders
# So if you want your script to be repeatable, you need to make sure you delete the folders before running again.
# Otherwise an error will be raised to prevent overwriting any results from your previous runs.
# This will not be done by the example projects routines, which only overwrite the source folder for repeatability. 
    
import shutil
from pathlib import Path

# Delete example projects folder
current_file = Path(__file__).resolve()
current_dir = current_file.parent
delete_folder_path = current_dir / "example_projects"

if delete_folder_path.exists():
    print(f"Removing existing folder: {delete_folder_path}")
    shutil.rmtree(delete_folder_path)
else:
    print(f"Folder not found: {delete_folder_path}")

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek"])

#### --- START OF SCRIPT --- ####

# RAS Commander (ras-commander) Library Notes:
# 1. This example uses the default global 'ras' object for simplicity.
# 2. If you need to work with multiple projects, use separate ras objects for each project.
# 3. Once you start using non-global ras objects, stick with that approach throughout your script.
# 4. The RasCmdr class provides methods for executing plans in various ways.
# 5. You can specify individual plans or lists of plans for batch operations.

# Best Practices:
# 1. For simple scripts working with a single project, using the global 'ras' object is fine.
# 2. For complex scripts or when working with multiple projects, create and use separate ras objects.
# 3. Be consistent in your approach: don't mix global and non-global ras object usage in the same script.
# 4. When specifying plans, use plan numbers as strings (e.g., "01", "02") for consistency.
# 5. Always check the available plans in the project before specifying plan numbers for execution.

def main():
    # Initialize the project
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Balde Eagle Creek"
    init_ras_project(project_path, "6.5")

    print("Available plans:")
    print(ras.plan_df)
    print()

    # Example 1: Sequential execution of specific plans
    print("Example 1: Sequential execution of specific plans (1 and 3)")
    RasCmdr.compute_test_mode(plan_number=["01", "03"], dest_folder_suffix="[SpecificSequential]", num_cores=6)
    print("Sequential execution of specific plans completed")
    print()

    # Example 2: Parallel execution of specific plans
    print("Example 2: Parallel execution of specific plans")
    results_specific = RasCmdr.compute_parallel(
        plan_number=["01", "02"],
        max_workers=2,
        num_cores=2
    )
    print("Parallel execution of specific plans results:")
    for plan_number, success in results_specific.items():
        print(f"Plan {plan_number}: {'Successful' if success else 'Failed'}")
    print()

    # Example 3: Execute all plans
    print("Example 3: Execute all plans")
    all_plan_numbers = ras.plan_df['plan_number'].tolist()
    RasCmdr.compute_test_mode(plan_number=all_plan_numbers, dest_folder_suffix="[AllPlans]")
    print("Execution of all plans completed")
    print()

if __name__ == "__main__":
    main()

==================================================

File: c:\GH\ras-commander\examples\10_arguments_for_compute.py
==================================================
#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek"])

#### --- START OF SCRIPT --- ####

# RAS Commander Library Notes:
# 1. This example uses the default global 'ras' object for simplicity.
# 2. If you need to work with multiple projects, use separate ras objects for each project.
# 3. Once you start using non-global ras objects, stick with that approach throughout your script.
# 4. The RasCmdr class provides various arguments for fine-tuning plan computation:
#    - plan_number: String representing the plan number to compute (e.g., "01")
#    - dest_folder: Path object specifying the destination folder for computation results
#    - clear_geompre: Boolean to clear geometry preprocessor files before computation
#    - num_cores: Integer specifying the number of cores to use
#    - overwrite_dest: Boolean to determine if existing destination folders should be overwritten

# Best Practices:
# 1. For simple scripts working with a single project, using the global 'ras' object is fine.
# 2. For complex scripts or when working with multiple projects, create and use separate ras objects.
# 3. Be consistent in your approach: don't mix global and non-global ras object usage in the same script.
# 4. Utilize the various arguments in compute functions to customize plan execution.
# 5. Always consider your system's capabilities when setting num_cores.
# 6. Use clear_geompre=True when you want to ensure a clean computation environment.
# 7. Specify dest_folder to keep your project folder organized and prevent overwriting previous results.

def main():
    # Initialize the project
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Balde Eagle Creek"
    init_ras_project(project_path, "6.5")

    print("Available plans:")
    print(ras.plan_df)
    print()

    # Example 1: Sequential execution (compute_test_mode) with various arguments
    print("Example 1: Sequential execution with various arguments")
    for plan_number in ["01", "02"]:
        # Put dest_folder in the parent directory of the project folder (placing it horizontally with the project folder)
        # Test mode only allows dest_folder_suffix, and always creates a copy in the project folder's parent directory. 
        # So instead of building the full folder name or path, we only define the suffix. 
        dest_folder_suffix = f"_{plan_number}_[SequentialWithArgs]"
        success = RasCmdr.compute_test_mode(
            plan_number=plan_number,
            dest_folder_suffix=dest_folder_suffix,  # Test mode only allows dest_folder_suffix, and always creates a copy in the project folder's parent directory
            clear_geompre=True,
            num_cores=2,
            overwrite_dest=True
        )
        print(f"Plan {plan_number} execution: {'Successful' if success else 'Failed'}")
    print("Sequential execution completed")
    print()
    
    # This variation will fail, as the folder already exists and overwrite_dest is False.  
    # Be sure to think step by step about folder management in your multi-folder automation workflows:
    # Also, try to run the same thing with compute_parallel, but with overwrite_dest=False
    # Since we just created these folders, they are not empty, so this should generate an error message on the terminal
    # Put in Try-Except block:
    try:
        dest_folder = project_path.parent / f"{ras.project_name}_compute_test_01_[SequentialWithArgs]"
        success = RasCmdr.compute_test_mode(
            plan_number="01",
            dest_folder_suffix=dest_folder_suffix,
            clear_geompre=True,
            num_cores=2,
            overwrite_dest=False
        )
    except ValueError as e:
        print(f"If the example operates successfully (it is meant to generate an error above), you will not see this message.")

    # Example 2: Parallel execution (compute_parallel) with various arguments
    print("Example 2: Parallel execution with various arguments")
    results = RasCmdr.compute_parallel(
        plan_number=["01", "02"],
        max_workers=2,
        num_cores=2,
        dest_folder=project_path.parent / "parallel_results",
        clear_geompre=True
    )
    print("Parallel execution results:")
    for plan_number, success in results.items():
        print(f"Plan {plan_number}: {'Successful' if success else 'Failed'}")
    print()

    # Example 3: Single plan execution (compute_plan) with specific arguments
    print("Example 3: Single plan execution with specific arguments")
    plan_number = "02"
    dest_folder = project_path.parent / "compute_test_2"
    success = RasCmdr.compute_plan(plan_number, dest_folder=dest_folder, num_cores=2, clear_geompre=True, overwrite_dest=True)
    print(f"Single plan execution: {'Successful' if success else 'Failed'}")

if __name__ == "__main__":
    main()

==================================================

File: c:\GH\ras-commander\examples\11_Using_RasExamples.ipynb
==================================================
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ras_commander imported successfully\n"
     ]
    }
   ],
   "source": [
    "import sys\n",
    "from pathlib import Path\n",
    "\n",
    "# Flexible imports to allow for development without installation\n",
    "try:\n",
    "    # Try to import from the installed package\n",
    "    from ras_commander import init_ras_project, RasExamples, RasCommander, RasPlan, RasGeo, RasUnsteady, RasUtils, ras\n",
    "except ImportError:\n",
    "    # If the import fails, add the parent directory to the Python path\n",
    "    import os\n",
    "    current_file = Path(os.getcwd()).resolve()\n",
    "    parent_directory = current_file.parent\n",
    "    sys.path.append(str(parent_directory))\n",
    "    \n",
    "    # Now try to import again\n",
    "    from ras_commander import init_ras_project, RasExamples, RasCommander, RasPlan, RasGeo, RasUnsteady, RasUtils, ras\n",
    "\n",
    "print(\"ras_commander imported successfully\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Example projects folder: c:\\Users\\billk\\Desktop\\AWS Webinar AI for HEC-RAS\\ras_commander\\ras_commander workspace6\\examples\\example_projects\n",
      "Found zip file: c:\\Users\\billk\\Desktop\\AWS Webinar AI for HEC-RAS\\ras_commander\\ras_commander workspace6\\examples\\Example_Projects_6_5.zip\n",
      "Loading project data from CSV...\n",
      "Loaded 66 projects from CSV, use list_categories() and list_projects() to explore them\n",
      "----- RasExamples Extracting Project -----\n",
      "Extracting project 'Balde Eagle Creek'\n",
      "Project 'Balde Eagle Creek' already exists. Deleting existing folder...\n",
      "Existing folder for project 'Balde Eagle Creek' has been deleted.\n",
      "Successfully extracted project 'Balde Eagle Creek' to c:\\Users\\billk\\Desktop\\AWS Webinar AI for HEC-RAS\\ras_commander\\ras_commander workspace6\\examples\\example_projects\\Balde Eagle Creek\n",
      "----- RasExamples Extracting Project -----\n",
      "Extracting project 'BaldEagleCrkMulti2D'\n",
      "Project 'BaldEagleCrkMulti2D' already exists. Deleting existing folder...\n",
      "Existing folder for project 'BaldEagleCrkMulti2D' has been deleted.\n",
      "Successfully extracted project 'BaldEagleCrkMulti2D' to c:\\Users\\billk\\Desktop\\AWS Webinar AI for HEC-RAS\\ras_commander\\ras_commander workspace6\\examples\\example_projects\\BaldEagleCrkMulti2D\n",
      "----- RasExamples Extracting Project -----\n",
      "Extracting project 'Muncie'\n",
      "Project 'Muncie' already exists. Deleting existing folder...\n",
      "Existing folder for project 'Muncie' has been deleted.\n",
      "Successfully extracted project 'Muncie' to c:\\Users\\billk\\Desktop\\AWS Webinar AI for HEC-RAS\\ras_commander\\ras_commander workspace6\\examples\\example_projects\\Muncie\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "[WindowsPath('c:/Users/billk/Desktop/AWS Webinar AI for HEC-RAS/ras_commander/ras_commander workspace6/examples/example_projects/Balde Eagle Creek'),\n",
       " WindowsPath('c:/Users/billk/Desktop/AWS Webinar AI for HEC-RAS/ras_commander/ras_commander workspace6/examples/example_projects/BaldEagleCrkMulti2D'),\n",
       " WindowsPath('c:/Users/billk/Desktop/AWS Webinar AI for HEC-RAS/ras_commander/ras_commander workspace6/examples/example_projects/Muncie')]"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# The First Code Cell is All You Need\n",
    "\n",
    "# This is what this Class was intended to do: Help me make repeatable workflows around HEC-RAS Example Projects for testing and demonstration purposes. \n",
    "# Replace the Example_Projects_6_5.zip with your own zip file in the same format and you will be able to load them by folder name for repeatable workflows.\n",
    "# Just make sure all project folders have unique folder names. \n",
    "\n",
    "# Extract specific projects\n",
    "ras_examples = RasExamples()\n",
    "ras_examples.extract_project([\"Balde Eagle Creek\", \"BaldEagleCrkMulti2D\", \"Muncie\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Example projects folder: c:\\Users\\billk\\Desktop\\AWS Webinar AI for HEC-RAS\\ras_commander\\ras_commander workspace6\\examples\\example_projects\n",
      "Found zip file: c:\\Users\\billk\\Desktop\\AWS Webinar AI for HEC-RAS\\ras_commander\\ras_commander workspace6\\examples\\Example_Projects_6_5.zip\n",
      "Loading project data from CSV...\n",
      "Loaded 66 projects from CSV, use list_categories() and list_projects() to explore them\n",
      "Example projects are already downloaded.\n",
      "ras_examples.folder_df:\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Category</th>\n",
       "      <th>Project</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>1D Sediment Transport</td>\n",
       "      <td>BSTEM - Simple Example</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>1D Sediment Transport</td>\n",
       "      <td>Dredging Example</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>1D Sediment Transport</td>\n",
       "      <td>Reservoir Video Tutorial</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>1D Sediment Transport</td>\n",
       "      <td>SIAM Example</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>1D Sediment Transport</td>\n",
       "      <td>Simple Sediment Transport Example</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>61</th>\n",
       "      <td>Applications Guide</td>\n",
       "      <td>Example 6 - Floodway Determination</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>62</th>\n",
       "      <td>Applications Guide</td>\n",
       "      <td>Example 7 - Multiple Plans</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>63</th>\n",
       "      <td>Applications Guide</td>\n",
       "      <td>Example 8 - Looped Network</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>64</th>\n",
       "      <td>Applications Guide</td>\n",
       "      <td>Example 9 - Mixed Flow Analysis</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>65</th>\n",
       "      <td>Water Quality</td>\n",
       "      <td>Nutrient Example</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>66 rows  2 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "                 Category                             Project\n",
       "0   1D Sediment Transport              BSTEM - Simple Example\n",
       "1   1D Sediment Transport                    Dredging Example\n",
       "2   1D Sediment Transport            Reservoir Video Tutorial\n",
       "3   1D Sediment Transport                        SIAM Example\n",
       "4   1D Sediment Transport   Simple Sediment Transport Example\n",
       "..                    ...                                 ...\n",
       "61     Applications Guide  Example 6 - Floodway Determination\n",
       "62     Applications Guide          Example 7 - Multiple Plans\n",
       "63     Applications Guide          Example 8 - Looped Network\n",
       "64     Applications Guide     Example 9 - Mixed Flow Analysis\n",
       "65          Water Quality                    Nutrient Example\n",
       "\n",
       "[66 rows x 2 columns]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Initialize RasExamples (it will use the current working directory by default)\n",
    "ras_examples = RasExamples()\n",
    "\n",
    "# Check if example projects are already downloaded\n",
    "if ras_examples.projects_dir.exists():\n",
    "    print(\"Example projects are already downloaded.\")\n",
    "    print(\"ras_examples.folder_df:\")\n",
    "    display(ras_examples.folder_df)\n",
    "else:\n",
    "    print(\"Downloading example projects...\")\n",
    "    ras_examples.get_example_projects()\n",
    "    print(\"ras_examples.folder_df:\")\n",
    "    display(ras_examples.folder_df)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Available categories: 1D Sediment Transport, 1D Steady Flow Hydraulics, 1D Unsteady Flow Hydraulics, 2D Sediment Transport, 2D Unsteady Flow Hydraulics, Applications Guide, Water Quality\n",
      "\n",
      "Available categories:\n",
      "- 1D Sediment Transport\n",
      "- 1D Steady Flow Hydraulics\n",
      "- 1D Unsteady Flow Hydraulics\n",
      "- 2D Sediment Transport\n",
      "- 2D Unsteady Flow Hydraulics\n",
      "- Applications Guide\n",
      "- Water Quality\n"
     ]
    }
   ],
   "source": [
    "# List all categories\n",
    "categories = ras_examples.list_categories()\n",
    "print(\"\\nAvailable categories:\")\n",
    "for category in categories:\n",
    "    print(f\"- {category}\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Projects in '1D Unsteady Flow Hydraulics':\n",
      "- Balde Eagle Creek\n",
      "- Bridge Hydraulics\n",
      "- ContractionExpansionMinorLosses\n",
      "- Culvert Hydraulics\n",
      "- Culverts with Flap Gates\n",
      "- Dam Breaching\n",
      "- Elevation Controled Gates\n",
      "- Inline Structure with Gated Spillways\n",
      "- Internal Stage and Flow Boundary Condition\n",
      "- JunctionHydraulics\n",
      "- Lateral Strcuture with Gates\n",
      "- Lateral Structure connected to a River Reach\n",
      "- Lateral Structure Overflow Weir\n",
      "- Lateral Structure with Culverts\n",
      "- Lateral Structure with Culverts and Gates\n",
      "- Levee Breaching\n",
      "- Mixed Flow Regime\n",
      "- Multiple Reaches with Hydraulic Structures\n",
      "- NavigationDam\n",
      "- Pumping Station\n",
      "- Pumping Station with Rules\n",
      "- Rule Operations\n",
      "- Simplified Physical Breaching\n",
      "- Storage Area Hydraulic Connection\n",
      "- UngagedAreaInflows\n",
      "- Unsteady Flow Encroachment Analysis\n"
     ]
    }
   ],
   "source": [
    "\n",
    "# List projects in a specific category\n",
    "category = \"1D Unsteady Flow Hydraulics\"\n",
    "projects = ras_examples.list_projects(category)\n",
    "print(f\"\\nProjects in '{category}':\")\n",
    "for project in projects:\n",
    "    print(f\"- {project}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "All available projects:\n",
      "- BSTEM - Simple Example\n",
      "- Dredging Example\n",
      "- Reservoir Video Tutorial\n",
      "- SIAM Example\n",
      "- Simple Sediment Transport Example\n",
      "- Unsteady Sediment with Concentration Rules\n",
      "- Video Tutorial (Sediment Intro)\n",
      "- Baxter RAS Mapper\n",
      "- Chapter 4 Example Data\n",
      "- ConSpan Culvert\n",
      "- Mixed Flow Regime Channel\n",
      "- Wailupe GeoRAS\n",
      "- Balde Eagle Creek\n",
      "- Bridge Hydraulics\n",
      "- ContractionExpansionMinorLosses\n",
      "- Culvert Hydraulics\n",
      "- Culverts with Flap Gates\n",
      "- Dam Breaching\n",
      "- Elevation Controled Gates\n",
      "- Inline Structure with Gated Spillways\n",
      "- Internal Stage and Flow Boundary Condition\n",
      "- JunctionHydraulics\n",
      "- Lateral Strcuture with Gates\n",
      "- Lateral Structure connected to a River Reach\n",
      "- Lateral Structure Overflow Weir\n",
      "- Lateral Structure with Culverts\n",
      "- Lateral Structure with Culverts and Gates\n",
      "- Levee Breaching\n",
      "- Mixed Flow Regime\n",
      "- Multiple Reaches with Hydraulic Structures\n",
      "- NavigationDam\n",
      "- Pumping Station\n",
      "- Pumping Station with Rules\n",
      "- Rule Operations\n",
      "- Simplified Physical Breaching\n",
      "- Storage Area Hydraulic Connection\n",
      "- UngagedAreaInflows\n",
      "- Unsteady Flow Encroachment Analysis\n",
      "- Chippewa_2D\n",
      "- BaldEagleCrkMulti2D\n",
      "- Muncie\n",
      "- Example 1 - Critical Creek\n",
      "- Example 10 - Stream Junction\n",
      "- Example 11 - Bridge Scour\n",
      "- Example 12 - Inline Structure\n",
      "- Example 13 - Singler Bridge (WSPRO)\n",
      "- Example 14 - Ice Covered River\n",
      "- Example 15 - Split Flow Junction with Lateral Weir\n",
      "- Example 16 - Channel Modification\n",
      "- Example 17 - Unsteady Flow Application\n",
      "- Example 18 - Advanced Inline Structure\n",
      "- Example 19 - Hydrologic Routing - ModPuls\n",
      "- Example 2 - Beaver Creek\n",
      "- Example 20 - HagerLatWeir\n",
      "- Example 21 - Overflow Gates\n",
      "- Example 22 - Groundwater Interflow\n",
      "- Example 23 - Urban Modeling\n",
      "- Example 24 - Mannings-n-Calibration\n",
      "- Example 3 - Single Culvert\n",
      "- Example 4 - Multiple Culverts\n",
      "- Example 5 - Multiple Openings\n",
      "- Example 6 - Floodway Determination\n",
      "- Example 7 - Multiple Plans\n",
      "- Example 8 - Looped Network\n",
      "- Example 9 - Mixed Flow Analysis\n",
      "- Nutrient Example\n"
     ]
    }
   ],
   "source": [
    "# List all projects\n",
    "all_projects = ras_examples.list_projects()\n",
    "print(\"\\nAll available projects:\")\n",
    "for project in all_projects:\n",
    "    print(f\"- {project}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "----- RasExamples Extracting Project -----\n",
      "Extracting project 'Balde Eagle Creek'\n",
      "Project 'Balde Eagle Creek' already exists. Deleting existing folder...\n",
      "Existing folder for project 'Balde Eagle Creek' has been deleted.\n",
      "Successfully extracted project 'Balde Eagle Creek' to c:\\Users\\billk\\Desktop\\AWS Webinar AI for HEC-RAS\\ras_commander\\ras_commander workspace6\\examples\\example_projects\\Balde Eagle Creek\n",
      "----- RasExamples Extracting Project -----\n",
      "Extracting project 'BaldEagleCrkMulti2D'\n",
      "Project 'BaldEagleCrkMulti2D' already exists. Deleting existing folder...\n",
      "Existing folder for project 'BaldEagleCrkMulti2D' has been deleted.\n",
      "Successfully extracted project 'BaldEagleCrkMulti2D' to c:\\Users\\billk\\Desktop\\AWS Webinar AI for HEC-RAS\\ras_commander\\ras_commander workspace6\\examples\\example_projects\\BaldEagleCrkMulti2D\n",
      "----- RasExamples Extracting Project -----\n",
      "Extracting project 'Muncie'\n",
      "Project 'Muncie' already exists. Deleting existing folder...\n",
      "Existing folder for project 'Muncie' has been deleted.\n",
      "Successfully extracted project 'Muncie' to c:\\Users\\billk\\Desktop\\AWS Webinar AI for HEC-RAS\\ras_commander\\ras_commander workspace6\\examples\\example_projects\\Muncie\n"
     ]
    }
   ],
   "source": [
    "# Extract specific projects\n",
    "projects_to_extract = [\"Balde Eagle Creek\", \"BaldEagleCrkMulti2D\", \"Muncie\"]\n",
    "extracted_paths = ras_examples.extract_project(projects_to_extract)\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "cmdr_workspace",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}

==================================================

File: c:\GH\ras-commander\examples\12_plan_set_execution.py
==================================================
#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek"])

#### --- START OF SCRIPT --- ####

import pandas as pd


def create_plan_set(base_plan, base_geom, num_copies):
    plan_set = []
    for i in range(num_copies):
        new_plan = RasPlan.clone_plan(base_plan)
        new_geom = RasPlan.clone_geom(base_geom)
        RasPlan.set_geom(new_plan, new_geom)
        plan_set.append({
            'plan_number': new_plan,
            'geom_number': new_geom
        })
    return pd.DataFrame(plan_set)

def main():
    # Initialize the project
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Balde Eagle Creek"
    init_ras_project(project_path, "6.5")

    print("Available plans:")
    print(ras.plan_df)
    print("\nAvailable geometries:")
    print(ras.geom_df)
    print()

    # Create a plan set
    base_plan = "01"
    base_geom = "01"
    num_copies = 5
    plan_set = create_plan_set(base_plan, base_geom, num_copies)
    
    print("Created plan set:")
    print(plan_set)
    print()

    # Placeholder for user to insert code that makes programmatic changes to the model
    # For example:
    # for index, row in plan_set.iterrows():
    #     plan_path = RasPlan.get_plan_path(row['plan_number'])
    #     geom_path = RasPlan.get_geom_path(row['geom_number'])
    #     # Make changes to the plan or geometry file here
    #     # For example, you could modify Manning's n values, cross-section data, etc.

    # Execute the plan set in parallel
    print("Executing plan set in parallel")
    results = RasCmdr.compute_parallel(
        plan_number=plan_set['plan_number'].tolist(),
        max_workers=3,
        num_cores=2
    )

    # Add execution results to the plan_set DataFrame
    plan_set['execution_success'] = plan_set['plan_number'].map(results)

    print("\nPlan set execution results:")
    print(plan_set)

    # Here you could add code to analyze the results, such as:
    # - Extracting key output values from each simulation
    # - Comparing results across different plans
    # - Creating visualizations of the results

if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\13_multiple_project_operations.py
==================================================
#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
import shutil
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek", "Muncie"])

#### --- START OF SCRIPT --- ####

def execute_plan(plan_number, ras_object, compute_folder):
    # Set the number of cores to 2 before executing the plan
    RasPlan.set_num_cores(plan_number, 2, ras_object=ras_object)
    
    # Execute the plan in the compute folder
    success = RasCmdr.compute_plan(plan_number, ras_object=ras_object, dest_folder=compute_folder)
    
    return plan_number, success

def main():
    # Initialize two projects
    current_dir = Path(__file__).parent
    bald_eagle_path = current_dir / "example_projects" / "Balde Eagle Creek"
    muncie_path = current_dir / "example_projects" / "Muncie"
    
    bald_eagle = init_ras_project(bald_eagle_path, "6.5")
    muncie = init_ras_project(muncie_path, "6.5")

    print("Available plans in Bald Eagle Creek project:")
    print(bald_eagle.plan_df)
    print("\nAvailable plans in Muncie project:")
    print(muncie.plan_df)
    print()

    # Example 1: Clone plans with custom short identifiers
    print("Example 1: Cloning plans with custom short identifiers")
    new_bald_eagle_plan = RasPlan.clone_plan("01", new_plan_shortid="BECustom", ras_object=bald_eagle)
    new_muncie_plan = RasPlan.clone_plan("01", new_plan_shortid="MunCustom", ras_object=muncie)
    print(f"Created new plan {new_bald_eagle_plan} in Bald Eagle Creek project")
    print(f"Created new plan {new_muncie_plan} in Muncie project")
    print()

    # Example 2: Set geometry for the new plans
    print("Example 2: Setting geometry for the new plans")
    RasPlan.set_geom(new_bald_eagle_plan, "01", ras_object=bald_eagle)
    RasPlan.set_geom(new_muncie_plan, "01", ras_object=muncie)
    print(f"Set geometry for plan {new_bald_eagle_plan} in Bald Eagle Creek project")
    print(f"Set geometry for plan {new_muncie_plan} in Muncie project")
    print()

    # Example 3: Update unsteady flow parameters for both projects
    print("Example 3: Updating unsteady flow parameters")
    bald_eagle_plan_file = RasPlan.get_plan_path(new_bald_eagle_plan, ras_object=bald_eagle)
    muncie_plan_file = RasPlan.get_plan_path(new_muncie_plan, ras_object=muncie)

    modifications = {
        "Computation Interval": "2MIN",
        "Output Interval": "30MIN",
        "Mapping Interval": "1HOUR"
    }

    RasUnsteady.update_unsteady_parameters(bald_eagle_plan_file, modifications, ras_object=bald_eagle)
    RasUnsteady.update_unsteady_parameters(muncie_plan_file, modifications, ras_object=muncie)
    print("Updated unsteady flow parameters for both projects")
    print()

    # Example 4: Execute plans for both projects simultaneously in separate compute folders
    print("Example 4: Executing plans for both projects simultaneously in separate compute folders")
    
    # Create compute folders
    bald_eagle_compute_folder = bald_eagle_path.parent / "compute_bald_eagle"
    muncie_compute_folder = muncie_path.parent / "compute_muncie"
    
    # Remove existing compute folders if they exist
    for folder in [bald_eagle_compute_folder, muncie_compute_folder]:
        if folder.exists():
            shutil.rmtree(folder)
        folder.mkdir(parents=True, exist_ok=True)
    
    with ThreadPoolExecutor(max_workers=2) as executor:
        futures = [
            executor.submit(execute_plan, new_bald_eagle_plan, bald_eagle, bald_eagle_compute_folder),
            executor.submit(execute_plan, new_muncie_plan, muncie, muncie_compute_folder)
        ]
        
        results = {}
        for future in futures:
            plan_number, success = future.result()
            results[plan_number] = success

    print("Execution results:")
    for plan_number, success in results.items():
        print(f"Plan {plan_number} execution: {'Successful' if success else 'Failed'}")
    print()

    # Example 5: Get and print results paths
    print("Example 5: Getting results paths")
    bald_eagle_results = RasPlan.get_results_path(new_bald_eagle_plan, ras_object=bald_eagle)
    muncie_results = RasPlan.get_results_path(new_muncie_plan, ras_object=muncie)

    if bald_eagle_results:
        print(f"Results for Bald Eagle Creek plan {new_bald_eagle_plan} are located at: {bald_eagle_results}")
    else:
        print(f"No results found for Bald Eagle Creek plan {new_bald_eagle_plan}")

    if muncie_results:
        print(f"Results for Muncie plan {new_muncie_plan} are located at: {muncie_results}")
    else:
        print(f"No results found for Muncie plan {new_muncie_plan}")

    print("\nNote: The original project folders can now be edited while the compute operations are running in separate folders.")

if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\examples\14_Core_Sensitivity.ipynb
==================================================
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#%pip install ras-commander pandas requests pathlib matplotlib"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import time\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from pathlib import Path\n",
    "from ras_commander import RasExamples, init_ras_project, RasCommander, RasPlan, RasGeo\n",
    "\n",
    "# Step 1: Initialize RasExamples and extract the Muncie project\n",
    "ras_examples = RasExamples()\n",
    "ras_examples.extract_project([\"Muncie\"])\n",
    "\n",
    "# Use Path.cwd() to get the current working directory in a Jupyter Notebook\n",
    "current_directory = Path.cwd()\n",
    "project_path = current_directory / \"example_projects\" / \"Muncie\"\n",
    "\n",
    "# Step 2: Initialize the Muncie Project using init_ras_project (from ras_commander)\n",
    "muncie_project = init_ras_project(project_path, \"6.5\")\n",
    "\n",
    "# Step 3: Initialize a DataFrame to store execution results\n",
    "results = []\n",
    "\n",
    "# Step 4: Iterate over each plan and core count\n",
    "for plan_number in muncie_project.plan_df['plan_number'].unique():\n",
    "    print(f\"Running sensitivity analysis for Plan {plan_number}\")\n",
    "    \n",
    "    # Clear geompre files before running the plan\n",
    "    plan_path = RasPlan.get_plan_path(plan_number)\n",
    "    RasGeo.clear_geompre_files(plan_path)\n",
    "    \n",
    "    for cores in range(1, 9):\n",
    "        # Set core count for this plan\n",
    "        RasPlan.set_num_cores(plan_number, cores)\n",
    "        \n",
    "        # Time the execution of the plan\n",
    "        start_time = time.time()\n",
    "        RasCommander.compute_plan(plan_number)\n",
    "        execution_time = time.time() - start_time\n",
    "        \n",
    "        # Store the results\n",
    "        results.append({\n",
    "            \"plan_number\": plan_number,\n",
    "            \"cores\": cores,\n",
    "            \"execution_time\": execution_time\n",
    "        })\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Step 5: Convert results into a DataFrame\n",
    "results_df = pd.DataFrame(results)\n",
    "\n",
    "# Step 6: Extract plan title, shortid, and description\n",
    "plan_info_df = muncie_project.plan_df[['plan_number', 'title', 'shortid', 'description']]\n",
    "\n",
    "# Merge the execution results with the plan information\n",
    "merged_df = pd.merge(results_df, plan_info_df, on='plan_number')\n",
    "\n",
    "# Step 7: Calculate unit runtime (based on 1 core execution time)\n",
    "merged_df['unit_runtime'] = merged_df.groupby('plan_number')['execution_time'].transform(lambda x: x / x.iloc[0])\n",
    "\n",
    "# Display the results dataframe for verification\n",
    "print(\"merged_df DataFrame:\")\n",
    "print(merged_df)\n",
    "\n",
    "# Step 8: Plot a line chart for unit runtime vs. cores for each plan\n",
    "plt.figure(figsize=(10, 6))\n",
    "for plan in merged_df['plan_number'].unique():\n",
    "    plan_data = merged_df[merged_df['plan_number'] == plan]\n",
    "    plt.plot(plan_data['cores'], plan_data['unit_runtime'], label=f\"Plan {plan}\")\n",
    "\n",
    "plt.xlabel(\"Number of Cores\")\n",
    "plt.ylabel(\"Unit Runtime (Relative to 1 Core)\")\n",
    "plt.title(\"Core Count Sensitivity Analysis\")\n",
    "plt.legend(title=\"Plan Title\")\n",
    "plt.grid(True)\n",
    "plt.show()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "releasecmdr311",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}

==================================================

File: c:\GH\ras-commander\examples\xx_edge_cases.py
==================================================
#### --- IMPORTS AND EXAMPLE PROJECT SETUP --- ####

import sys
from pathlib import Path
import shutil

# Add the parent directory to the Python path
current_file = Path(__file__).resolve()
parent_directory = current_file.parent.parent
sys.path.append(str(parent_directory))

# Flexible imports to allow for development without installation
try:
    # Try to import from the installed package
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras
except ImportError:
    # If the import fails, add the parent directory to the Python path
    current_file = Path(__file__).resolve()
    parent_directory = current_file.parent.parent
    sys.path.append(str(parent_directory))
    
    # Now try to import again
    from ras_commander import init_ras_project, RasExamples, RasCmdr, RasPlan, RasGeo, RasUnsteady, RasUtils, ras

example_projects_folder = Path(__file__).parent.parent / "example_projects"

# delete the folder if it exists
if example_projects_folder.exists():
    shutil.rmtree(example_projects_folder)


# Extract specific projects
ras_examples = RasExamples()
ras_examples.extract_project(["Balde Eagle Creek"])

#### --- START OF SCRIPT --- ####

def main():
    # Initialize the project
    current_dir = Path(__file__).parent
    project_path = current_dir / "example_projects" / "Balde Eagle Creek"
    init_ras_project(project_path, "6.5")

    print("Available plans:")
    print(ras.plan_df)
    print()

    # Example 1: Execute a single plan using compute_test_mode
    print("Example 1: Executing a single plan using compute_test_mode")
    single_plan = "01"
    dest_folder_suffix = "[SinglePlanTest]"
    compute_folder = project_path.parent / f"{project_path.name} {dest_folder_suffix}"
    
    # Delete the compute folder if it exists
    if compute_folder.exists():
        shutil.rmtree(compute_folder)
        print(f"Deleted existing compute folder: {compute_folder}")

    RasCmdr.compute_test_mode(
        plan_number=single_plan,
        dest_folder_suffix=dest_folder_suffix,
        clear_geompre=False,
        num_cores=2
    )
    print(f"Execution of plan {single_plan} completed using compute_test_mode")
    print()

    # Example 2: Execute a single plan using compute_parallel
    print("Example 2: Executing a single plan using compute_parallel")
    parallel_result_folder = project_path.parent / "parallel_single_plan_result"
    if parallel_result_folder.exists():
        shutil.rmtree(parallel_result_folder)
        print(f"Deleted existing result folder: {parallel_result_folder}")

    results = RasCmdr.compute_parallel(
        plan_number=single_plan,
        max_workers=1,
        num_cores=2,
        dest_folder=parallel_result_folder
    )
    print("Parallel execution of single plan results:")
    for plan_number, success in results.items():
        print(f"Plan {plan_number}: {'Successful' if success else 'Failed'}")
    print()

    # Example 3: Execute a single plan using compute_test_mode with a string input
    print("Example 3: Executing a single plan using compute_test_mode with a string input")
    dest_folder_suffix = "[SinglePlanTestString]"
    compute_folder = project_path.parent / f"{project_path.name} {dest_folder_suffix}"
    
    # Delete the compute folder if it exists
    if compute_folder.exists():
        shutil.rmtree(compute_folder)
        print(f"Deleted existing compute folder: {compute_folder}")

    RasCmdr.compute_test_mode(
        plan_number="02",
        dest_folder_suffix=dest_folder_suffix,
        clear_geompre=False,
        num_cores=2
    )
    print("Execution of plan 02 completed using compute_test_mode with string input")
    print()

    # Example 4: Execute a single plan using compute_parallel with a string input
    print("Example 4: Executing a single plan using compute_parallel with a string input")
    parallel_result_folder = project_path.parent / "parallel_single_plan_string_result"
    if parallel_result_folder.exists():
        shutil.rmtree(parallel_result_folder)
        print(f"Deleted existing result folder: {parallel_result_folder}")

    results = RasCmdr.compute_parallel(
        plan_number="01",  # Changed from "03" to "01"
        max_workers=1,
        num_cores=2,
        dest_folder=parallel_result_folder
    )
    print("Parallel execution of single plan (string input) results:")
    for plan_number, success in results.items():
        print(f"Plan {plan_number}: {'Successful' if success else 'Failed'}")
    print()

    # Example 5: Attempt to execute with an empty plan list
    print("Example 5: Attempting to execute with an empty plan list")
    dest_folder_suffix = "[EmptyPlanList]"
    compute_folder = project_path.parent / f"{project_path.name} {dest_folder_suffix}"
    
    if compute_folder.exists():
        shutil.rmtree(compute_folder)
        print(f"Deleted existing compute folder: {compute_folder}")

    try:
        RasCmdr.compute_test_mode(plan_number=[], dest_folder_suffix=dest_folder_suffix)
    except ValueError as e:
        print(f"Error caught: {e}")
    print()

    # Example 6: Attempt to execute with a non-existent plan number
    print("Example 6: Attempting to execute with a non-existent plan number")
    non_existent_plan = "99"
    dest_folder_suffix = "[NonExistentPlan]"
    compute_folder = project_path.parent / f"{project_path.name} {dest_folder_suffix}"
    
    if compute_folder.exists():
        shutil.rmtree(compute_folder)
        print(f"Deleted existing compute folder: {compute_folder}")

    try:
        RasCmdr.compute_test_mode(plan_number=non_existent_plan, dest_folder_suffix=dest_folder_suffix)
    except ValueError as e:
        print(f"Error caught: {e}")
    print()

if __name__ == "__main__":
    main()
==================================================

File: c:\GH\ras-commander\ras_commander\RasCmdr.py
==================================================
"""
Execution operations for running HEC-RAS simulations using subprocess.
Based on the HEC-Commander project's "Command Line is All You Need" approach, leveraging the -c compute flag to run HEC-RAS and orchestrating changes directly in the RAS input files to achieve automation outcomes. 
"""

import os
import subprocess
import shutil
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, as_completed
from .RasPrj import ras, RasPrj, init_ras_project, get_ras_exe
from .RasPlan import RasPlan
from .RasGeo import RasGeo
from .RasUtils import RasUtils
import subprocess
import os
import logging
import time
import pandas as pd
from threading import Thread, Lock
import queue
from pathlib import Path
import shutil
import queue
from threading import Thread, Lock
import time

# TO DO: 
# 1. Alternate Run Mode for compute_plan and compute_parallel:  Using Powershell to execute the HEC-RAS command and hide the RAS window and all child windows.
#    If this is implemented, and the plan has a popup, then the plan will not execute.  This is a deal breaker for many scenarios, and should only be used
#    as a special option for those who don't want to deal with the popups, or want to run in the background.  This option should be limited to non-commercial use.
# 2. Implment compute_plan_remote to go along with compute_plan.  This will be a compute_plan that is run on a remote machine via a psexec command.
#    First, we will use the keyring package to securely store the remote machine username and password.
#    Second, we will implement the psexec command to execute the HEC-RAS command on the remote machine.
#    Each machine will need to be initialized as a remote_worker object, which will store the machine name, username, password, ras_exe_path, local folder path and other relevant info.
#    A separate RasRemote class will be created to handle the creation of the remote_worker objects and the necessary abstractions. 
#    The compute_plan_remote function will live in RasCmdr, and will be a thin abstraction above the RasRemote class, since the functions will be simliar to the existing compute_plan functions, but specific to remote execution.  


class RasCmdr:
    @staticmethod
    def compute_plan(
        plan_number,
        dest_folder=None, 
        ras_object=None,
        clear_geompre=False,
        num_cores=None,
        overwrite_dest=False
    ):
        """
        Execute a HEC-RAS plan.

        Args:
            plan_number (str, Path): The plan number to execute (e.g., "01", "02") or the full path to the plan file.
            dest_folder (str, Path, optional): Name of the folder or full path for computation.
                If a string is provided, it will be created in the same parent directory as the project folder.
                If a full path is provided, it will be used as is.
            ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
            clear_geompre (bool, optional): Whether to clear geometry preprocessor files. Defaults to False.
            num_cores (int, optional): Number of cores to use for the plan execution. If None, the current setting is not changed.
            overwrite_dest (bool, optional): If True, overwrite the destination folder if it exists. Defaults to False.

        Returns:
            bool: True if the execution was successful, False otherwise.

        Raises:
            ValueError: If the specified dest_folder already exists and is not empty, and overwrite_dest is False.
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        if dest_folder is not None:
            dest_folder = Path(ras_obj.project_folder).parent / dest_folder if isinstance(dest_folder, str) else Path(dest_folder)
            
            if dest_folder.exists():
                if overwrite_dest:
                    shutil.rmtree(dest_folder)
                elif any(dest_folder.iterdir()):
                    raise ValueError(f"Destination folder '{dest_folder}' exists and is not empty. Use overwrite_dest=True to overwrite.")
            
            dest_folder.mkdir(parents=True, exist_ok=True)
            shutil.copytree(ras_obj.project_folder, dest_folder, dirs_exist_ok=True)
            
            compute_ras = RasPrj()
            compute_ras.initialize(dest_folder, ras_obj.ras_exe_path)
            compute_prj_path = compute_ras.prj_file
        else:
            compute_ras = ras_obj
            compute_prj_path = ras_obj.prj_file

        # Determine the plan path
        compute_plan_path = Path(plan_number) if isinstance(plan_number, (str, Path)) and Path(plan_number).is_file() else RasPlan.get_plan_path(plan_number, compute_ras)

        if not compute_prj_path or not compute_plan_path:
            print(f"Error: Could not find project file or plan file for plan {plan_number}")
            return False

        # Clear geometry preprocessor files if requested
        if clear_geompre:
            try:
                RasGeo.clear_geompre_files(compute_plan_path, ras_object=compute_ras)
                print(f"Cleared geometry preprocessor files for plan: {plan_number}")
            except Exception as e:
                print(f"Error clearing geometry preprocessor files for plan {plan_number}: {str(e)}")

        # Set the number of cores if specified
        if num_cores is not None:
            try:
                RasPlan.set_num_cores(compute_plan_path, num_cores=num_cores, ras_object=compute_ras)
                print(f"Set number of cores to {num_cores} for plan: {plan_number}")
            except Exception as e:
                print(f"Error setting number of cores for plan {plan_number}: {str(e)}")

        # Prepare the command for HEC-RAS execution
        cmd = f'"{compute_ras.ras_exe_path}" -c "{compute_prj_path}" "{compute_plan_path}"'
        print("Running HEC-RAS from the Command Line:")
        print(f"Running command: {cmd}")

        # Execute the HEC-RAS command
        start_time = time.time()
        try:
            subprocess.run(cmd, check=True, shell=True, capture_output=True, text=True)
            end_time = time.time()
            run_time = end_time - start_time
            print(f"HEC-RAS execution completed for plan: {plan_number}")
            print(f"Total run time for plan {plan_number}: {run_time:.2f} seconds")
            return True
        except subprocess.CalledProcessError as e:
            end_time = time.time()
            run_time = end_time - start_time
            print(f"Error running plan: {plan_number}")
            print(f"Error message: {e.output}")
            print(f"Total run time for plan {plan_number}: {run_time:.2f} seconds")
            return False

        ras_obj = ras_object or ras
        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()



    @staticmethod
    def compute_parallel(
        plan_number: str | list[str] | None = None,
        max_workers: int = 2,
        num_cores: int = 2,
        clear_geompre: bool = False,
        ras_object: RasPrj | None = None,
        dest_folder: str | Path | None = None,
        overwrite_dest: bool = False
    ) -> dict[str, bool]:
        """
        Execute HEC-RAS plans in parallel using multiple worker threads.

        This function creates separate worker folders, copies the project to each, and executes the specified plans
        in parallel. It allows for isolated and concurrent execution of multiple plans.

        Args:
            plan_number (str | list[str] | None): Plan number, list of plan numbers, or None to execute all plans.
            max_workers (int, optional): Maximum number of worker threads to use. Default is 2.
            num_cores (int, optional): Number of cores to use for each plan execution. Default is 2.
            clear_geompre (bool, optional): Whether to clear geometry preprocessor files. Defaults to False.
            ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
            dest_folder (str | Path, optional): Destination folder for the final computed results.
                If None, results will be stored in a "[Computed]" folder next to the original project.
            overwrite_dest (bool, optional): If True, overwrite the destination folder if it exists. Defaults to False.

        Returns:
            dict[str, bool]: A dictionary with plan numbers as keys and boolean values indicating success (True) or failure (False).

        Raises:
            ValueError: If the destination folder exists and is not empty, and overwrite_dest is False.
            FileNotFoundError: If a plan file is not found.

        Notes:
            - This function creates separate folders for each worker to ensure isolated execution.
            - Each worker uses its own RAS object to prevent conflicts.
            - Plans are distributed among workers using a queue to ensure efficient parallel processing.
            - The function automatically handles cleanup and consolidation of results after execution.
        
        Revision Notes:
            - Added support for clear_geompre flag as a pass-through to compute_plan.
            - Simplified worker thread logic by removing redundant operations.
            - Removed duplicate RAS object initialization in worker threads.
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()

        project_folder = ras_obj.project_folder

        if dest_folder is not None:
            dest_folder_path = Path(dest_folder)
            if dest_folder_path.exists():
                if overwrite_dest:
                    shutil.rmtree(dest_folder_path)
                elif any(dest_folder_path.iterdir()):
                    raise ValueError(f"Destination folder '{dest_folder_path}' exists and is not empty. Use overwrite_dest=True to overwrite.")
            dest_folder_path.mkdir(parents=True, exist_ok=True)
            shutil.copytree(project_folder, dest_folder_path, dirs_exist_ok=True)
            project_folder = dest_folder_path

        if plan_number:
            if isinstance(plan_number, str):
                plan_number = [plan_number]
            ras_obj.plan_df = ras_obj.plan_df[ras_obj.plan_df['plan_number'].isin(plan_number)]

        num_plans = len(ras_obj.plan_df)
        max_workers = min(max_workers, num_plans) if num_plans > 0 else 1
        print(f"Adjusted max_workers to {max_workers} based on the number of plans: {num_plans}")

        # Clean up existing worker folders and create new ones
        worker_ras_objects = {}
        for worker_id in range(1, max_workers + 1):
            worker_folder = project_folder.parent / f"{project_folder.name} [Worker {worker_id}]"
            if worker_folder.exists():
                shutil.rmtree(worker_folder)
            shutil.copytree(project_folder, worker_folder)
            
            worker_ras_instance = init_ras_project(
                ras_project_folder=worker_folder,
                ras_version=ras_obj.ras_exe_path,
                ras_instance=RasPrj()
            )
            worker_ras_objects[worker_id] = worker_ras_instance

        plan_queue = queue.Queue()
        for plan_number in ras_obj.plan_df['plan_number']:
            plan_queue.put(plan_number)

        execution_results: dict[str, bool] = {}
        results_lock = Lock()
        queue_lock = Lock()

        def worker_thread(worker_id: int):
            worker_ras_obj = worker_ras_objects[worker_id]
            while True:
                with queue_lock:
                    if plan_queue.empty():
                        break
                    plan_number = plan_queue.get()
                
                try:
                    print(f"Worker {worker_id} executing plan {plan_number}")
                    success = RasCmdr.compute_plan(
                        plan_number, 
                        ras_object=worker_ras_obj, 
                        clear_geompre=clear_geompre,
                        num_cores=num_cores
                    )
                    with results_lock:
                        execution_results[plan_number] = success
                    print(f"Completed: Plan {plan_number} in worker {worker_id}")
                except Exception as e:
                    with results_lock:
                        execution_results[plan_number] = False
                    print(f"Failed: Plan {plan_number} in worker {worker_id}. Error: {str(e)}")

        # Start worker threads
        worker_threads = [Thread(target=worker_thread, args=(worker_id,)) for worker_id in range(1, max_workers + 1)]
        for thread in worker_threads:
            thread.start()

        # Wait for all threads to complete
        for thread in worker_threads:
            thread.join()

        # Consolidate results
        final_dest_folder = dest_folder_path if dest_folder is not None else project_folder.parent / f"{project_folder.name} [Computed]"
        final_dest_folder.mkdir(exist_ok=True)
        print(f"Final destination for computed results: {final_dest_folder}")

        for worker_ras in worker_ras_objects.values():
            worker_folder = worker_ras.project_folder
            try:
                for item in worker_folder.iterdir():
                    dest_path = final_dest_folder / item.name
                    if dest_path.exists():
                        if dest_path.is_dir():
                            shutil.rmtree(dest_path)
                        else:
                            dest_path.unlink()
                    shutil.move(str(item), final_dest_folder)
                shutil.rmtree(worker_folder)
            except Exception as e:
                print(f"Error moving results from {worker_folder} to {final_dest_folder}: {str(e)}")

        # Print execution results for each plan
        print("\nExecution Results:")
        for plan_number, success in execution_results.items():
            print(f"Plan {plan_number}: {'Successful' if success else 'Failed'}")

        return execution_results
    
    
    
    @staticmethod
    def compute_test_mode(
        plan_number=None, 
        dest_folder_suffix="[Test]", 
        clear_geompre=False, 
        num_cores=None, 
        ras_object=None,
        overwrite_dest=False
    ):
        """
        Execute HEC-RAS plans in test mode.  This is a re-creation of the HEC-RAS command line -test flag, 
        which does not work in recent versions of HEC-RAS.
        
        As a special-purpose function that emulates the original -test flag, it operates differently than the 
        other two compute_ functions.  Per the original HEC-RAS test flag, it creates a separate test folder,
        copies the project there, and executes the specified plans in sequential order.
        
        For most purposes, just copying a the project folder, initing that new folder, then running each plan 
        with compute_plan is a simpler and more flexible approach.  This is shown in the examples provided
        in the ras-commander library.

        Args:
            plan_number (str, list[str], optional): Plan number or list of plan numbers to execute. 
                If None, all plans will be executed. Default is None.
            dest_folder_suffix (str, optional): Suffix to append to the test folder name to create dest_folder. 
                Defaults to "[Test]".
                dest_folder is always created in the project folder's parent directory.
            clear_geompre (bool, optional): Whether to clear geometry preprocessor files.
                Defaults to False.
            num_cores (int, optional): Maximum number of cores to use for each plan.
                If None, the current setting is not changed. Default is None.
            ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
            overwrite_dest (bool, optional): If True, overwrite the destination folder if it exists. Defaults to False.

        Returns:
            None

        Example:
            Run all plans: RasCommander.compute_test_mode()
            Run a specific plan: RasCommander.compute_test_mode(plan_number="01")
            Run multiple plans: RasCommander.compute_test_mode(plan_number=["01", "03", "05"])
            Run plans with a custom folder suffix: RasCommander.compute_test_mode(dest_folder_suffix="[TestRun]")
            Run plans and clear geometry preprocessor files: RasCommander.compute_test_mode(clear_geompre=True)
            Run plans with a specific number of cores: RasCommander.compute_test_mode(num_cores=4)
            
        Notes:
            - This function executes plans in a separate folder for isolated testing.
            - If plan_number is not provided, all plans in the project will be executed.
            - The function does not change the geometry preprocessor and IB tables settings.  
                - To force recomputing of geometry preprocessor and IB tables, use the clear_geompre=True option.
            - Plans are executed sequentially.
            - Because copying the project is implicit, only a dest_folder_suffix option is provided.
            - For more flexible run management, use the compute_parallel or compute_sequential functions.
        """
        
        # This line of code is used to initialize the RasPrj object with the default "ras" object if no specific object is provided.
        ras_obj = ras_object or ras
        # This line of code is used to check if the RasPrj object is initialized.
        ras_obj.check_initialized()
        
        print("Starting the compute_test_mode...")
           
        # Use the project folder from the ras object
        project_folder = ras_obj.project_folder

        # Check if the project folder exists
        if not project_folder.exists():
            print(f"Error: Project folder '{project_folder}' does not exist.")
            return

        # Create test folder with the specified suffix in the same directory as the project folder
        compute_folder = project_folder.parent / f"{project_folder.name} {dest_folder_suffix}"
        print(f"Creating the test folder: {compute_folder}...")

        # Check if the compute folder exists and is empty
        if compute_folder.exists():
            if overwrite_dest:
                shutil.rmtree(compute_folder)
            elif any(compute_folder.iterdir()):
                raise ValueError(
                    f"Compute folder '{compute_folder}' exists and is not empty. "
                    "Use overwrite_dest=True to overwrite."
                )
        else:
            try:
                shutil.copytree(project_folder, compute_folder)
            except FileNotFoundError:
                print(f"Error: Unable to copy project folder. Source folder '{project_folder}' not found.")
                return
            except PermissionError:
                print(f"Error: Permission denied when trying to create or copy to '{compute_folder}'.")
                return
            except Exception as e:
                print(f"Error occurred while copying project folder: {str(e)}")
                return

        # Initialize a new RAS project in the compute folder
        try:
            compute_ras = RasPrj()
            compute_ras.initialize(compute_folder, ras_obj.ras_exe_path)
            compute_prj_path = compute_ras.prj_file
        except Exception as e:
            print(f"Error initializing RAS project in compute folder: {str(e)}")
            return

        if not compute_prj_path:
            print("Project file not found.")
            return


        # Get plan entries
        print("Getting plan entries...")
        try:
            ras_compute_plan_entries = compute_ras.plan_df
            print("Retrieved plan entries successfully.")
        except Exception as e:
            print(f"Error retrieving plan entries: {str(e)}")
            return

        if plan_number:
            if isinstance(plan_number, str):
                plan_number = [plan_number]
            ras_compute_plan_entries = ras_compute_plan_entries[
                ras_compute_plan_entries['plan_number'].isin(plan_number)
            ]
            print(f"Filtered plans to execute: {plan_number}")

        print("Running selected plans sequentially...")
        for _, plan in ras_compute_plan_entries.iterrows():
            plan_number = plan["plan_number"]
            start_time = time.time()
            try:
                RasCommander.compute_plan(
                    plan_number,
                    ras_object=compute_ras,
                    clear_geompre=clear_geompre,
                    num_cores=num_cores
                )
            except Exception as e:
                print(f"Error computing plan {plan_number}: {str(e)}")
            end_time = time.time()
            run_time = end_time - start_time
            print(f"Total run time for plan {plan_number}: {run_time:.2f} seconds")

        print("All selected plans have been executed.")
        print("compute_test_mode completed.")

        ras_obj = ras_object or ras
        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()
==================================================

File: c:\GH\ras-commander\ras_commander\RasExamples.py
==================================================
import os
import requests
import zipfile
import pandas as pd
from pathlib import Path
import shutil
from typing import Union, List
import csv
from datetime import datetime

class RasExamples:
    """
    A class for quickly loading HEC-RAS example projects for testing and development of ras-commander.

    This class provides functionality to download, extract, and manage HEC-RAS example projects.
    It supports both default HEC-RAS example projects and custom projects from user-provided URLs.

    Expected folder structure:              Notes:
    ras-commander/
     examples/                           # This is examples_dir
        example_projects/               # This is projects_dir
           Balde Eagle Creek/          # Individual Projects from Zip file
           Muncie/                 
           ...
        Example_Projects_6_5.zip        # HEC-RAS Example Projects zip file will be downloaded here
        example_projects.csv            # CSV file containing cached project metadata
        01_project_initialization.py    # ras-commander library examples are also at this level
        ...
     ras_commander/                      # Code for the ras-commander library

    Attributes:
        base_url (str): Base URL for downloading HEC-RAS example projects.
        valid_versions (list): List of valid HEC-RAS versions for example projects.
        base_dir (Path): Base directory for storing example projects.
        examples_dir (Path): Directory for example projects and related files. (assumed to be parent )
        projects_dir (Path): Directory where example projects are extracted.
        zip_file_path (Path): Path to the downloaded zip file.
        folder_df (pd.DataFrame): DataFrame containing folder structure information.
        csv_file_path (Path): Path to the CSV file for caching project metadata.

    
    Future Improvements:
    - Implement the ability for user-provided example projects (provided as a zip file) for their own repeatable examples. 
    - If the zip file is in the same folder structure as the HEC-RAS example projects, simple replace Example_Projects_6_5.zip and the folder structure will be automatically extracted from the zip file.
    - The actual RAS example projects haven't been updated much, but there is the structure here to handle future versions. Although this version of the code is probably fine for a few years, until HEC-RAS 2025 comes out. 
       
    """

    def __init__(self):
        """
        Initialize the RasExamples class.

        This constructor sets up the necessary attributes and paths for managing HEC-RAS example projects.
        It initializes the base URL for downloads, valid versions, directory paths, and other essential
        attributes. It also creates the projects directory if it doesn't exist and loads the project data.

        The method also prints the location of the example projects folder and calls _load_project_data()
        to initialize the project data.
        """
        self.base_url = 'https://github.com/HydrologicEngineeringCenter/hec-downloads/releases/download/'
        self.valid_versions = [
            "6.5", "6.4.1", "6.3.1", "6.3", "6.2", "6.1", "6.0",
            "5.0.7", "5.0.6", "5.0.5", "5.0.4", "5.0.3", "5.0.1", "5.0",
            "4.1", "4.0", "3.1.3", "3.1.2", "3.1.1", "3.0", "2.2"
        ]
        self.base_dir = Path.cwd()
        self.examples_dir = self.base_dir
        self.projects_dir = self.examples_dir / 'example_projects'
        self.zip_file_path = None
        self.folder_df = None
        self.csv_file_path = self.examples_dir / 'example_projects.csv'

        self.projects_dir.mkdir(parents=True, exist_ok=True)
        print(f"Example projects folder: {self.projects_dir}")
        self._load_project_data()

    def _load_project_data(self):
        """
        Load project data from CSV if up-to-date, otherwise extract from zip.

        Checks for existing CSV file and compares modification times with zip file.
        Extracts folder structure if necessary and saves to CSV.
        """
        self._find_zip_file()
        
        if not self.zip_file_path:
            print("No example projects zip file found. Downloading...")
            self.get_example_projects()
        
        zip_modified_time = os.path.getmtime(self.zip_file_path)
        
        if self.csv_file_path.exists():
            csv_modified_time = os.path.getmtime(self.csv_file_path)
            
            if csv_modified_time >= zip_modified_time:
                print("Loading project data from CSV...")
                self.folder_df = pd.read_csv(self.csv_file_path)
                print(f"Loaded {len(self.folder_df)} projects from CSV, use list_categories() and list_projects() to explore them")
                return

        print("Extracting folder structure from zip file...")
        self._extract_folder_structure()
        self._save_to_csv()

    def _find_zip_file(self):
        """Locate the example projects zip file in the examples directory."""
        for version in self.valid_versions:
            potential_zip = self.examples_dir / f"Example_Projects_{version.replace('.', '_')}.zip"
            if potential_zip.exists():
                self.zip_file_path = potential_zip
                print(f"Found zip file: {self.zip_file_path}")
                break

    def _extract_folder_structure(self):
        """
        Extract folder structure from the zip file.

        Populates folder_df with category and project information.
        """
        folder_data = []
        try:
            with zipfile.ZipFile(self.zip_file_path, 'r') as zip_ref:
                for file in zip_ref.namelist():
                    parts = Path(file).parts
                    if len(parts) > 2:
                        folder_data.append({
                            'Category': parts[1],
                            'Project': parts[2]
                        })
            
            self.folder_df = pd.DataFrame(folder_data).drop_duplicates()
            print(f"Extracted {len(self.folder_df)} projects")
            print("folder_df:")
            display(self.folder_df)
        except Exception as e:
            print(f"An error occurred while extracting the folder structure: {str(e)}")
            self.folder_df = pd.DataFrame(columns=['Category', 'Project'])

    def _save_to_csv(self):
        """Save the extracted folder structure to CSV file."""
        if self.folder_df is not None and not self.folder_df.empty:
            self.folder_df.to_csv(self.csv_file_path, index=False)
            print(f"Saved project data to {self.csv_file_path}")

    def get_example_projects(self, version_number='6.5'):
        """
        Download and extract HEC-RAS example projects for a specified version.

        Args:
            version_number (str): HEC-RAS version number. Defaults to '6.5'.

        Returns:
            Path: Path to the extracted example projects.

        Raises:
            ValueError: If an invalid version number is provided.
        """
        print(f"Getting example projects for version {version_number}")
        if version_number not in self.valid_versions:
            raise ValueError(f"Invalid version number. Valid versions are: {', '.join(self.valid_versions)}")

        zip_url = f"{self.base_url}1.0.31/Example_Projects_{version_number.replace('.', '_')}.zip"
        
        self.examples_dir.mkdir(parents=True, exist_ok=True)
        
        self.zip_file_path = self.examples_dir / f"Example_Projects_{version_number.replace('.', '_')}.zip"

        if not self.zip_file_path.exists():
            print(f"Downloading HEC-RAS Example Projects from {zip_url}. \n The file is over 400 MB, so it may take a few minutes to download....")
            response = requests.get(zip_url)
            with open(self.zip_file_path, 'wb') as file:
                file.write(response.content)
            print(f"Downloaded to {self.zip_file_path}")
        else:
            print("HEC-RAS Example Projects zip file already exists. Skipping download.")

        self._load_project_data()
        return self.projects_dir

    def list_categories(self):
        """
        List all categories of example projects.

        Returns:
            list: Available categories.
        """
        if self.folder_df is None or 'Category' not in self.folder_df.columns:
            print("No categories available. Make sure the zip file is properly loaded.")
            return []
        categories = self.folder_df['Category'].unique()
        print(f"Available categories: {', '.join(categories)}")
        return categories.tolist()

    def list_projects(self, category=None):
        """
        List all projects or projects in a specific category.

        Args:
            category (str, optional): Category to filter projects.

        Returns:
            list: List of project names.
        """
        if self.folder_df is None:
            print("No projects available. Make sure the zip file is properly loaded.")
            return []
        if category:
            projects = self.folder_df[self.folder_df['Category'] == category]['Project'].unique()
        else:
            projects = self.folder_df['Project'].unique()
        return projects.tolist()

    def extract_project(self, project_names: Union[str, List[str]]):
        """
        Extract one or more specific projects from the zip file.

        Args:
            project_names (str or List[str]): Name(s) of the project(s) to extract.

        Returns:
            List[Path]: List of paths to the extracted project(s).

        Raises:
            ValueError: If any project is not found.
        """
        if isinstance(project_names, str):
            project_names = [project_names]

        extracted_paths = []

        for project_name in project_names:
            print("----- RasExamples Extracting Project -----")
            print(f"Extracting project '{project_name}'")
            project_path = self.projects_dir / project_name

            if project_path.exists():
                print(f"Project '{project_name}' already exists. Deleting existing folder...")
                shutil.rmtree(project_path)
                print(f"Existing folder for project '{project_name}' has been deleted.")

            if self.folder_df is None or self.folder_df.empty:
                raise ValueError("No project information available. Make sure the zip file is properly loaded.")

            project_info = self.folder_df[self.folder_df['Project'] == project_name]
            if project_info.empty:
                raise ValueError(f"Project '{project_name}' not found in the zip file.")

            category = project_info['Category'].iloc[0]
            
            # Ensure the project directory exists
            project_path.mkdir(parents=True, exist_ok=True)

            try:
                with zipfile.ZipFile(self.zip_file_path, 'r') as zip_ref:
                    for file in zip_ref.namelist():
                        parts = Path(file).parts
                        if len(parts) > 2 and parts[2] == project_name:
                            # Remove the first two levels (category and project name)
                            relative_path = Path(*parts[3:])
                            extract_path = project_path / relative_path
                            if file.endswith('/'):
                                extract_path.mkdir(parents=True, exist_ok=True)
                            else:
                                extract_path.parent.mkdir(parents=True, exist_ok=True)
                                with zip_ref.open(file) as source, open(extract_path, "wb") as target:
                                    shutil.copyfileobj(source, target)

                print(f"Successfully extracted project '{project_name}' to {project_path}")
                extracted_paths.append(project_path)
            except zipfile.BadZipFile:
                print(f"Error: The file {self.zip_file_path} is not a valid zip file.")
            except FileNotFoundError:
                print(f"Error: The file {self.zip_file_path} was not found.")
            except Exception as e:
                print(f"An unexpected error occurred while extracting the project: {str(e)}")
            #print("----- RasExamples Extraction Complete -----")
        return extracted_paths

    def is_project_extracted(self, project_name):
        """
        Check if a specific project is already extracted.

        Args:
            project_name (str): Name of the project to check.

        Returns:
            bool: True if the project is extracted, False otherwise.
        """
        project_path = self.projects_dir / project_name
        return project_path.exists()

    def clean_projects_directory(self):
        """Remove all extracted projects from the example_projects directory."""
        print(f"Cleaning projects directory: {self.projects_dir}")
        if self.projects_dir.exists():
            shutil.rmtree(self.projects_dir)
        self.projects_dir.mkdir(parents=True, exist_ok=True)
        print("Projects directory cleaned.")

# Example usage:
# ras_examples = RasExamples()
# extracted_paths = ras_examples.extract_project(["Bald Eagle Creek", "BaldEagleCrkMulti2D", "Muncie"])
# for path in extracted_paths:
#     print(f"Extracted to: {path}")

==================================================

File: c:\GH\ras-commander\ras_commander\RasGeo.py
==================================================
"""
Operations for handling geometry files in HEC-RAS projects.
"""
from pathlib import Path
from typing import List, Union
from .RasPlan import RasPlan
from .RasPrj import ras
import re

class RasGeo:
    """
    A class for operations on HEC-RAS geometry files.
    """
    
    @staticmethod
    def clear_geompre_files(
        plan_files: Union[str, Path, List[Union[str, Path]]] = None,
        ras_object = None
    ) -> None:
        """
        Clear HEC-RAS geometry preprocessor files for specified plan files or all plan files in the project directory.
        
        Limitations/Future Work:
        - This function only deletes the geometry preprocessor file.
        - It does not clear the IB tables.
        - It also does not clear geometry preprocessor tables from the geometry HDF.
        - All of these features will need to be added to reliably remove geometry preprocessor files for 1D and 2D projects.
        
        Parameters:
            plan_files (Union[str, Path, List[Union[str, Path]]], optional): 
                Full path(s) to the HEC-RAS plan file(s) (.p*).
                If None, clears all plan files in the project directory.
            ras_object: An optional RAS object instance.
        
        Returns:
            None
        
        Examples:
            # Clear all geometry preprocessor files in the project directory
            RasGeo.clear_geompre_files()
            
            # Clear a single plan file
            RasGeo.clear_geompre_files(r'path/to/plan.p01')
            
            # Clear multiple plan files
            RasGeo.clear_geompre_files([r'path/to/plan1.p01', r'path/to/plan2.p02'])

        Note:
            This function updates the ras object's geometry dataframe after clearing the preprocessor files.
        """
        ## Explicit Function Steps
        # 1. Initialize the ras_object, defaulting to the global ras if not provided.
        # 2. Define a helper function to clear a single geometry preprocessor file.
        # 3. Determine the list of plan files to process based on the input.
        # 4. Iterate over each plan file and clear its geometry preprocessor file.
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        def clear_single_file(plan_file: Union[str, Path], ras_obj) -> None:
            plan_path = Path(plan_file)
            geom_preprocessor_suffix = '.c' + ''.join(plan_path.suffixes[1:]) if plan_path.suffixes else '.c'
            geom_preprocessor_file = plan_path.with_suffix(geom_preprocessor_suffix)
            if geom_preprocessor_file.exists():
                try:
                    print(f"Deleting geometry preprocessor file: {geom_preprocessor_file}")
                    geom_preprocessor_file.unlink()
                    print("File deletion completed successfully.")
                except PermissionError:
                    raise PermissionError(f"Unable to delete geometry preprocessor file: {geom_preprocessor_file}. Permission denied.")
                except OSError as e:
                    raise OSError(f"Error deleting geometry preprocessor file: {geom_preprocessor_file}. {str(e)}")
            else:
                print(f"No geometry preprocessor file found for: {plan_file}")
        
        if plan_files is None:
            print("Clearing all geometry preprocessor files in the project directory.")
            plan_files_to_clear = list(ras_obj.project_folder.glob(r'*.p*'))
        elif isinstance(plan_files, (str, Path)):
            plan_files_to_clear = [plan_files]
        elif isinstance(plan_files, list):
            plan_files_to_clear = plan_files
        else:
            raise ValueError("Invalid input. Please provide a string, Path, list of paths, or None.")
        
        for plan_file in plan_files_to_clear:
            clear_single_file(plan_file, ras_obj)
        ras_obj.geom_df = ras_obj.get_geom_entries()


==================================================

File: c:\GH\ras-commander\ras_commander\RasPlan.py
==================================================
"""
Operations for modifying and updating HEC-RAS plan files.

"""
import re
from pathlib import Path
import shutil
from typing import Union, Optional
import pandas as pd
from .RasPrj import RasPrj, ras
from .RasUtils import RasUtils

class RasPlan:
    """
    A class for operations on HEC-RAS plan files.
    """
    
    @staticmethod
    def set_geom(plan_number: Union[str, int], new_geom: Union[str, int], ras_object=None) -> pd.DataFrame:
        """
        Set the geometry for the specified plan.

        Parameters:
            plan_number (Union[str, int]): The plan number to update.
            new_geom (Union[str, int]): The new geometry number to set.
            ras_object: An optional RAS object instance.

        Returns:
            pd.DataFrame: The updated geometry DataFrame.

        Example:
            updated_geom_df = RasPlan.set_geom('02', '03')

        Note:
            This function updates the ras object's dataframes after modifying the project structure.
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()

        # Ensure plan_number and new_geom are strings
        plan_number = str(plan_number).zfill(2)
        new_geom = str(new_geom).zfill(2)

        # Before doing anything, make sure the plan, geom, flow, and unsteady dataframes are current
        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()
        
        # List the geom_df for debugging
        print("Current geometry DataFrame within the function:")
        print(ras_obj.geom_df)
        
        if new_geom not in ras_obj.geom_df['geom_number'].values:
            raise ValueError(f"Geometry {new_geom} not found in project.")

        # Update the geometry for the specified plan
        ras_obj.plan_df.loc[ras_obj.plan_df['plan_number'] == plan_number, 'geom_number'] = new_geom

        print(f"Geometry for plan {plan_number} set to {new_geom}")
        print("Updated plan DataFrame:")
        display(ras_obj.plan_df)

        # Update the project file
        prj_file_path = ras_obj.prj_file
        with open(prj_file_path, 'r') as f:
            lines = f.readlines()

        plan_pattern = re.compile(rf"^Plan File=p{plan_number}", re.IGNORECASE)
        geom_pattern = re.compile(r"^Geom File=g\d+", re.IGNORECASE)
        
        for i, line in enumerate(lines):
            if plan_pattern.match(line):
                for j in range(i+1, len(lines)):
                    if geom_pattern.match(lines[j]):
                        lines[j] = f"Geom File=g{new_geom}\n"
                        break
                break

        with open(prj_file_path, 'w') as f:
            f.writelines(lines)

        print(f"Updated project file with new geometry for plan {plan_number}")

        # Re-initialize the ras object to reflect changes
        ras_obj.initialize(ras_obj.project_folder, ras_obj.ras_exe_path)

        return ras_obj.plan_df

    @staticmethod
    def set_steady(plan_number: str, new_steady_flow_number: str, ras_object=None):
        """
        Apply a steady flow file to a plan file.
        
        Parameters:
        plan_number (str): Plan number (e.g., '02')
        new_steady_flow_number (str): Steady flow number to apply (e.g., '01')
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
        
        Returns:
        None

        Raises:
        ValueError: If the specified steady flow number is not found in the project file
        FileNotFoundError: If the specified plan file is not found

        Example:
        >>> RasPlan.set_steady('02', '01')

        Note:
            This function updates the ras object's dataframes after modifying the project structure.
        """
        logging.info(f"Setting steady flow file to {new_steady_flow_number} in Plan {plan_number}")
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
                        
        # Update the flow dataframe in the ras instance to ensure it is current
        ras_obj.flow_df = ras_obj.get_flow_entries()
        
        if new_steady_flow_number not in ras_obj.flow_df['flow_number'].values:
            raise ValueError(f"Steady flow number {new_steady_flow_number} not found in project file.")
        
        # Resolve the full path of the plan file
        plan_file_path = RasPlan.get_plan_path(plan_number, ras_obj)
        if not plan_file_path:
            raise FileNotFoundError(f"Plan file not found: {plan_number}")
        
        with open(plan_file_path, 'r') as f:
            lines = f.readlines()
        with open(plan_file_path, 'w') as f:
            for line in lines:
                if line.startswith("Flow File=f"):
                    f.write(f"Flow File=f{new_steady_flow_number}\n")
                    logging.info(f"Updated Flow File in {plan_file_path} to f{new_steady_flow_number}")
                else:
                    f.write(line)

        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()

    @staticmethod
    def set_unsteady(plan_number: str, new_unsteady_flow_number: str, ras_object=None):
        """
        Apply an unsteady flow file to a plan file.
        
        Parameters:
        plan_number (str): Plan number (e.g., '04')
        new_unsteady_flow_number (str): Unsteady flow number to apply (e.g., '01')
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
        
        Returns:
        None

        Raises:
        ValueError: If the specified unsteady number is not found in the project file
        FileNotFoundError: If the specified plan file is not found

        Example:
        >>> RasPlan.set_unsteady('04', '01')

        Note:
            This function updates the ras object's dataframes after modifying the project structure.
        """
        print(f"Setting unsteady flow file from {new_unsteady_flow_number} to {plan_number}")
        
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        # Update the unsteady dataframe in the ras instance to ensure it is current
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()
        
        if new_unsteady_flow_number not in ras_obj.unsteady_df['unsteady_number'].values:
            raise ValueError(f"Unsteady number {new_unsteady_flow_number} not found in project file.")
        
        # Get the full path of the plan file
        plan_file_path = RasPlan.get_plan_path(plan_number, ras_obj)
        if not plan_file_path:
            raise FileNotFoundError(f"Plan file not found: {plan_number}")
        
        
        # DEV NOTE: THIS WORKS HERE, BUT IN OTHER FUNCTIONS WE DO THIS MANUALLY.  
        # UPDATE OTHER FUNCTIONS TO USE RasUtils.update_plan_file INSTEAD OF REPLICATING THIS CODE.
        
        RasUtils.update_plan_file(plan_file_path, 'Unsteady', new_unsteady_flow_number)
        print(f"Updated unsteady flow file in {plan_file_path} to u{new_unsteady_flow_number}")

        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()

    @staticmethod
    def set_num_cores(plan_number, num_cores, ras_object=None):
        """
        Update the maximum number of cores to use in the HEC-RAS plan file.
        
        Parameters:
        plan_number (str): Plan number (e.g., '02') or full path to the plan file
        num_cores (int): Maximum number of cores to use
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
        
        Returns:
        None

        Notes on setting num_cores in HEC-RAS:
        The recommended setting for num_cores is 2 (most efficient) to 8 (most performant)
        More details in the HEC-Commander Repository Blog "Benchmarking is All You Need"
        https://github.com/billk-FM/HEC-Commander/blob/main/Blog/7._Benchmarking_Is_All_You_Need.md
        
        Microsoft Windows has a maximum of 64 cores that can be allocated to a single Ras.exe process. 

        Example:
        >>> # Using plan number
        >>> RasPlan.set_num_cores('02', 4)
        >>> # Using full path to plan file
        >>> RasPlan.set_num_cores('/path/to/project.p02', 4)

        Note:
            This function updates the ras object's dataframes after modifying the project structure.
        """
        print(f"Setting num_cores to {num_cores} in Plan {plan_number}")
        
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        # Determine if plan_number is a path or a plan number
        if Path(plan_number).is_file():
            plan_file_path = Path(plan_number)
            if not plan_file_path.exists():
                raise FileNotFoundError(f"Plan file not found: {plan_file_path}. Please provide a valid plan number or path.")
        else:
            # Update the plan dataframe in the ras instance to ensure it is current
            ras_obj.plan_df = ras_obj.get_prj_entries('Plan')
            
            # Get the full path of the plan file
            plan_file_path = RasPlan.get_plan_path(plan_number, ras_obj)
            if not plan_file_path:
                raise FileNotFoundError(f"Plan file not found: {plan_number}. Please provide a valid plan number or path.")
        
        cores_pattern = re.compile(r"(UNET D1 Cores= )\d+")
        with open(plan_file_path, 'r') as file:
            content = file.read()
        new_content = cores_pattern.sub(rf"\g<1>{num_cores}", content)
        with open(plan_file_path, 'w') as file:
            file.write(new_content)
        print(f"Updated {plan_file_path} with {num_cores} cores.")
        
        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()
        
        
    @staticmethod
    def set_geom_preprocessor(file_path, run_htab, use_ib_tables, ras_object=None):
        """
        Update the simulation plan file to modify the `Run HTab` and `UNET Use Existing IB Tables` settings.
        
        Parameters:
        file_path (str): Path to the simulation plan file (.p06 or similar) that you want to modify.
        run_htab (int): Value for the `Run HTab` setting:
            - `0` : Do not run the geometry preprocessor, use existing geometry tables.
            - `-1` : Run the geometry preprocessor, forcing a recomputation of the geometry tables.
        use_ib_tables (int): Value for the `UNET Use Existing IB Tables` setting:
            - `0` : Use existing interpolation/boundary (IB) tables without recomputing them.
            - `-1` : Do not use existing IB tables, force a recomputation.
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
        
        Returns:
        None

        Raises:
        ValueError: If `run_htab` or `use_ib_tables` are not integers or not within the accepted values (`0` or `-1`).
        FileNotFoundError: If the specified file does not exist.
        IOError: If there is an error reading or writing the file.

        Example:
        >>> RasPlan.set_geom_preprocessor('/path/to/project.p06', run_htab=-1, use_ib_tables=0)

        Note:
            This function updates the ras object's dataframes after modifying the project structure.
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        if run_htab not in [-1, 0]:
            raise ValueError("Invalid value for `Run HTab`. Expected `0` or `-1`.")
        if use_ib_tables not in [-1, 0]:
            raise ValueError("Invalid value for `UNET Use Existing IB Tables`. Expected `0` or `-1`.")
        try:
            print(f"Reading the file: {file_path}")
            with open(file_path, 'r') as file:
                lines = file.readlines()
            print("Updating the file with new settings...")
            updated_lines = []
            for line in lines:
                if line.lstrip().startswith("Run HTab="):
                    updated_line = f"Run HTab= {run_htab} \n"
                    updated_lines.append(updated_line)
                    print(f"Updated 'Run HTab' to {run_htab}")
                elif line.lstrip().startswith("UNET Use Existing IB Tables="):
                    updated_line = f"UNET Use Existing IB Tables= {use_ib_tables} \n"
                    updated_lines.append(updated_line)
                    print(f"Updated 'UNET Use Existing IB Tables' to {use_ib_tables}")
                else:
                    updated_lines.append(line)
            print(f"Writing the updated settings back to the file: {file_path}")
            with open(file_path, 'w') as file:
                file.writelines(updated_lines)
            print("File update completed successfully.")
        except FileNotFoundError:
            raise FileNotFoundError(f"The file '{file_path}' does not exist.")
        except IOError as e:
            raise IOError(f"An error occurred while reading or writing the file: {e}")

        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()

# Get Functions to retrieve file paths for plan, flow, unsteady, geometry and results files

    @staticmethod
    def get_results_path(plan_number: str, ras_object=None) -> Optional[str]:
        """
        Retrieve the results file path for a given HEC-RAS plan number.

        Args:
            plan_number (str): The HEC-RAS plan number for which to find the results path.
            ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.

        Returns:
            Optional[str]: The full path to the results file if found and the file exists, or None if not found.

        Raises:
            RuntimeError: If the project is not initialized.

        Example:
            >>> ras_plan = RasPlan()
            >>> results_path = ras_plan.get_results_path('01')
            >>> if results_path:
            ...     print(f"Results file found at: {results_path}")
            ... else:
            ...     print("Results file not found.")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        # Update the plan dataframe in the ras instance to ensure it is current
        ras_obj.plan_df = ras_obj.get_plan_entries()
        
        # Ensure plan_number is a string
        plan_number = str(plan_number)
        
        # Ensure plan_number is formatted as '01', '02', etc.
        plan_number = plan_number.zfill(2)
        
        # print the ras_obj.plan_df dataframe
        print("Plan DataFrame:")
        display(ras_obj.plan_df)
        
        plan_entry = ras_obj.plan_df[ras_obj.plan_df['plan_number'] == plan_number]
        if not plan_entry.empty:
            results_path = plan_entry['HDF_Results_Path'].iloc[0]
            if results_path:
                print(f"Results file for Plan number {plan_number} exists at: {results_path}")
                return results_path
            else:
                print(f"Results file for Plan number {plan_number} does not exist.")
                return None
        else:
            print(f"Plan number {plan_number} not found in the entries.")
            return None
        
    @staticmethod
    def get_plan_path(plan_number: str, ras_object=None) -> Optional[str]:
        """
        Return the full path for a given plan number.
        
        This method ensures that the latest plan entries are included by refreshing
        the plan dataframe before searching for the requested plan number.
        
        Args:
        plan_number (str): The plan number to search for.
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
        
        Returns:
        Optional[str]: The full path of the plan file if found, None otherwise.
        
        Raises:
        RuntimeError: If the project is not initialized.

        Example:
        >>> ras_plan = RasPlan()
        >>> plan_path = ras_plan.get_plan_path('01')
        >>> if plan_path:
        ...     print(f"Plan file found at: {plan_path}")
        ... else:
        ...     print("Plan file not found.")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        project_name = ras_obj.project_name
        
        # Use updated plan dataframe
        plan_df = ras_obj.get_plan_entries()
        
        plan_path = plan_df[plan_df['plan_number'] == plan_number]
        
        if not plan_path.empty:
            full_path = plan_path['full_path'].iloc[0]
            return full_path
        else:
            print(f"Plan number {plan_number} not found in the updated plan entries.")
            return None

    @staticmethod
    def get_flow_path(flow_number: str, ras_object=None) -> Optional[str]:
        """
        Return the full path for a given flow number.

        Args:
        flow_number (str): The flow number to search for.
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.

        Returns:
        Optional[str]: The full path of the flow file if found, None otherwise.

        Raises:
        RuntimeError: If the project is not initialized.

        Example:
        >>> ras_plan = RasPlan()
        >>> flow_path = ras_plan.get_flow_path('01')
        >>> if flow_path:
        ...     print(f"Flow file found at: {flow_path}")
        ... else:
        ...     print("Flow file not found.")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        # Use updated flow dataframe
        ras_obj.flow_df = ras_obj.get_prj_entries('Flow')
        
        flow_path = ras_obj.flow_df[ras_obj.flow_df['flow_number'] == flow_number]
        if not flow_path.empty:
            full_path = flow_path['full_path'].iloc[0]
            return full_path
        else:
            print(f"Flow number {flow_number} not found in the updated flow entries.")
            return None

    @staticmethod
    def get_unsteady_path(unsteady_number: str, ras_object=None) -> Optional[str]:
        """
        Return the full path for a given unsteady number.

        Args:
        unsteady_number (str): The unsteady number to search for.
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.

        Returns:
        Optional[str]: The full path of the unsteady file if found, None otherwise.

        Raises:
        RuntimeError: If the project is not initialized.

        Example:
        >>> ras_plan = RasPlan()
        >>> unsteady_path = ras_plan.get_unsteady_path('01')
        >>> if unsteady_path:
        ...     print(f"Unsteady file found at: {unsteady_path}")
        ... else:
        ...     print("Unsteady file not found.")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        # Use updated unsteady dataframe
        ras_obj.unsteady_df = ras_obj.get_prj_entries('Unsteady')
        
        unsteady_path = ras_obj.unsteady_df[ras_obj.unsteady_df['unsteady_number'] == unsteady_number]
        if not unsteady_path.empty:
            full_path = unsteady_path['full_path'].iloc[0]
            return full_path
        else:
            print(f"Unsteady number {unsteady_number} not found in the updated unsteady entries.")
            return None

    @staticmethod
    def get_geom_path(geom_number: str, ras_object=None) -> Optional[str]:
        """
        Return the full path for a given geometry number.

        Args:
        geom_number (str): The geometry number to search for.
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.

        Returns:
        Optional[str]: The full path of the geometry file if found, None otherwise.

        Raises:
        RuntimeError: If the project is not initialized.

        Example:
        >>> ras_plan = RasPlan()
        >>> geom_path = ras_plan.get_geom_path('01')
        >>> if geom_path:
        ...     print(f"Geometry file found at: {geom_path}")
        ... else:
        ...     print("Geometry file not found.")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        # Use updated geom dataframe
        ras_obj.geom_df = ras_obj.get_prj_entries('Geom')
        
        geom_path = ras_obj.geom_df[ras_obj.geom_df['geom_number'] == geom_number]
        if not geom_path.empty:
            full_path = geom_path['full_path'].iloc[0]
            return full_path
        else:
            print(f"Geometry number {geom_number} not found in the updated geometry entries.")
            return None
#  Clone Functions to copy unsteady, flow, and geometry files from templates
     
    @staticmethod
    def clone_plan(template_plan, new_plan_shortid=None, ras_object=None):
        """
        Create a new plan file based on a template and update the project file.
        
        Parameters:
        template_plan (str): Plan number to use as template (e.g., '01')
        new_plan_shortid (str, optional): New short identifier for the plan file
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
        
        Returns:
        str: New plan number
        
        Example:
        >>> ras_plan = RasPlan()
        >>> new_plan_number = ras_plan.clone_plan('01', new_plan_shortid='New Plan')
        >>> print(f"New plan created with number: {new_plan_number}")

        Note:
            This function updates the ras object's dataframes after modifying the project structure.
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()

        # Update plan entries without reinitializing the entire project
        ras_obj.plan_df = ras_obj.get_prj_entries('Plan')

        new_plan_num = RasPlan.get_next_number(ras_obj.plan_df['plan_number'])
        template_plan_path = ras_obj.project_folder / f"{ras_obj.project_name}.p{template_plan}"
        new_plan_path = ras_obj.project_folder / f"{ras_obj.project_name}.p{new_plan_num}"
        
        if not template_plan_path.exists():
            raise FileNotFoundError(f"Template plan file '{template_plan_path}' does not exist.")

        shutil.copy(template_plan_path, new_plan_path)
        print(f"Copied {template_plan_path} to {new_plan_path}")

        with open(new_plan_path, 'r') as f:
            plan_lines = f.readlines()

        shortid_pattern = re.compile(r'^Short Identifier=(.*)$', re.IGNORECASE)
        for i, line in enumerate(plan_lines):
            match = shortid_pattern.match(line.strip())
            if match:
                current_shortid = match.group(1)
                if new_plan_shortid is None:
                    new_shortid = (current_shortid + "_copy")[:24]
                else:
                    new_shortid = new_plan_shortid[:24]
                plan_lines[i] = f"Short Identifier={new_shortid}\n"
                break

        with open(new_plan_path, 'w') as f:
            f.writelines(plan_lines)

        print(f"Updated short identifier in {new_plan_path}")

        with open(ras_obj.prj_file, 'r') as f:
            lines = f.readlines()

        # Prepare the new Plan File entry line
        new_plan_line = f"Plan File=p{new_plan_num}\n"

        # Find the correct insertion point for the new Plan File entry
        plan_file_pattern = re.compile(r'^Plan File=p(\d+)', re.IGNORECASE)
        insertion_index = None
        for i, line in enumerate(lines):
            match = plan_file_pattern.match(line.strip())
            if match:
                current_number = int(match.group(1))
                if current_number < int(new_plan_num):
                    continue
                else:
                    insertion_index = i
                    break

        if insertion_index is not None:
            lines.insert(insertion_index, new_plan_line)
        else:
            # Try to insert after the last Plan File entry
            plan_indices = [i for i, line in enumerate(lines) if plan_file_pattern.match(line.strip())]
            if plan_indices:
                last_plan_index = plan_indices[-1]
                lines.insert(last_plan_index + 1, new_plan_line)
            else:
                # Append at the end if no Plan File entries exist
                lines.append(new_plan_line)

        # Write the updated lines back to the project file
        with open(ras_obj.prj_file, 'w') as f:
            f.writelines(lines)

        print(f"Updated {ras_obj.prj_file} with new plan p{new_plan_num}")
        new_plan = new_plan_num
        
        # Store the project folder path
        project_folder = ras_obj.project_folder

        # Re-initialize the ras global object
        ras_obj.initialize(project_folder, ras_obj.ras_exe_path)

        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()

        return new_plan


    @staticmethod
    def clone_unsteady(template_unsteady, ras_object=None):
        """
        Copy unsteady flow files from a template, find the next unsteady number,
        and update the project file accordingly.

        Parameters:
        template_unsteady (str): Unsteady flow number to be used as a template (e.g., '01')
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.

        Returns:
        str: New unsteady flow number (e.g., '03')

        Example:
        >>> ras_plan = RasPlan()
        >>> new_unsteady_num = ras_plan.clone_unsteady('01')
        >>> print(f"New unsteady flow file created: u{new_unsteady_num}")

        Note:
            This function updates the ras object's dataframes after modifying the project structure.
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()

        # Update unsteady entries without reinitializing the entire project
        ras_obj.unsteady_df = ras_obj.get_prj_entries('Unsteady')

        new_unsteady_num = RasPlan.get_next_number(ras_obj.unsteady_df['unsteady_number'])
        template_unsteady_path = ras_obj.project_folder / f"{ras_obj.project_name}.u{template_unsteady}"
        new_unsteady_path = ras_obj.project_folder / f"{ras_obj.project_name}.u{new_unsteady_num}"

        if not template_unsteady_path.exists():
            raise FileNotFoundError(f"Template unsteady file '{template_unsteady_path}' does not exist.")

        shutil.copy(template_unsteady_path, new_unsteady_path)
        print(f"Copied {template_unsteady_path} to {new_unsteady_path}")

        # Copy the corresponding .hdf file if it exists
        template_hdf_path = ras_obj.project_folder / f"{ras_obj.project_name}.u{template_unsteady}.hdf"
        new_hdf_path = ras_obj.project_folder / f"{ras_obj.project_name}.u{new_unsteady_num}.hdf"
        if template_hdf_path.exists():
            shutil.copy(template_hdf_path, new_hdf_path)
            print(f"Copied {template_hdf_path} to {new_hdf_path}")
        else:
            print(f"No corresponding .hdf file found for '{template_unsteady_path}'. Skipping '.hdf' copy.")

        with open(ras_obj.prj_file, 'r') as f:
            lines = f.readlines()

        # Prepare the new Unsteady Flow File entry line
        new_unsteady_line = f"Unsteady File=u{new_unsteady_num}\n"

        # Find the correct insertion point for the new Unsteady Flow File entry
        unsteady_file_pattern = re.compile(r'^Unsteady File=u(\d+)', re.IGNORECASE)
        insertion_index = None
        for i, line in enumerate(lines):
            match = unsteady_file_pattern.match(line.strip())
            if match:
                current_number = int(match.group(1))
                if current_number < int(new_unsteady_num):
                    continue
                else:
                    insertion_index = i
                    break

        if insertion_index is not None:
            lines.insert(insertion_index, new_unsteady_line)
        else:
            # Try to insert after the last Unsteady Flow File entry
            unsteady_indices = [i for i, line in enumerate(lines) if unsteady_file_pattern.match(line.strip())]
            if unsteady_indices:
                last_unsteady_index = unsteady_indices[-1]
                lines.insert(last_unsteady_index + 1, new_unsteady_line)
            else:
                # Append at the end if no Unsteady Flow File entries exist
                lines.append(new_unsteady_line)

        # Write the updated lines back to the project file
        with open(ras_obj.prj_file, 'w') as f:
            f.writelines(lines)

        print(f"Updated {ras_obj.prj_file} with new unsteady flow file u{new_unsteady_num}")
        new_unsteady = new_unsteady_num
        
        # Store the project folder path
        project_folder = ras_obj.project_folder
        hecras_path = ras_obj.ras_exe_path

        # Re-initialize the ras global object
        ras_obj.initialize(project_folder, hecras_path)
        
        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()
        
        return new_unsteady

    @staticmethod
    def clone_steady(template_flow, ras_object=None):
        """
        Copy steady flow files from a template, find the next flow number,
        and update the project file accordingly.
        
        Parameters:
        template_flow (str): Flow number to be used as a template (e.g., '01')
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
        
        Returns:
        str: New flow number (e.g., '03')

        Example:
        >>> ras_plan = RasPlan()
        >>> new_flow_num = ras_plan.clone_steady('01')
        >>> print(f"New steady flow file created: f{new_flow_num}")

        Note:
            This function updates the ras object's dataframes after modifying the project structure.
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()

        # Update flow entries without reinitializing the entire project
        ras_obj.flow_df = ras_obj.get_prj_entries('Flow')

        new_flow_num = RasPlan.get_next_number(ras_obj.flow_df['flow_number'])
        template_flow_path = ras_obj.project_folder / f"{ras_obj.project_name}.f{template_flow}"
        new_flow_path = ras_obj.project_folder / f"{ras_obj.project_name}.f{new_flow_num}"

        if not template_flow_path.exists():
            raise FileNotFoundError(f"Template steady flow file '{template_flow_path}' does not exist.")

        shutil.copy(template_flow_path, new_flow_path)
        print(f"Copied {template_flow_path} to {new_flow_path}")

        # Read the contents of the project file
        with open(ras_obj.prj_file, 'r') as f:
            lines = f.readlines()

        # Prepare the new Steady Flow File entry line
        new_flow_line = f"Flow File=f{new_flow_num}\n"

        # Find the correct insertion point for the new Steady Flow File entry
        flow_file_pattern = re.compile(r'^Flow File=f(\d+)', re.IGNORECASE)
        insertion_index = None
        for i, line in enumerate(lines):
            match = flow_file_pattern.match(line.strip())
            if match:
                current_number = int(match.group(1))
                if current_number < int(new_flow_num):
                    continue
                else:
                    insertion_index = i
                    break

        if insertion_index is not None:
            lines.insert(insertion_index, new_flow_line)
        else:
            # Try to insert after the last Steady Flow File entry
            flow_indices = [i for i, line in enumerate(lines) if flow_file_pattern.match(line.strip())]
            if flow_indices:
                last_flow_index = flow_indices[-1]
                lines.insert(last_flow_index + 1, new_flow_line)
            else:
                # Append at the end if no Steady Flow File entries exist
                lines.append(new_flow_line)

        # Write the updated lines back to the project file
        with open(ras_obj.prj_file, 'w') as f:
            f.writelines(lines)

        print(f"Updated {ras_obj.prj_file} with new steady flow file f{new_flow_num}")
        new_steady = new_flow_num
        
        # Store the project folder path
        project_folder = ras_obj.project_folder

        # Re-initialize the ras global object
        ras_obj.initialize(project_folder, ras_obj.ras_exe_path)
        
        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()
        
        return new_steady


    @staticmethod
    def clone_geom(template_geom, ras_object=None):
        """
        Copy geometry files from a template, find the next geometry number,
        and update the project file accordingly.
        
        Parameters:
        template_geom (str): Geometry number to be used as a template (e.g., '01')
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
        
        Returns:
        str: New geometry number (e.g., '03')

        Note:
            This function updates the ras object's dataframes after modifying the project structure.
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()

        # Update geometry entries without reinitializing the entire project
        ras_obj.geom_df = ras_obj.get_prj_entries('Geom')  # Call the correct function to get updated geometry entries
        print(f"Updated geometry entries:\n{ras_obj.geom_df}")

#  Clone Functions to copy unsteady, flow, and geometry files from templates
     
    @staticmethod
    def clone_plan(template_plan, new_plan_shortid=None, ras_object=None):
        """
        Create a new plan file based on a template and update the project file.
        
        Parameters:
        template_plan (str): Plan number to use as template (e.g., '01')
        new_plan_shortid (str, optional): New short identifier for the plan file
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
        
        Returns:
        str: New plan number
        
        Revision Notes:
        - Updated to insert new plan entry in the correct position
        - Improved error handling and logging
        - Updated to use get_prj_entries('Plan') for the latest entries
        - Added print statements for progress tracking

        Example:
        >>> ras_plan = RasPlan()
        >>> new_plan_number = ras_plan.clone_plan('01', new_plan_shortid='New Plan')
        >>> print(f"New plan created with number: {new_plan_number}")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()

        # Update plan entries without reinitializing the entire project
        ras_obj.plan_df = ras_obj.get_prj_entries('Plan')

        new_plan_num = RasPlan.get_next_number(ras_obj.plan_df['plan_number'])
        template_plan_path = ras_obj.project_folder / f"{ras_obj.project_name}.p{template_plan}"
        new_plan_path = ras_obj.project_folder / f"{ras_obj.project_name}.p{new_plan_num}"
        
        if not template_plan_path.exists():
            raise FileNotFoundError(f"Template plan file '{template_plan_path}' does not exist.")

        shutil.copy(template_plan_path, new_plan_path)
        print(f"Copied {template_plan_path} to {new_plan_path}")

        with open(new_plan_path, 'r') as f:
            plan_lines = f.readlines()

        shortid_pattern = re.compile(r'^Short Identifier=(.*)$', re.IGNORECASE)
        for i, line in enumerate(plan_lines):
            match = shortid_pattern.match(line.strip())
            if match:
                current_shortid = match.group(1)
                if new_plan_shortid is None:
                    new_shortid = (current_shortid + "_copy")[:24]
                else:
                    new_shortid = new_plan_shortid[:24]
                plan_lines[i] = f"Short Identifier={new_shortid}\n"
                break

        with open(new_plan_path, 'w') as f:
            f.writelines(plan_lines)

        print(f"Updated short identifier in {new_plan_path}")

        with open(ras_obj.prj_file, 'r') as f:
            lines = f.readlines()

        # Prepare the new Plan File entry line
        new_plan_line = f"Plan File=p{new_plan_num}\n"

        # Find the correct insertion point for the new Plan File entry
        plan_file_pattern = re.compile(r'^Plan File=p(\d+)', re.IGNORECASE)
        insertion_index = None
        for i, line in enumerate(lines):
            match = plan_file_pattern.match(line.strip())
            if match:
                current_number = int(match.group(1))
                if current_number < int(new_plan_num):
                    continue
                else:
                    insertion_index = i
                    break

        if insertion_index is not None:
            lines.insert(insertion_index, new_plan_line)
        else:
            # Try to insert after the last Plan File entry
            plan_indices = [i for i, line in enumerate(lines) if plan_file_pattern.match(line.strip())]
            if plan_indices:
                last_plan_index = plan_indices[-1]
                lines.insert(last_plan_index + 1, new_plan_line)
            else:
                # Append at the end if no Plan File entries exist
                lines.append(new_plan_line)

        # Write the updated lines back to the project file
        with open(ras_obj.prj_file, 'w') as f:
            f.writelines(lines)

        print(f"Updated {ras_obj.prj_file} with new plan p{new_plan_num}")
        new_plan = new_plan_num
        
        # Store the project folder path
        project_folder = ras_obj.project_folder

        # Re-initialize the ras global object
        ras_obj.initialize(project_folder, ras_obj.ras_exe_path)
        return new_plan


    @staticmethod
    def clone_unsteady(template_unsteady, ras_object=None):
        """
        Copy unsteady flow files from a template, find the next unsteady number,
        and update the project file accordingly.

        Parameters:
        template_unsteady (str): Unsteady flow number to be used as a template (e.g., '01')
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.

        Returns:
        str: New unsteady flow number (e.g., '03')

        Example:
        >>> ras_plan = RasPlan()
        >>> new_unsteady_num = ras_plan.clone_unsteady('01')
        >>> print(f"New unsteady flow file created: u{new_unsteady_num}")

        Revision Notes:
        - Updated to insert new unsteady flow entry in the correct position
        - Improved error handling and logging
        - Removed dst_folder parameter as it's not needed (using project folder)
        - Added handling for corresponding .hdf files
        - Updated to use get_prj_entries('Unsteady') for the latest entries
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()

        # Update unsteady entries without reinitializing the entire project
        ras_obj.unsteady_df = ras_obj.get_prj_entries('Unsteady')

        new_unsteady_num = RasPlan.get_next_number(ras_obj.unsteady_df['unsteady_number'])
        template_unsteady_path = ras_obj.project_folder / f"{ras_obj.project_name}.u{template_unsteady}"
        new_unsteady_path = ras_obj.project_folder / f"{ras_obj.project_name}.u{new_unsteady_num}"

        if not template_unsteady_path.exists():
            raise FileNotFoundError(f"Template unsteady file '{template_unsteady_path}' does not exist.")

        shutil.copy(template_unsteady_path, new_unsteady_path)
        print(f"Copied {template_unsteady_path} to {new_unsteady_path}")

        # Copy the corresponding .hdf file if it exists
        template_hdf_path = ras_obj.project_folder / f"{ras_obj.project_name}.u{template_unsteady}.hdf"
        new_hdf_path = ras_obj.project_folder / f"{ras_obj.project_name}.u{new_unsteady_num}.hdf"
        if template_hdf_path.exists():
            shutil.copy(template_hdf_path, new_hdf_path)
            print(f"Copied {template_hdf_path} to {new_hdf_path}")
        else:
            print(f"No corresponding .hdf file found for '{template_unsteady_path}'. Skipping '.hdf' copy.")

        with open(ras_obj.prj_file, 'r') as f:
            lines = f.readlines()

        # Prepare the new Unsteady Flow File entry line
        new_unsteady_line = f"Unsteady File=u{new_unsteady_num}\n"

        # Find the correct insertion point for the new Unsteady Flow File entry
        unsteady_file_pattern = re.compile(r'^Unsteady File=u(\d+)', re.IGNORECASE)
        insertion_index = None
        for i, line in enumerate(lines):
            match = unsteady_file_pattern.match(line.strip())
            if match:
                current_number = int(match.group(1))
                if current_number < int(new_unsteady_num):
                    continue
                else:
                    insertion_index = i
                    break

        if insertion_index is not None:
            lines.insert(insertion_index, new_unsteady_line)
        else:
            # Try to insert after the last Unsteady Flow File entry
            unsteady_indices = [i for i, line in enumerate(lines) if unsteady_file_pattern.match(line.strip())]
            if unsteady_indices:
                last_unsteady_index = unsteady_indices[-1]
                lines.insert(last_unsteady_index + 1, new_unsteady_line)
            else:
                # Append at the end if no Unsteady Flow File entries exist
                lines.append(new_unsteady_line)

        # Write the updated lines back to the project file
        with open(ras_obj.prj_file, 'w') as f:
            f.writelines(lines)

        print(f"Updated {ras_obj.prj_file} with new unsteady flow file u{new_unsteady_num}")
        new_unsteady = new_unsteady_num
        
        # Store the project folder path
        project_folder = ras_obj.project_folder
        hecras_path = ras_obj.ras_exe_path

        # Re-initialize the ras global object
        ras_obj.initialize(project_folder, hecras_path)
        
        return new_unsteady

    @staticmethod
    def clone_steady(template_flow, ras_object=None):
        """
        Copy steady flow files from a template, find the next flow number,
        and update the project file accordingly.
        
        Parameters:
        template_flow (str): Flow number to be used as a template (e.g., '01')
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
        
        Returns:
        str: New flow number (e.g., '03')

        Example:
        >>> ras_plan = RasPlan()
        >>> new_flow_num = ras_plan.clone_steady('01')
        >>> print(f"New steady flow file created: f{new_flow_num}")

        Revision Notes:
        - Updated to insert new steady flow entry in the correct position
        - Improved error handling and logging
        - Added handling for corresponding .hdf files
        - Updated to use get_prj_entries('Flow') for the latest entries
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()

        # Update flow entries without reinitializing the entire project
        ras_obj.flow_df = ras_obj.get_prj_entries('Flow')

        new_flow_num = RasPlan.get_next_number(ras_obj.flow_df['flow_number'])
        template_flow_path = ras_obj.project_folder / f"{ras_obj.project_name}.f{template_flow}"
        new_flow_path = ras_obj.project_folder / f"{ras_obj.project_name}.f{new_flow_num}"

        if not template_flow_path.exists():
            raise FileNotFoundError(f"Template steady flow file '{template_flow_path}' does not exist.")

        shutil.copy(template_flow_path, new_flow_path)
        print(f"Copied {template_flow_path} to {new_flow_path}")

        # Read the contents of the project file
        with open(ras_obj.prj_file, 'r') as f:
            lines = f.readlines()

        # Prepare the new Steady Flow File entry line
        new_flow_line = f"Flow File=f{new_flow_num}\n"

        # Find the correct insertion point for the new Steady Flow File entry
        flow_file_pattern = re.compile(r'^Flow File=f(\d+)', re.IGNORECASE)
        insertion_index = None
        for i, line in enumerate(lines):
            match = flow_file_pattern.match(line.strip())
            if match:
                current_number = int(match.group(1))
                if current_number < int(new_flow_num):
                    continue
                else:
                    insertion_index = i
                    break

        if insertion_index is not None:
            lines.insert(insertion_index, new_flow_line)
        else:
            # Try to insert after the last Steady Flow File entry
            flow_indices = [i for i, line in enumerate(lines) if flow_file_pattern.match(line.strip())]
            if flow_indices:
                last_flow_index = flow_indices[-1]
                lines.insert(last_flow_index + 1, new_flow_line)
            else:
                # Append at the end if no Steady Flow File entries exist
                lines.append(new_flow_line)

        # Write the updated lines back to the project file
        with open(ras_obj.prj_file, 'w') as f:
            f.writelines(lines)

        print(f"Updated {ras_obj.prj_file} with new steady flow file f{new_flow_num}")
        new_steady = new_flow_num
        
        # Store the project folder path
        project_folder = ras_obj.project_folder

        # Re-initialize the ras global object
        ras_obj.initialize(project_folder, ras_obj.ras_exe_path)
        
        return new_steady

    @staticmethod
    def clone_geom(template_geom, ras_object=None):
        """
        Copy geometry files from a template, find the next geometry number,
        and update the project file accordingly.
        
        Parameters:
        template_geom (str): Geometry number to be used as a template (e.g., '01')
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
        
        Returns:
        str: New geometry number (e.g., '03')

        Note:
            This function updates the ras object's dataframes after modifying the project structure.
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()

        # Update geometry entries without reinitializing the entire project
        ras_obj.geom_df = ras_obj.get_prj_entries('Geom')

        template_geom_filename = f"{ras_obj.project_name}.g{template_geom}"
        template_geom_path = ras_obj.project_folder / template_geom_filename

        if not template_geom_path.is_file():
            raise FileNotFoundError(f"Template geometry file '{template_geom_path}' does not exist.")

        next_geom_number = RasPlan.get_next_number(ras_obj.geom_df['geom_number'])

        new_geom_filename = f"{ras_obj.project_name}.g{next_geom_number}"
        new_geom_path = ras_obj.project_folder / new_geom_filename

        shutil.copyfile(template_geom_path, new_geom_path)
        print(f"Copied '{template_geom_path}' to '{new_geom_path}'.")

        # Handle HDF file copy
        template_hdf_path = template_geom_path.with_suffix('.g' + template_geom + '.hdf')
        new_hdf_path = new_geom_path.with_suffix('.g' + next_geom_number + '.hdf')
        if template_hdf_path.is_file():
            shutil.copyfile(template_hdf_path, new_hdf_path)
            print(f"Copied '{template_hdf_path}' to '{new_hdf_path}'.")
        else:
            print(f"Warning: Template geometry HDF file '{template_hdf_path}' does not exist. This is common, and not critical. Continuing without it.")

        with open(ras_obj.prj_file, 'r') as file:
            lines = file.readlines()

        # Prepare the new Geometry File entry line
        new_geom_line = f"Geom File=g{next_geom_number}\n"

        # Find the correct insertion point for the new Geometry File entry
        geom_file_pattern = re.compile(r'^Geom File=g(\d+)', re.IGNORECASE)
        insertion_index = None
        for i, line in enumerate(lines):
            match = geom_file_pattern.match(line.strip())
            if match:
                current_number = int(match.group(1))
                if current_number < int(next_geom_number):
                    continue
                else:
                    insertion_index = i
                    break

        if insertion_index is not None:
            lines.insert(insertion_index, new_geom_line)
        else:
            # Try to insert after the last Geometry File entry
            geom_indices = [i for i, line in enumerate(lines) if geom_file_pattern.match(line.strip())]
            if geom_indices:
                last_geom_index = geom_indices[-1]
                lines.insert(last_geom_index + 1, new_geom_line)
            else:
                # Append at the end if no Geometry File entries exist
                lines.append(new_geom_line)

        # Write the updated lines back to the project file
        with open(ras_obj.prj_file, 'w') as file:
            file.writelines(lines)

        print(f"Updated {ras_obj.prj_file} with new geometry file g{next_geom_number}")
        new_geom = next_geom_number
        
        # Update all dataframes in the ras object
        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()

        print(f"Updated geometry entries:\n{ras_obj.geom_df}")

        return new_geom
            
            
        
        
    @staticmethod
    def get_next_number(existing_numbers):
        """
        Determine the next available number from a list of existing numbers.
        
        Parameters:
        existing_numbers (list): List of existing numbers as strings
        
        Returns:
        str: Next available number as a zero-padded string
        
        Example:
        >>> existing_numbers = ['01', '02', '04']
        >>> RasPlan.get_next_number(existing_numbers)
        '03'
        >>> existing_numbers = ['01', '02', '03']
        >>> RasPlan.get_next_number(existing_numbers)
        '04'
        """
        existing_numbers = sorted(int(num) for num in existing_numbers)
        next_number = 1
        for num in existing_numbers:
            if num == next_number:
                next_number += 1
            else:
                break
        return f"{next_number:02d}"

==================================================

File: c:\GH\ras-commander\ras_commander\RasPrj.py
==================================================
"""RasPrj.py

This module provides a class for managing HEC-RAS projects.

Classes:
    RasPrj: A class for managing HEC-RAS projects.

Functions:
    init_ras_project: Initialize a RAS project.
    get_ras_exe: Determine the HEC-RAS executable path based on the input.

DEVELOPER NOTE:
This class is used to initialize a RAS project and is used in conjunction with the RasCmdr class to manage the execution of RAS plans.
By default, the RasPrj class is initialized with the global 'ras' object.
However, you can create multiple RasPrj instances to manage multiple projects.
Do not mix and match global 'ras' object instances and custom instances of RasPrj - it will cause errors.
"""
# Example Terminal Output for RasPrj Functions:
# print(f"\n----- INSERT TEXT HERE -----\n")

from pathlib import Path
import pandas as pd
import re

class RasPrj:
    def __init__(self):
        self.initialized = False

    def initialize(self, project_folder, ras_exe_path):
        """
        Initialize a RasPrj instance.

        This method sets up the RasPrj instance with the given project folder and RAS executable path.
        It finds the project file, loads project data, and sets the initialization flag.

        Args:
            project_folder (str or Path): Path to the HEC-RAS project folder.
            ras_exe_path (str or Path): Path to the HEC-RAS executable.

        Raises:
            ValueError: If no HEC-RAS project file is found in the specified folder.

        Note:
            This method is intended for internal use. External users should use the init_ras_project function instead.
        """
        self.project_folder = Path(project_folder)
        self.prj_file = self.find_ras_prj(self.project_folder)
        if self.prj_file is None:
            raise ValueError(f"No HEC-RAS project file found in {self.project_folder}")
        self.project_name = Path(self.prj_file).stem
        self.ras_exe_path = ras_exe_path
        self._load_project_data()
        self.initialized = True
        print(f"\n-----Initialization complete for project: {self.project_name}-----")
        print(f"Plan entries: {len(self.plan_df)}, Flow entries: {len(self.flow_df)}, Unsteady entries: {len(self.unsteady_df)}, Geometry entries: {len(self.geom_df)}\n")

    def _load_project_data(self):
        """
        Load project data from the HEC-RAS project file.

        This method initializes DataFrames for plan, flow, unsteady, and geometry entries
        by calling the _get_prj_entries method for each entry type.
        """
        # Initialize DataFrames
        self.plan_df = self._get_prj_entries('Plan')
        self.flow_df = self._get_prj_entries('Flow')
        self.unsteady_df = self._get_prj_entries('Unsteady')
        self.geom_df = self._get_prj_entries('Geom')

    def _get_prj_entries(self, entry_type):
        """
        Extract entries of a specific type from the HEC-RAS project file.

        Args:
            entry_type (str): The type of entry to extract (e.g., 'Plan', 'Flow', 'Unsteady', 'Geom').

        Returns:
            pd.DataFrame: A DataFrame containing the extracted entries.

        Note:
            This method reads the project file and extracts entries matching the specified type.
            For 'Plan' entries, it also checks for the existence of HDF results files.
        """
        # Initialize an empty list to store entries
        entries = []
        # Create a regex pattern to match the specific entry type
        pattern = re.compile(rf"{entry_type} File=(\w+)")

        # Open and read the project file
        with open(self.prj_file, 'r') as file:
            for line in file:
                # Check if the line matches the pattern
                match = pattern.match(line.strip())
                if match:
                    # Extract the file name from the matched pattern
                    file_name = match.group(1)
                    # Create a dictionary for the current entry
                    entry = {
                        f'{entry_type.lower()}_number': file_name[1:],
                        'full_path': str(self.project_folder / f"{self.project_name}.{file_name}")
                    }

                    # Special handling for Plan entries
                    if entry_type == 'Plan':
                        # Construct the path for the HDF results file
                        hdf_results_path = self.project_folder / f"{self.project_name}.p{file_name[1:]}.hdf"
                        # Add the results_path to the entry, if the file exists
                        entry['HDF_Results_Path'] = str(hdf_results_path) if hdf_results_path.exists() else None

                    # Add the entry to the list
                    entries.append(entry)

        # Convert the list of entries to a DataFrame and return it
        return pd.DataFrame(entries)

    @property
    def is_initialized(self):
        """
        Check if the RasPrj instance has been initialized.

        Returns:
            bool: True if the instance has been initialized, False otherwise.
        """
        return self.initialized

    def check_initialized(self):
        """
        Ensure that the RasPrj instance has been initialized.

        Raises:
            RuntimeError: If the project has not been initialized.
        """
        if not self.initialized:
            raise RuntimeError("Project not initialized. Call init_ras_project() first.")

    @staticmethod
    def find_ras_prj(folder_path):
        """
        Find the appropriate HEC-RAS project file (.prj) in the given folder.
        
        Parameters:
        folder_path (str or Path): Path to the folder containing HEC-RAS files.
        
        Returns:
        Path: The full path of the selected .prj file or None if no suitable file is found.
        """
        folder_path = Path(folder_path)
        prj_files = list(folder_path.glob("*.prj"))
        rasmap_files = list(folder_path.glob("*.rasmap"))
        if len(prj_files) == 1:
            return prj_files[0].resolve()
        if len(prj_files) > 1:
            if len(rasmap_files) == 1:
                base_filename = rasmap_files[0].stem
                prj_file = folder_path / f"{base_filename}.prj"
                return prj_file.resolve()
            for prj_file in prj_files:
                with open(prj_file, 'r') as file:
                    if "Proj Title=" in file.read():
                        return prj_file.resolve()
        print("No suitable .prj file found after all checks.")
        return None

    def get_project_name(self):
        """
        Get the name of the HEC-RAS project.

        Returns:
            str: The name of the project.

        Raises:
            RuntimeError: If the project has not been initialized.
        """
        self.check_initialized()
        return self.project_name

    def get_prj_entries(self, entry_type):
        """
        Get entries of a specific type from the HEC-RAS project.

        Args:
            entry_type (str): The type of entry to retrieve (e.g., 'Plan', 'Flow', 'Unsteady', 'Geom').

        Returns:
            pd.DataFrame: A DataFrame containing the requested entries.

        Raises:
            RuntimeError: If the project has not been initialized.
        """
        self.check_initialized()
        return self._get_prj_entries(entry_type)

    def get_plan_entries(self):
        """
        Get all plan entries from the HEC-RAS project.

        Returns:
            pd.DataFrame: A DataFrame containing all plan entries.

        Raises:
            RuntimeError: If the project has not been initialized.
        """
        self.check_initialized()
        return self._get_prj_entries('Plan')

    def get_flow_entries(self):
        """
        Get all flow entries from the HEC-RAS project.

        Returns:
            pd.DataFrame: A DataFrame containing all flow entries.

        Raises:
            RuntimeError: If the project has not been initialized.
        """
        self.check_initialized()
        return self._get_prj_entries('Flow')

    def get_unsteady_entries(self):
        """
        Get all unsteady flow entries from the HEC-RAS project.

        Returns:
            pd.DataFrame: A DataFrame containing all unsteady flow entries.

        Raises:
            RuntimeError: If the project has not been initialized.
        """
        self.check_initialized()
        return self._get_prj_entries('Unsteady')

    def get_geom_entries(self):
        """
        Get all geometry entries from the HEC-RAS project.

        Returns:
            pd.DataFrame: A DataFrame containing all geometry entries.

        Raises:
            RuntimeError: If the project has not been initialized.
        """
        self.check_initialized()
        return self._get_prj_entries('Geom')
    
    def get_hdf_entries(self):
        """
        Get HDF entries for plans that have results.
        
        Returns:
        pd.DataFrame: A DataFrame containing plan entries with HDF results.
                  Returns an empty DataFrame if no HDF entries are found.
        """
        self.check_initialized()
        
        # Filter the plan_df to include only entries with existing HDF results
        hdf_entries = self.plan_df[self.plan_df['HDF_Results_Path'].notna()].copy()
        
        # If no HDF entries are found, return an empty DataFrame with the correct columns
        if hdf_entries.empty:
            return pd.DataFrame(columns=self.plan_df.columns)
        
        return hdf_entries
    
    def print_data(self):
        """Print all RAS Object data for this instance.
           If any objects are added, add them to the print statements below."""
        print(f"\n--- Data for {self.project_name} ---")
        print(f"Project folder: {self.project_folder}")
        print(f"PRJ file: {self.prj_file}")
        print(f"HEC-RAS executable: {self.ras_exe_path}")
        print("\nPlan files:")
        print(self.plan_df)
        print("\nFlow files:")
        print(self.flow_df)
        print("\nUnsteady flow files:")
        print(self.unsteady_df)
        print("\nGeometry files:")
        print(self.geom_df)
        print("\nHDF entries:")
        print(self.get_hdf_entries())
        print("----------------------------\n")


# Create a global instance named 'ras'
ras = RasPrj()

def init_ras_project(ras_project_folder, ras_version, ras_instance=None):
    """
    Initialize a RAS project.

    USE THIS FUNCTION TO INITIALIZE A RAS PROJECT, NOT THE INITIALIZE METHOD OF THE RasPrj CLASS.
    The initialize method of the RasPrj class only modifies the global 'ras' object.

    This function creates or initializes a RasPrj instance, providing a safer and more
    flexible interface than directly using the 'initialize' method.

    Parameters:
    -----------
    ras_project_folder : str
        The path to the RAS project folder.
    ras_version : str
        The version of RAS to use (e.g., "6.5").
        The version can also be a full path to the Ras.exe file. (Useful when calling ras objects for folder copies.)
    ras_instance : RasPrj, optional
        An instance of RasPrj to initialize. If None, the global 'ras' instance is used.

    Returns:
    --------
    RasPrj
        An initialized RasPrj instance.

    Usage:
    ------
    1. For general use with a single project:
        init_ras_project("/path/to/project", "6.5")
        # Use the global 'ras' object after initialization

    2. For managing multiple projects:
        project1 = init_ras_project("/path/to/project1", "6.5", ras_instance=RasPrj())
        project2 = init_ras_project("/path/to/project2", "6.5", ras_instance=RasPrj())

    Notes:
    ------
    - This function is preferred over directly calling the 'initialize' method.
    - It supports both the global 'ras' object and custom instances.
    - Be consistent in your approach: stick to either the global 'ras' object
      or custom instances throughout your script or application.
    - Document your choice of approach clearly in your code.

    Warnings:
    ---------
    Avoid mixing use of the global 'ras' object and custom instances to prevent
    confusion and potential bugs.
    """

    if not Path(ras_project_folder).exists():
        raise FileNotFoundError(f"The specified RAS project folder does not exist: {ras_project_folder}. Please check the path and try again.")

    ras_exe_path = get_ras_exe(ras_version)

    if ras_instance is None:
        print(f"\n-----Initializing global 'ras' object via init_ras_project function-----")
        ras_instance = ras
    elif not isinstance(ras_instance, RasPrj):
        print(f"\n-----Initializing custom RasPrj instance via init_ras_project function-----")
        raise TypeError("ras_instance must be an instance of RasPrj or None.")

    # Initialize the RasPrj instance
    ras_instance.initialize(ras_project_folder, ras_exe_path)

    #print(f"\n-----HEC-RAS project initialized via init_ras_project function: {ras_instance.project_name}-----\n")
    return ras_instance


def get_ras_exe(ras_version):
    """
    Determine the HEC-RAS executable path based on the input.
    
    Args:
    ras_version (str): Either a version number or a full path to the HEC-RAS executable.
    
    Returns:
    str: The full path to the HEC-RAS executable.
    
    Raises:
    ValueError: If the input is neither a valid version number nor a valid file path.
    FileNotFoundError: If the executable file does not exist at the specified or constructed path.
    """
    ras_version_numbers = [
        "6.5", "6.4.1", "6.3.1", "6.3", "6.2", "6.1", "6.0",
        "5.0.7", "5.0.6", "5.0.5", "5.0.4", "5.0.3", "5.0.1", "5.0",
        "4.1", "4.0", "3.1.3", "3.1.2", "3.1.1", "3.0", "2.2"
    ]
    
    hecras_path = Path(ras_version)
    
    if hecras_path.is_file() and hecras_path.suffix.lower() == '.exe':
        return str(hecras_path)
    
    if ras_version in ras_version_numbers:
        default_path = Path(f"C:/Program Files (x86)/HEC/HEC-RAS/{ras_version}/Ras.exe")
        if default_path.is_file():
            return str(default_path)
        else:
            raise FileNotFoundError(f"HEC-RAS executable not found at the expected path: {default_path}")
    
    try:
        version_float = float(ras_version)
        if version_float > max(float(v) for v in ras_version_numbers):
            newer_version_path = Path(f"C:/Program Files (x86)/HEC/HEC-RAS/{ras_version}/Ras.exe")
            if newer_version_path.is_file():
                return str(newer_version_path)
            else:
                raise FileNotFoundError(f"Newer version of HEC-RAS was specified. Check the version number or pass the full Ras.exe path as the function argument instead of the version number. The script looked for the executable at: {newer_version_path}")
    except ValueError:
        pass
    
    raise ValueError(f"Invalid HEC-RAS version or path: {ras_version}. "
                     f"Please provide a valid version number from {ras_version_numbers} "
                     "or a full path to the HEC-RAS executable.")
==================================================

File: c:\GH\ras-commander\ras_commander\RasUnsteady.py
==================================================
"""
Operations for handling unsteady flow files in HEC-RAS projects.
"""
from pathlib import Path
from .RasPrj import ras
import re

class RasUnsteady:
    """
    Class for all operations related to HEC-RAS unsteady flow files.
    """
    
    @staticmethod
    def update_unsteady_parameters(unsteady_file, modifications, ras_object=None):
        """
        Modify parameters in an unsteady flow file.
        
        Parameters:
        unsteady_file (str): Full path to the unsteady flow file
        modifications (dict): Dictionary of modifications to apply, where keys are parameter names and values are new values
        ras_object (RasPrj, optional): Specific RAS object to use. If None, uses the global ras instance.
        
        Returns:
        None

        Note:
            This function updates the ras object's unsteady dataframe after modifying the unsteady flow file.
        
        Example:
            from ras_commander import RasCmdr
            
            # Initialize RAS project
            ras_cmdr = RasCmdr()
            ras_cmdr.init_ras_project(project_folder, ras_version)
            
            # Update unsteady parameters
            unsteady_file = r"path/to/unsteady_file.u01"
            modifications = {"Parameter1": "NewValue1", "Parameter2": "NewValue2"}
            RasUnsteady.update_unsteady_parameters(unsteady_file, modifications, ras_object=ras_cmdr.ras)
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()
        
        unsteady_path = Path(unsteady_file)
        try:
            with open(unsteady_path, 'r') as f:
                lines = f.readlines()
        except FileNotFoundError:
            raise FileNotFoundError(f"Unsteady flow file not found: {unsteady_path}")
        except PermissionError:
            raise PermissionError(f"Permission denied when reading unsteady flow file: {unsteady_path}")
        
        updated = False
        for i, line in enumerate(lines):
            for param, new_value in modifications.items():
                if line.startswith(f"{param}="):
                    lines[i] = f"{param}={new_value}\n"
                    updated = True
                    print(f"Updated {param} to {new_value}")
        if updated:
            try:
                with open(unsteady_path, 'w') as f:
                    f.writelines(lines)
            except PermissionError:
                raise PermissionError(f"Permission denied when writing to unsteady flow file: {unsteady_path}")
            except IOError as e:
                raise IOError(f"Error writing to unsteady flow file: {unsteady_path}. {str(e)}")
            print(f"Applied modifications to {unsteady_file}")
        else:
            print(f"No matching parameters found in {unsteady_file}")

        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()

==================================================

File: c:\GH\ras-commander\ras_commander\RasUtils.py
==================================================
"""
Utility functions for the ras-commander library.
"""
import os
import shutil
import logging
import time
from pathlib import Path
from .RasPrj import ras
from typing import Union

class RasUtils:
    """
    A class containing utility functions for the ras-commander library.
    When integrating new functions that do not clearly fit into other classes, add them here.
    """

    @staticmethod
    def create_backup(file_path: Path, backup_suffix: str = "_backup", ras_object=None) -> Path:
        """
        Create a backup of the specified file.

        Parameters:
        file_path (Path): Path to the file to be backed up
        backup_suffix (str): Suffix to append to the backup file name
        ras_object (RasPrj, optional): RAS object to use. If None, uses the default ras object.

        Returns:
        Path: Path to the created backup file

        Example:
        >>> backup_path = RasUtils.create_backup(Path("project.prj"))
        >>> print(f"Backup created at: {backup_path}")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        original_path = Path(file_path)
        backup_path = original_path.with_name(f"{original_path.stem}{backup_suffix}{original_path.suffix}")
        shutil.copy2(original_path, backup_path)
        logging.info(f"Backup created: {backup_path}")
        return backup_path

    @staticmethod
    def restore_from_backup(backup_path: Path, remove_backup: bool = True, ras_object=None) -> Path:
        """
        Restore a file from its backup.

        Parameters:
        backup_path (Path): Path to the backup file
        remove_backup (bool): Whether to remove the backup file after restoration
        ras_object (RasPrj, optional): RAS object to use. If None, uses the default ras object.

        Returns:
        Path: Path to the restored file

        Example:
        >>> restored_path = RasUtils.restore_from_backup(Path("project_backup.prj"))
        >>> print(f"File restored to: {restored_path}")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        backup_path = Path(backup_path)
        original_path = backup_path.with_name(backup_path.stem.rsplit('_backup', 1)[0] + backup_path.suffix)
        shutil.copy2(backup_path, original_path)
        logging.info(f"File restored: {original_path}")
        if remove_backup:
            backup_path.unlink()
            logging.info(f"Backup removed: {backup_path}")
        return original_path

    @staticmethod
    def create_directory(directory_path: Path, ras_object=None) -> Path:
        """
        Ensure that a directory exists, creating it if necessary.

        Parameters:
        directory_path (Path): Path to the directory
        ras_object (RasPrj, optional): RAS object to use. If None, uses the default ras object.

        Returns:
        Path: Path to the ensured directory

        Example:
        >>> ensured_dir = RasUtils.create_directory(Path("output"))
        >>> print(f"Directory ensured: {ensured_dir}")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        path = Path(directory_path)
        path.mkdir(parents=True, exist_ok=True)
        logging.info(f"Directory ensured: {path}")
        return path

    @staticmethod
    def find_files_by_extension(extension: str, ras_object=None) -> list:
        """
        List all files in the project directory with a specific extension.

        Parameters:
        extension (str): File extension to filter (e.g., '.prj')
        ras_object (RasPrj, optional): RAS object to use. If None, uses the default ras object.

        Returns:
        list: List of file paths matching the extension

        Example:
        >>> prj_files = RasUtils.find_files_by_extension('.prj')
        >>> print(f"Found {len(prj_files)} .prj files")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        files = list(ras_obj.project_folder.glob(f"*{extension}"))
        return [str(file) for file in files]

    @staticmethod
    def get_file_size(file_path: Path, ras_object=None) -> int:
        """
        Get the size of a file in bytes.

        Parameters:
        file_path (Path): Path to the file
        ras_object (RasPrj, optional): RAS object to use. If None, uses the default ras object.

        Returns:
        int: Size of the file in bytes

        Example:
        >>> size = RasUtils.get_file_size(Path("project.prj"))
        >>> print(f"File size: {size} bytes")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        path = Path(file_path)
        if path.exists():
            return path.stat().st_size
        else:
            logging.warning(f"File not found: {path}")
            return None

    @staticmethod
    def get_file_modification_time(file_path: Path, ras_object=None) -> float:
        """
        Get the last modification time of a file.

        Parameters:
        file_path (Path): Path to the file
        ras_object (RasPrj, optional): RAS object to use. If None, uses the default ras object.

        Returns:
        float: Last modification time as a timestamp

        Example:
        >>> mtime = RasUtils.get_file_modification_time(Path("project.prj"))
        >>> print(f"Last modified: {mtime}")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        path = Path(file_path)
        if path.exists():
            return path.stat().st_mtime
        else:
            logging.warning(f"File not found: {path}")
            return None

    @staticmethod
    def get_plan_path(current_plan_number_or_path: Union[str, Path], ras_object=None) -> Path:
        """
        Get the path for a plan file with a given plan number or path.

        Parameters:
        current_plan_number_or_path (Union[str, Path]): The plan number (1 to 99) or full path to the plan file
        ras_object (RasPrj, optional): RAS object to use. If None, uses the default ras object.

        Returns:
        Path: Full path to the plan file

        Example:
        >>> plan_path = RasUtils.get_plan_path(1)
        >>> print(f"Plan file path: {plan_path}")
        >>> plan_path = RasUtils.get_plan_path("path/to/plan.p01")
        >>> print(f"Plan file path: {plan_path}")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        plan_path = Path(current_plan_number_or_path)
        if plan_path.is_file():
            return plan_path
        
        try:
            current_plan_number = f"{int(current_plan_number_or_path):02d}"  # Ensure two-digit format
        except ValueError:
            raise ValueError(f"Invalid plan number: {current_plan_number_or_path}. Expected a number from 1 to 99.")
        
        plan_name = f"{ras_obj.project_name}.p{current_plan_number}"
        return ras_obj.project_folder / plan_name

    @staticmethod
    def remove_with_retry(path: Path, max_attempts: int = 5, initial_delay: float = 1.0, is_folder: bool = True, ras_object=None) -> bool:
        """
        Attempts to remove a file or folder with retry logic and exponential backoff.

        Parameters:
        path (Path): Path to the file or folder to be removed.
        max_attempts (int): Maximum number of removal attempts.
        initial_delay (float): Initial delay between attempts in seconds.
        is_folder (bool): If True, the path is treated as a folder; if False, it's treated as a file.
        ras_object (RasPrj, optional): RAS object to use. If None, uses the default ras object.

        Returns:
        bool: True if the file or folder was successfully removed, False otherwise.

        Example:
        >>> success = RasUtils.remove_with_retry(Path("temp_folder"), is_folder=True)
        >>> print(f"Removal successful: {success}")
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()

        path = Path(path)
        for attempt in range(max_attempts):
            try:
                if path.exists():
                    if is_folder:
                        shutil.rmtree(path)
                    else:
                        path.unlink()
                return True
            except PermissionError:
                if attempt < max_attempts - 1:
                    delay = initial_delay * (2 ** attempt)  # Exponential backoff
                    logging.warning(f"Failed to remove {path}. Retrying in {delay} seconds...")
                    time.sleep(delay)
                else:
                    logging.error(f"Failed to remove {path} after {max_attempts} attempts. Skipping.")
                    return False
        return False

    @staticmethod
    def update_plan_file(plan_number_or_path: Union[str, Path], file_type: str, entry_number: int, ras_object=None) -> None:
        """
        Update a plan file with a new file reference.

        Parameters:
        plan_number_or_path (Union[str, Path]): The plan number (1 to 99) or full path to the plan file
        file_type (str): Type of file to update ('Geom', 'Flow', or 'Unsteady')
        entry_number (int): Number (from 1 to 99) to set
        ras_object (RasPrj, optional): RAS object to use. If None, uses the default ras object.

        Raises:
        ValueError: If an invalid file_type is provided
        FileNotFoundError: If the plan file doesn't exist

        Example:
        >>> RasUtils.update_plan_file(1, "Geom", 2)
        >>> RasUtils.update_plan_file("path/to/plan.p01", "Geom", 2)
        """
        ras_obj = ras_object or ras
        ras_obj.check_initialized()
        
        valid_file_types = {'Geom': 'g', 'Flow': 'f', 'Unsteady': 'u'}
        if file_type not in valid_file_types:
            raise ValueError(f"Invalid file_type. Expected one of: {', '.join(valid_file_types.keys())}")

        plan_file_path = Path(plan_number_or_path)
        if not plan_file_path.is_file():
            plan_file_path = RasUtils.get_plan_path(plan_number_or_path, ras_object)
        
        if not plan_file_path.exists():
            raise FileNotFoundError(f"Plan file not found: {plan_file_path}")

        file_prefix = valid_file_types[file_type]
        search_pattern = f"{file_type} File="
        entry_number = f"{int(entry_number):02d}"  # Ensure two-digit format

        RasUtils.check_file_access(plan_file_path, 'r')
        with open(plan_file_path, 'r') as file:
            lines = file.readlines()

        for i, line in enumerate(lines):
            if line.startswith(search_pattern):
                lines[i] = f"{search_pattern}{file_prefix}{entry_number}\n"
                logging.info(f"Updated {file_type} File in {plan_file_path} to {file_prefix}{entry_number}")
                break

        with plan_file_path.open('w') as file:
            file.writelines(lines)

        logging.info(f"Successfully updated plan file: {plan_file_path}")
        ras_obj.plan_df = ras_obj.get_plan_entries()
        ras_obj.geom_df = ras_obj.get_geom_entries()
        ras_obj.flow_df = ras_obj.get_flow_entries()
        ras_obj.unsteady_df = ras_obj.get_unsteady_entries()

    @staticmethod
    def check_file_access(file_path, mode='r'):
        path = Path(file_path)
        if not path.exists():
            raise FileNotFoundError(f"File not found: {file_path}")
        if mode in ('r', 'rb') and not os.access(path, os.R_OK):
            raise PermissionError(f"Read permission denied for file: {file_path}")
        if mode in ('w', 'wb', 'a', 'ab') and not os.access(path.parent, os.W_OK):
            raise PermissionError(f"Write permission denied for directory: {path.parent}")


==================================================

File: c:\GH\ras-commander\ras_commander\RasUtils.zip
==================================================
PK    |2YlG       __init__.py}SN@zQR OZcL<C.dw
4rb{3{k0uYVF1D^T6NB!MBw&OQ"*^4}'-H0'0.}9sYYKQx(#h$IpKK&O/a{*Y$`+oT	ZK9r@_~WucQJ&_(uK>#Bu{P" ?>?9?6?c3ceE=&,MnV660?5NCo}_:5g();YI`wHPK    2Y?_       _version.pymQK0P04e#tmZmRloVy	{2BTJ.N-aJUh3%{eu}p%!SjUa|cxO>H0D;V5S#d	nlvKe9v`@a]]4S/Y0_I5cmZ #ti^@hHr~|FrYNCo?9N_>x!]cPK    D2Y|  V  
   RasCmdr.py<ko?4"q$`p^g loN F3Mq3=#J_U1xzwU&y1Uv	j;MS57~|j3 ][p!/~/Mc0/&!SpV	y9azj~ wZlU3!+\TVV`X%	U= |`c\rb{bLzlg0_5p~bu]]3~7ECVC?t@yhZ,K\{{^* \\t_.s&auU'K9:o4 yoyQ8o>8LWn~lA^iOAz?|$=$W_9cujA=?Z-9yJj]^>c2v;`)rFwUS;z0AT._1|Xp0V$Cln6Mk2rVf[u\6DZ!u;98Tf-/* n Jngu9.ozdUZgP~7];4X!P %u8iSd3&ci3OoZRn-riA@J4Y9S07EU9D 
h:8Kkyq "Gx`23>qXdTHJ# OC9.ECbHKn M0qsY)D-@VmM .rNjUj5ohrQ|SYK)Qi13 )i;&z);iV?Q4.x)w/m9ASW]/uw^+!Cf]CP&7
2c,	]/p)z`c5J+T>6%K)mazHaWMQ[p[@"|8X:<KD+3;29dt8keSBd^:;M6go&3F%PbR\*:tk g7JHb1J 5=;pwAdkTD,L[&!#S&EBKNnFl6#p83"D-~IjoT0 lzy5'8h(xH0U|uOI3k:VMZXJi)cf!e1~Ub s7 h3UAXPFoQ7!3BHMri.aB9<	5Lw\{O=r|B	{H1[{\D2K'|Ogv,rV4+wG-L5*e,S;2Vh:oKf$nI$n5gub~N%6}:k
);,,E~:T*G<:@N(mc)>yMr%sKXlog IhB]sCJ&.~{:YL#`z\:{\ 8Ny^jq[`G1P 4dX),U(*KUa]A$dx2Vx`7'*EdhE&SG*B(0R8?qa ZKo^F,`%|,dDF;`3=yGko5_g!MEp.j' mJ{&{@&Hjhr7*RHJJ4v+bh`>}_q,0X	]t_W{pU@zke25mJf]/4J}
<wj<MN,pj-3b`@ow;r/	dbUtzL7]LT^[z/=S17^R3YFmG&Ouq'64D2jB7',M)F?P+%#aA},9qsx&7nVrK&YaYtUYt+3g?THSt17P^wd@AP)HFIR/v0"Y)\}';+st|(f(spu4Uu3}X	R@S/aKj\x[qU@bQ@TB!5czB;+T}/t\.p0{l=3n3)?GD[PvHNgqm}6NFTT		37tjg{@(p$l rs%D	kK%mjw`9\+HWGW!coAO0	F382fQ?S?{#[|WWiv	iCOCdFp5evA+^5Hvr2BDC'_W3G`|G4q
:R3lu<6TjW=	>fwyi	-KXtcy)$y^"\};PSE+sD b^?P		\VwX lAg+]Se7.a~//} 8^-AZOvKjG^u>"kK{Ju^i[#3wiX{D2.<TO.'	*W0[y39s PG{Yx-Xs`cy6m&gH9%aG#SHv;.K]Z~|A%rr&v!WCzbe<OWE[?i&YfNcb
:OO{s#S4]ltAJ[.t`i{MCeXu!K}
Krx.%$BK 9}`jn[x'`]	crbL4oT1u|0w7F;Pu|4*~p>6O-h{
-_U_ZstQaVx_&G_	S;}V*G)yq_T<rJm.)t?f}S*v#}Ky|
{w7ba|6;";.HhgV,fTk5NP02guAu={4 rJcl`t*k~)J{j@Dhdi+
^hNK *|8b#LSX#$t-C;J,?YbhM_(XE1JL~\G4HuH$V;Py&5^HA;7EUvk^{0`5'I:C9$XFiK|F\)_L.?;,u{yms_HQWpVk>5<X*u)tM#N `4Y};/1]t_U5L%U)ZqSN	3^{ws;fMs[n3}YMO`'aQ?j~|%B^/rXc/z0O#jT&A:Z:k5v0U~T{R#HNs{8<eGJWd-g}i%i&Y]OfnU>Z\^C8G(37JWKJ1w/
v"9iG^rw5^h-ZRjNz`^6VG?KLwAn s0GAWU0xLP*KqhRRK(*"SD'ZP`QEtM69;&E^J{{hHUxM&)~FRd(?>y)jUXlFx_y=)9bJ/S1WU>hE[n~ZAK48klbdv6~{%r25Up{OeR	D9c7hI>
sH6O(C>RQC",lKEIma~j'%^s6Dj[)W.|'AxkiQ6Q^>pob3<=.*nXfTj/C}dS@}c|9YJ}J<?9p$s,4u'JR~Ba|0/K4>Ow|TI[LzAlI p:{,:p,G^_/_egsPMgMit_Gn$?>5>[YJMR21q>n+x/?b}6 21@MP`+=%xuC#lq=we:J3VSUHPkPmJ[\JRIJ~|u9qMeoNq$G{%zdGVu\4^$b]kj_zqv)[MsEtpkPK    1YIH}  6     RasExamples.py]o6=@~a-$8 I$m3DUl}__r3)Q0l-Y#n^N?[5).%+>G[zyukXw9vy,T%5?Ks)W_.(?L&%+_<+6`I<tPB-pv\$KZVIQMd 9 }Q V%E.6D0
hT% Q"-0,X]-AvrC6GR:]GhT='ec5!q?fueVaK*]69 *QmRkLb{PEQZcCFM*4@*iZC^dI*:tOq@.?I^Iz)Hh9nDFifc$%II(5q$8D5dB&_qX&mS9(hv6uCY|OLdV=;-m*	+!3tBu4H0ZP=(A'">4Gd^-3LPDv jt ~f`1b1~Yp	@;b<eoHyvXI^cJT0TYC!Y~i%%z!NrJBO[WX!A5"_IOG1	@Z$)ix 
It
bKsd@urO "mI/t='9f# Oo 5PBW4BY{V^PK@0):0 k^)I>M`Z[Afzvr
veY+.,K=B*Bbxi:tp5NJMeOV_q
N'>ZnhJ9XX+<L^ D!7\R>p~IZ%uHB0( !]iZ5+C(G_#Ix&XHY0ST:#DXL#A9kxen*Sm.2;~5`yzU<)@t	1D
:P\w$qD&s2:U/sUto+<0a I"C3p3@!s!H>d//}^^i?K(+*[~5udp3{MKbv'?zl5
[9y96.irUI[	vg\CmzVl<Wr	vgR\6N/NJ\{,9DSN yR0&G/Hz*j*=!t&JGX[ey%PhRu1LHX?)D(%Nuh*!`;	v1<dZ tT qh}Jbz 9sL	f1 UNK]FF2t=T%jh	QFm=G[!!Fl]ohwsN/\r8O6:@4.*BGBu]eEvMLG+W7d,LH=g		mT[	AMAnv(cUK(0h99h6=#9-mXRtCWe
*Sq@4\g[3YGr*4	\qH%g#Pq8\U6{_cz>=Wt]wl&awoxBvGfi#H8kG]e
^owY7}"% ?@qPyQ4;,Mjya-thfp`-+=x;oL3|mym_%c=+5)GG)Tpa/Mf_vIDZM!s0~Y*$;N657(rI5	<I^C%4Ay|L&[YL%O2c@ow";	4Xp	}h?%EKF	`l,V}`*DU><KuC:r"i{4k:t4F"6YMN)6NG}IN4HA_$fKU)L "JL	yp}2Qz-J.(P@]]`9fi2a	taJ;qHo0@#J]M)p3)(5|m<DT	q
ajnk,/ lnwA_h}8WF]}]Z9.",=Pb{fo],nXsr0W6
`ij&* S,$}ixZ0'"A6_yZ$MX|=K0 B(.]B*iJzH+wRh=k%(V|YkQb*gPm-$u[z@m?`!G2I+Abzh$?nm
GuM$yERA1cNd]rM9}|i["+4>[77t#3. 8a[KqATDXZ5hh'++!kRF9E8A]oo]yXnm(hA7?FoOeKl'=O|5BP:nR{masO5Yq|]_QmmA bPtl7m#MDrV7 w{["MfnkVI*(xMfq[2Q0.URRP9koq?'DI!#e/3C'lS4_juW7H\9l	gIn|wI*>	L<_  Q~`B)Cy#X(/*VsUd8%0sFOnsIhe!#A

npuvwED@MO|	y?3v|>~~2$-hR.H	T:Tab1v+o4Ipr|gL~.Kz:5@[imz`{-On,#JDJ5wG'*?~8'.m!8dr#.X$`w*HPK    1Ysx    	   RasGeo.pyVKo68[[GihG7"$C`DLdR lE{gDId95Royh4>g\3+4(+&TGxj@"Rn@Hxy~xwvVO<&FhU* ngyb7S"Q`y1s2Y(6OSuo>QGr5 W>b.m-{wcaV*v[1O3 LE~Nie9m.|p$zTwdp[sim%(:/A_4&H4m`OMOb-UnsJ \Ftn)(6Q'RY`R%Uc8$j,98v7V/os|prJe!adZ>ao(N1_+,fuSh	H%2O]I}msyG13YSQ2&*W(l#r.h}%hV{k#m|<K:O"2BShxP0oGI$'e<rXiBZsSj,{8k)`WR?adE1UKdb.T!%$lp!QX{ "E/Y.IHPkd(dr-dG*J)ai9ls)V<z^q3VE|NB1-1UI"^8rRC7y@}<vD%idH8=X:a"I2y5n~Kg K|eZlUL)b`1MVq	p02_j5]4I3	%e8/Vn{sm-/RX"F!NU(UeUMo8Z{-x@xRUd4:=N\fA!3I]n~xDny.4.FK{\E<~Ionfka]"P{<pKTPK    |2Yk2y  ?  
   RasPlan.py=o0PtQI^;:?^ZZHZ*k?r>9_+"!9$gjZjiA>',l:gGl:J'l*k!|<-bi}9FGa}5EWS$&.S $d0^TO"N QEHtV;~f10)&aX}S?b n!"+6rS'dy#Yq.[$?KNtX$uoTl'Ty":++/B=8$v71MBP`0c0&:S6LH,Y<Y9FG	1nS:2Gz6-%ugk?GK2M8B	<cmWnCTfH4N3>XR#43dNQW6XN*eI-)<JTw_+mJ9M=6N1Hn-cOF,\YYYfs"B2Newz!~/~S?	5A0hhK^^T}q.8,%R|hbR1p{T$,sCUv(;/k30,f  GZr"&9*F:ND;oU 10a:X28$k3bfNY-yO:PS_9CoZ`>X};e>Q>blI`j':Kx
;'{[=lG'| [x5@1pJe[u`xA_qZ/ySN""` !qA7^x68!-#LZ0"R1,%c1Vi R,YNX\3r=6np87E6';uf,2JFIhpb;	_syK\`6%5<}k@
gmr5q:2Q/kGWYoi'g(# 60&"67a=fg~\s)9zQ]*Pav"<:,FF!Y=`1s5$P	e"kl>I1(I%Gg*U

}\F<'h\
EzPJtkHY1p[=pOd/- 0V(0| u8:=}[1G :&*D0k{QBQFuapO h,7x@S0W&&[9B]G(4r[OHK)NTp=r;Bs{d?~Rq5h9'}:Au_!.Qxw~ !c;xu__{{c?.y%Z}pN}}u<~NvN["LnW{p/~^[89S/_nN&`6".,.vumg0:Ox6Vt.6  oP1#z k71oWr59kW/l2Zg3.eCU;J1NoRVxEEy~~&qZ*3bl@isLo{mX64l J(P3D!*5=ZAH~|2Y<chT|h$'?J|L:vv00K= wmAjL(/4Ood<esM'(Q+Tx uI^EZx~n@~<x]2w3 o:E1W}^8Oe|^"/^7PC7Mhlsr{vjuqY {c[=$[-M|10mqD5{1GKaCuOszgrF03V&guz}>nFWSF$A-?k	.e\fyQ^6qu
?
\	gy}Ql 4J=z:U|ZXYJ<"f@iKtVHGbHdh!'t <+s4)+	z"nqSl\i[%oQZs,	: e6KlYXgAWhoL$,~%.fxrSqQNg"<n=~X',f<-mdZ9kk"<HLYVrl[7Y(F$c9\IyZK*+Xc`zAM,u\:}c?_fznB7oE)	8X]+)$X<p?l+mlk]17Hlh--;@MA2)~'+*Pb{P1^&iQVO\%%QIq%XN|7`(=VVMv JlVKtx(Vl=
T-> 'sU53.9MFj	${RrX<EZ8TC.!Jd<w7rj0_f!H\GzXD)W~(9X<rO:wE:do4F	lRcr8ssiq4|ztTx+"R*hIs8GG4s 5.ac6VXl6h|
[Sv<% JLK[6q5~CH(R>s4	!<d}\L\iNvcGMM3)ggkIr,{WDKKko%KvvCz*uIjDGPYP2Nzh(I
defxZE+F#V)|V/AK
(_dXoH\RZ(hBvr^]M
L}7$rqPn9`-GbTqG+Z38 eu`_P|*n?ms4n?	T]t]4
om};*JX,^h]s%_8p{93sdRFU>S-.15r6y13'142U
h8ieY! Ov"Lr%4R+CGJ1:YsT4M4j8(_4.jkDmRM1=D`IjUBq-+BhC3 ?:7}kk|we+#Ycs!o)s#wlaB5 |]Xk|L~`tBCi2M[FljoP5T+CgURBx*#TFk_L&GK+Q]xU"v:uT?MWFuYu>51p,:GvVb>ZoeE}O=/pY OpC`V@ezs_ `aKMf81D~']m$F\&%k I'AhyBM3<%)Er[wTTXgbH=3h}DNLrbma}xt$W.8#cRi>)2	"wz/)aey0*&$&:$n6V7<ouG;.4=WZfDEuV|<-2(W |4ka4AtE]6EIfuz^ Nb1u0F}tWuMS2\H+adnX8kiO 6M\Q~PG*0QAu5bO >^qV{$^kVn;;)^|227Hu;\@3}p%X}q-]4QZq y_YE/'++z$LlN?XM.GixEd|\qa%%\%
5E|~Blwp@$]i@pT
/K8.jw9~{ Eb+6EO'EHyGac~E4IppNB119xa}3.XjZX22k;3gt	*yb5$MfhvY%Bg@J|IQMf~`4]g2B8|8'}9ISg;f07rH|atK+l8bIXnZ |>Xl*tr:8W%;=r/"VH_Z#1+A#N=Z}NjofL*;LEtF)qqM|:mGBkLGQIf jdy
/ztf/o$'2\9qH'6bkFd9\zaj3GAD$vPCmMC6^mF`HMDuX(q"L|)uH@	(YzOIO&Li'G/4%S$Rh$H<#po#5Bk.VIK"tvpN*DpbB)>VnYSCcZ!{lH`f7n2tG|`:IX-Scq4-!,U30X-+/iu!V+6*;Z:Drt RBWz+ZoSpV	mmIZ4qRibM1-k1SWHnAWp:4sVhd0/Z	EmLdt,Z^0W(hY(L	q0Q*e(1 "{	?BEF1A)_*m5meeqQf0/`z|L{bE=v:.8k]u\Q.]:+x]%=oEo/ax,N^yb]};u\i]tw@?t5NKgmllw9Fbe)D4.,Lg&~2:]
Qq4^\#U	<rIw@ssIkI$
:k]ZWvZ"F5f.2L"H=`{YKWdN4ekK5L_mH:tZWvK[k]w:KMi$w@iSj p[
)
OX-T_Wck]uO-+/ips!XWcX5J`]PZW(lPX2h\pqmAl^FfhI^73,uA>/!o}ysIpp8}FlLx*e,kvU/1;{2GDN;hc[GrY	T@O,01aNMvmm[2cl[L&5KU\?DT%>8by?%N-2E(pcj
7\t@}D 9VhDM(2GzQF9Y6^H:
Gg=hHM :K}v.OS2ex7ZTW!g<F9/}8W.R<
^!=uMc[:bO$qs GA~c4;:O?(=+ $lZ<wb	Jh&UI44pnx7,(:o?y~cwDn/9kH(A	:3(|kW!`<5;V}	EWd~uMq=y6(PK    1Ye  <  	   RasPrj.pyksgv:)rhF(2+JN;u<o<xC/}ESIA bht%C{*)ZGU&7I
!"E!b2A-"DO\8e3!rbnG3x4|h WPTIDR |ZTr%e"3d$V^N^Ln**5qY%X Y:YG
H:]&AT,8$ LLfOk+WQDJ,$p+Y*&(ePG?).:eXfq*Jf/qs04@Bh4z521#EYIV9^j&fB^hq|H>_,
\!Q]:Aob>'J>\yGTrg8cFHks#'qj8t2@+{%Xaf/g!dQA8<tH]$K9!Yv2Kec`)4e.^.If&:.]rh0z%u'VjF/e	>UFIHs\=j&R,"r\ZBXpS^b4E|]$[z9"9<Y>=X|PuMza q>.{&8[Ps;jX_kSNfofy-Wy\hTd#><w&@|%42O}2;{x?Dc!oa7;KFGN_wK~JP&I:ok%9A&BM`"W\fXy!+sL@G+	Qn3Gj6ngnV6Ka(4S0aH4mLh.!k/H0W@	"03
De/{3fReg01a
2V[xR"ex)8	fiX/f? W/Or(vZ5N
ypH{Qt]
I1f]\0Bz~)<
~qd{(qTFGH;x1&59T	rMi]H9@xy	.Pq=i$MHq/cY4^6ACx1$(sQ}?cG3^3<<*;y~wp~2g/ 9gb_uSiQzg.HZW`QB<LbHk @,%iNm'1fs;y1}i-$[ddd,FLn<@{ehc`L|d3(Sj6KTA$kb(XQx8,O;PI{bfw+pJe"C:=CT)G*E>+Saw4+7r_UY5D%,&1oOw	KK9!qi|g$NHL&]e ?Zt
 $X,`yw`du*&%kqb K(Gk#Fch2Z8'3=(!;;}.z0CXJFBF<Eupf\&{`OvamAx
+4&DYhG*B\+H]/Sp#&	N@X,)!\8|;@LkYk[7,X;}BzY<.1[:PukB	9^'Oc]uE]+j
S9oU'S<bV1l5 \MAm}	)sA>J1V!2?3nS(;?^?3MxST&D?3c?VDv?!Qa+yK;;v~#P*\zP]]M%_=26fj{(E; \D;zR5>_3X5z`!XW&p7wCc,Gcyj1m-BZ}+./{`0Zm%~~R=|
$';jd&+UT	@5"a$hSvCFByOs=v80!
3JvsV`wZ@b=V$[jM<yrml{/Z)E[5u]`otHtf#MJ@T^oOfgbv!fg9PW?NOflS>o>b7oX;rQ6]u:s\sbyu"BPkSc$4C2lk8qM,\P-:Q8
5Iy:uPf2EWNjCC5f}8's
nG_a?15ZP]OuI5Zm`RKAcwN]n0NkZ9:8TO1TjtM^f!njX
T ~Tn:Lxky,nv\h_}fX=*E@?r0NS0O)ph];x_}Ry$7D^gTD7lJ{,Sj^PO
aOwnlbK=YB=?`B6!
Ze\WJX@&MdzQaVe.V:1+\x]^91:.<$>s/$vv "?7BztcrDebI=I]-"BV%K&PInl0)KD~61fn8nP(*O+7,WE MVI>|Z;i9G3mQn5#Ta%B+o<X<mOLcDML\-"ocWv~g;)}czuS>T3GWF[	9BAqW;/5}[tVoLmo5<mUh/g}uw|nM%#ows`nhxms~ztT5Q]U"l+ P5[F'^_M[gxQ#g&3L@=!t}H;9TG/shfL{e)0
?KfPkx1u![{tH(x)#3g
m]w2w`72_tM!z8ZbdHiA~,3I)wQeRb u4PK    |2Y.@N       RasUnsteady.pyVo6~7=D4u+ m#b)T];J%Y)l|EwErF#BKQPz,T>@mgMa
+dUkI |:1.g\.I},AaNN#By*:'	f[#Hw@sY5%aif^\Vp)<
FAlY!8,L0r\f ~?z!t1!PQ!<X{(lmUd3N7S-NxgO~%cd31jH#qB1;I(K,Zvat.
Dx\drj/.f.UE$zWVDUx*(KytB	3^K[Lk+-e<P*cqoDo~3:I.q&oeu!Qm<h"=0 lK:q=TIc'BiVa<	E@MgP9#ot"x6~}\s0[U<J\*\E39EjonH7nT~m6$#sNaU
J;G$\=JZNNdHkxCsIIrg3"s3'nDi#L<<P5Z=i!i	w|mtXQ0f&)mGn!h?U41x48/SyTY|byfz9/g7"M6ci^m+Xuka3,	)4pWg6UXivlS.lPK    |2YM
  /     RasUtils.pyZo,wbv{Qv}
D$
$U3CJ"e)v{!(9<LNO>,u2,5KbF0,
^&B<[*60[}S1Yy>'vG&R}kTT''kWOO\aJg%2ZdF,+V R=HVJW9RH&=g<IP\`TU!LP"RRXm]Eil7gv|46]>rM{Y{(WcdJ&Xei&x]rAiE(mfe`o~)Hp6X`I@>*Q&+&q,9Y[9llm<Wo>0XZ]Fs|M~%LJk_Qwrxuc2Eq(%TJ^6B68_FnxtA485!k(;{X. L?"<T2xHB#d:377nFmD;/BXUxL1@ %J,{(QMp9Q"vJNuC $CC,E   &J;a/y
m``rd7(p[YE0i1o(AtU?:LlW18fC= 28 L^YyV<kFLD]EK]+a)ZLe@Db	4hRG; D~XN $o5dm":GXL
!BIqq+Q}a EBxx,oH4+b^,7qg+QQ>/9(</?;^ .BB}Z4h((:)oH"Lm{~fuB,pBt+klsQF-!S&4X6]D*s	\
wVDBvdtI@\CXhPuw;`I[f*Gm7.}pk3Y*$4@ H
<jahED^cxC\YS1\Rc< J1*'(dM{ i.9@/N?kJ;pBQRgM5$_,
{Lz<r^U!#e],ZHNP/v-LWdM,$[udv,kUEgY?0Cic%kg,GCY] e.$#L#_P\<0>xk<0=th(L"bD3qHQ[:d7awZ>OENkRR5kp;1v>`t$$'S-~ovq5$yp^tRBOlba{u2TsnomE7gKxGU1}z'G$ &NVLUDMa {iu-wwX6wYQmQp,"wv0k;-VLVvpe`vLo9Tu$"8htDWs.v:OxTO	Y}20+fE@32kQ/@.* .E_chLT>ua+.|PEdil_^gv3*7r.[W0,d[k%zsv UD4qEp%xD9%pqa(pU[Q-?	 	FHR'tn]fS	w >SE\ 
E+Hm%Sauf%sxb?	YLl6)~cO6'7eSp'	?-1Fqm7;@I.{#{i)t95c>	2gfE==lom4uRCT0POw,}o'Zo [r9>	]Smp!nOFx@fd l:8U
f;XR_\n`fij)vEtGv=fCH$sjpBFQWf;lNS1%J(q<;TFRQhV8}Zw[o -	;^ #nXn}szNnG@_kkYkoQNVVhXG8%I;,2W8S]S=T]S=T}Gm~M^2%~l;u ]'${aOT#50CeBR22j6C`~jr3`lAz~~1/Fm>/8
PK     |2YlG                    __init__.pyPK     2Y?_                  _version.pyPK     D2Y|  V  
              RasCmdr.pyPK     1YIH}  6                RasExamples.pyPK     1Ysx    	            |&  RasGeo.pyPK     |2Yk2y  ?  
            +  RasPlan.pyPK     1Ye  <  	            EG  RasPrj.pyPK     |2Y.@N                W  RasUnsteady.pyPK     |2YM
  /              [  RasUtils.pyPK    	 	   2f    
==================================================

File: c:\GH\ras-commander\ras_commander\_version.py
==================================================
# file generated by setuptools_scm
# don't change, don't track in version control
TYPE_CHECKING = False
if TYPE_CHECKING:
    from typing import Tuple, Union
    VERSION_TUPLE = Tuple[Union[int, str], ...]
else:
    VERSION_TUPLE = object

version: str
__version__: str
__version_tuple__: VERSION_TUPLE
version_tuple: VERSION_TUPLE

__version__ = version = '0.29.dev1+g22e75d4.d20240919'
__version_tuple__ = version_tuple = (0, 29, 'dev1', 'g22e75d4.d20240919')

==================================================

File: c:\GH\ras-commander\ras_commander\__init__.py
==================================================
from importlib.metadata import version, PackageNotFoundError

try:
    __version__ = version("ras-commander")
except PackageNotFoundError:
    # package is not installed
    __version__ = "unknown"

# Import all necessary functions and classes directly
from .RasPrj import ras, init_ras_project, get_ras_exe
from .RasPrj import RasPrj
from .RasPlan import RasPlan
from .RasGeo import RasGeo
from .RasUnsteady import RasUnsteady
from .RasCmdr import RasCmdr
from .RasUtils import RasUtils
from .RasExamples import RasExamples

# Import all attributes from these modules
from .RasPrj import *
from .RasPlan import *
from .RasGeo import *
from .RasUnsteady import *
from .RasCmdr import *
from .RasUtils import *
from .RasExamples import *

# Define __all__ to specify what should be imported when using "from ras_commander import *"
__all__ = [
    "ras",
    "init_ras_project",
    "get_ras_exe",
    "RasPrj",
    "RasPlan",
    "RasGeo",
    "RasUnsteady",
    "RasCmdr",
    "RasUtils",
    "RasExamples"
]

==================================================

