"""
report_generator.py

Generates markdown reports from conversation analysis results.
"""

from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from pathlib import Path

try:
    from .conversation_parser import ConversationHistory, HistoryEntry
    from .pattern_analyzer import PatternAnalyzer, SlashCommandCandidate, ProjectActivity
    from .insight_extractor import InsightExtractor
except ImportError:
    from conversation_parser import ConversationHistory, HistoryEntry
    from pattern_analyzer import PatternAnalyzer, SlashCommandCandidate, ProjectActivity
    from insight_extractor import InsightExtractor


class ReportGenerator:
    """
    Generates comprehensive markdown reports from conversation insights.

    Report types:
    - Quick summary (500 words)
    - Full analysis report
    - Deep research report
    """

    def __init__(
        self,
        history: Optional[ConversationHistory] = None,
        output_dir: Optional[Path] = None
    ):
        """
        Initialize ReportGenerator.

        Args:
            history: ConversationHistory instance
            output_dir: Directory for report output (defaults to agent_tasks/)
        """
        self.history = history or ConversationHistory()
        self.pattern_analyzer = PatternAnalyzer(self.history)
        self.insight_extractor = InsightExtractor(self.history)
        self.output_dir = output_dir or Path("agent_tasks")

    def generate_quick_report(
        self,
        days: int = 7,
        project_filter: Optional[str] = None
    ) -> str:
        """
        Generate a quick summary report (~500 words).

        Args:
            days: Number of days to analyze
            project_filter: Optional project filter

        Returns:
            Markdown report string
        """
        now = datetime.now()
        date_str = now.strftime("%B %d, %Y")

        # Get prompts and analyze patterns
        prompts = self.history.get_all_prompts(days=days, project_filter=project_filter)
        candidates = self.pattern_analyzer.find_slash_command_candidates(prompts)
        activity = self.pattern_analyzer.analyze_project_activity(prompts)

        # Calculate time range
        if prompts:
            start_date = min(p.timestamp for p in prompts).strftime("%b %d")
            end_date = max(p.timestamp for p in prompts).strftime("%b %d, %Y")
            time_range = f"{start_date} - {end_date}"
        else:
            time_range = "No data"

        # Build report
        lines = [
            f"# Quick Insights - {date_str}",
            f"",
            f"**Period**: Last {days} days ({time_range})",
            f"**Activity**: {len(prompts)} prompts across {len(activity)} projects",
            f"",
        ]

        # Top projects
        if activity:
            lines.append("**Top Projects**:")
            for proj in activity[:3]:
                lines.append(f"- {proj.project_name} ({proj.prompt_count} prompts)")
            lines.append("")

        # Slash command candidates
        lines.append("## Potential Slash Commands")
        lines.append("")
        if candidates:
            for candidate in candidates[:5]:
                lines.append(f"- **`{candidate.command_name}`** - {candidate.frequency} uses ({candidate.priority} priority)")
                lines.append(f"  - {candidate.suggested_implementation}")
        else:
            lines.append("No strong candidates found in this period.")
        lines.append("")

        # Action verbs
        verbs = self.pattern_analyzer.analyze_action_verbs(prompts)
        if verbs:
            top_verbs = list(verbs.items())[:5]
            lines.append("## Common Actions")
            lines.append("")
            for verb, count in top_verbs:
                lines.append(f"- {verb}: {count} uses")
            lines.append("")

        # Footer
        lines.extend([
            "---",
            f"*Generated by Conversation Insights Agent - {now.strftime('%Y-%m-%d %H:%M')}*",
            "",
            "Run `/insights-full` for detailed analysis."
        ])

        return "\n".join(lines)

    def generate_full_report(
        self,
        days: int = 30,
        project_name: Optional[str] = None,
        save_to_file: bool = True
    ) -> str:
        """
        Generate a comprehensive analysis report.

        Args:
            days: Number of days to analyze
            project_name: Specific project to analyze (None = all)
            save_to_file: Whether to save to file

        Returns:
            Markdown report string
        """
        now = datetime.now()
        date_str = now.strftime("%Y-%m-%d")

        # Gather all data
        prompts = self.history.get_all_prompts(
            days=days,
            project_filter=project_name
        )

        pattern_analysis = self.pattern_analyzer.analyze_patterns(
            days=days,
            project_filter=project_name
        )

        # If project specified, extract insights from that project
        insights = {"blockers": [], "best_practices": [], "design_patterns": [], "anti_patterns": []}
        if project_name:
            # Find encoded project name
            projects = self.history.get_projects()
            encoded = None
            for p in projects:
                if project_name.lower() in p.lower():
                    encoded = p
                    break

            if encoded:
                insights = self.insight_extractor.extract_all_insights(
                    encoded, days=days, max_sessions=50
                )

        # Build comprehensive report
        report = self._build_full_report(
            prompts=prompts,
            pattern_analysis=pattern_analysis,
            insights=insights,
            days=days,
            project_name=project_name
        )

        # Save to file if requested
        if save_to_file:
            filename = f"conversation_insights_report_{date_str}.md"
            output_path = self.output_dir / filename
            output_path.parent.mkdir(parents=True, exist_ok=True)
            output_path.write_text(report, encoding="utf-8")

        return report

    def _build_full_report(
        self,
        prompts: List[HistoryEntry],
        pattern_analysis: Dict,
        insights: Dict,
        days: int,
        project_name: Optional[str]
    ) -> str:
        """Build the full markdown report."""
        now = datetime.now()

        lines = [
            "# Conversation Insights Report",
            "",
            f"**Generated**: {now.strftime('%Y-%m-%d %H:%M')}",
            f"**Analysis Period**: Last {days} days",
            f"**Project Focus**: {project_name or 'All projects'}",
            f"**Prompts Analyzed**: {len(prompts)}",
            "",
            "---",
            "",
            "## Executive Summary",
            "",
        ]

        # Executive summary
        summary_points = []
        candidates = pattern_analysis.get("slash_command_candidates", [])
        if candidates:
            top_cmd = candidates[0]
            summary_points.append(
                f"Found **{len(candidates)}** potential slash commands. "
                f"Top candidate: `{top_cmd.command_name}` ({top_cmd.frequency} uses)"
            )

        blockers = insights.get("blockers", [])
        if blockers:
            summary_points.append(f"Identified **{len(blockers)}** recurring blockers")

        practices = insights.get("best_practices", [])
        if practices:
            summary_points.append(f"Extracted **{len(practices)}** best practices")

        if summary_points:
            for point in summary_points:
                lines.append(f"- {point}")
        else:
            lines.append("Analysis complete. See sections below for details.")
        lines.extend(["", "---", ""])

        # Slash Command Recommendations
        lines.extend([
            "## Slash Command Recommendations",
            "",
            "| Priority | Command | Frequency | Implementation |",
            "|----------|---------|-----------|----------------|",
        ])

        for candidate in candidates[:10]:
            lines.append(
                f"| {candidate.priority.capitalize()} | `{candidate.command_name}` | "
                f"{candidate.frequency} | {candidate.suggested_implementation[:50]}... |"
            )

        lines.append("")

        # Detailed recommendations for top 3
        lines.append("### Detailed Recommendations")
        lines.append("")

        for candidate in candidates[:3]:
            lines.extend([
                f"#### {candidate.command_name}",
                "",
                f"**Frequency**: {candidate.frequency} uses",
                f"**Priority**: {candidate.priority.capitalize()}",
                f"**Category**: {candidate.category}",
                "",
                "**Implementation**:",
                f"> {candidate.suggested_implementation}",
                "",
                "**Example Uses**:",
            ])
            for example in candidate.example_uses[:3]:
                lines.append(f"- `{example[:80]}...`")
            lines.extend(["", "---", ""])

        # Recurring Blockers
        if blockers:
            lines.extend([
                "## Recurring Blockers",
                "",
            ])

            for i, blocker in enumerate(blockers[:10], 1):
                lines.extend([
                    f"### {i}. {blocker.get('category', 'General').replace('_', ' ').title()} Issue",
                    "",
                    f"**Problem**: {blocker.get('problem', 'Unknown')[:200]}",
                    "",
                    f"**Solution**: {blocker.get('solution', 'Unknown')[:200]}",
                    "",
                    f"**Frequency**: Encountered {blocker.get('frequency', 1)} time(s)",
                    "",
                ])

        # Design Patterns
        patterns = insights.get("design_patterns", [])
        if patterns:
            lines.extend([
                "## Design Patterns Observed",
                "",
            ])

            for pattern in patterns[:10]:
                lines.extend([
                    f"### Pattern: {pattern.get('name', 'Unnamed')[:50]}",
                    "",
                    f"**Category**: {pattern.get('category', 'general')}",
                    f"**Description**: {pattern.get('description', '')[:200]}",
                    "",
                ])

        # Anti-Patterns
        anti_patterns = insights.get("anti_patterns", [])
        if anti_patterns:
            lines.extend([
                "## Anti-Patterns to Avoid",
                "",
            ])

            for pattern in anti_patterns[:10]:
                lines.extend([
                    f"### Anti-Pattern: {pattern.get('name', 'Unnamed')[:50]}",
                    "",
                    f"**Category**: {pattern.get('category', 'general')}",
                    f"**Description**: {pattern.get('description', '')[:200]}",
                    "",
                    f"**Alternative**: {pattern.get('alternative', 'See documentation')}",
                    "",
                ])

        # Best Practices
        if practices:
            lines.extend([
                "## Best Practices Extracted",
                "",
            ])

            for i, practice in enumerate(practices[:10], 1):
                lines.extend([
                    f"{i}. **{practice.get('category', 'General').replace('_', ' ').title()}**",
                    f"   - {practice.get('practice', '')[:200]}",
                    "",
                ])

        # Project Activity
        activity = pattern_analysis.get("project_activity", [])
        if activity:
            lines.extend([
                "## Project Activity Summary",
                "",
                "| Project | Prompts | Last Active | Top Topics |",
                "|---------|---------|-------------|------------|",
            ])

            for proj in activity[:10]:
                topics = ", ".join(proj.top_topics[:2]) if proj.top_topics else "-"
                lines.append(
                    f"| {proj.project_name[:30]} | {proj.prompt_count} | "
                    f"{proj.last_activity} | {topics[:30]} |"
                )

            lines.append("")

        # Word Frequency
        word_freq = pattern_analysis.get("word_frequency", [])
        if word_freq:
            lines.extend([
                "## Frequently Used Terms",
                "",
            ])

            top_words = word_freq[:20]
            word_chunks = [top_words[i:i+4] for i in range(0, len(top_words), 4)]
            for chunk in word_chunks:
                terms = ", ".join(f"{w[0]} ({w[1]})" for w in chunk)
                lines.append(f"- {terms}")
            lines.append("")

        # Footer
        lines.extend([
            "---",
            "",
            "## Appendix: Analysis Metadata",
            "",
            f"- **Total prompts analyzed**: {len(prompts)}",
            f"- **Time range**: {pattern_analysis.get('time_range', {}).get('start', '?')} to {pattern_analysis.get('time_range', {}).get('end', '?')}",
            f"- **Sessions analyzed for insights**: {insights.get('sessions_analyzed', 0)}",
            f"- **Report generated**: {now.strftime('%Y-%m-%d %H:%M:%S')}",
            "",
            "---",
            "",
            "*Generated by Conversation Insights Agent v1.0*"
        ])

        return "\n".join(lines)

    def generate_session_summaries(
        self,
        project_name: str,
        days: int = 7,
        max_sessions: int = 10
    ) -> str:
        """
        Generate summaries for recent sessions.

        Args:
            project_name: Encoded project name
            days: Number of days to look back
            max_sessions: Maximum sessions to summarize

        Returns:
            Markdown with session summaries
        """
        sessions = self.history.get_project_sessions(
            project_name,
            include_agents=False,
            days=days
        )[:max_sessions]

        lines = [
            f"# Recent Sessions - {project_name}",
            f"",
            f"Last {days} days ({len(sessions)} sessions)",
            "",
        ]

        for session in sessions:
            timestamp = session.first_timestamp.strftime("%Y-%m-%d %H:%M") if session.first_timestamp else "?"
            lines.extend([
                f"## {timestamp} - {session.session_id[:8]}",
                f"",
                f"**Messages**: {session.message_count} ({session.user_message_count} user, {session.assistant_message_count} assistant)",
                f"**Size**: {session.file_size_mb:.1f} MB",
                f"**Branch**: {session.git_branch or 'unknown'}",
                "",
                f"**Started with**: {session.first_prompt or 'Unknown'}",
                "",
                f"**Summary**: {self.insight_extractor.get_conversation_summary(session.file_path)}",
                "",
                "---",
                "",
            ])

        return "\n".join(lines)

    def generate_slash_command_file(
        self,
        candidate: SlashCommandCandidate,
        output_dir: Optional[Path] = None
    ) -> str:
        """
        Generate a slash command markdown file.

        Args:
            candidate: The slash command candidate
            output_dir: Output directory (defaults to ~/.claude/commands/)

        Returns:
            Path to created file
        """
        output_dir = output_dir or Path.home() / ".claude" / "commands"
        output_dir.mkdir(parents=True, exist_ok=True)

        # Generate command filename
        cmd_name = candidate.command_name.lstrip("/").replace("-", "_")
        filename = f"{cmd_name}.md"

        # Generate content
        content = f"""# {candidate.command_name}

{candidate.suggested_implementation}

## Trigger Pattern

This command was identified from frequent use of:
{chr(10).join(f'- "{phrase}"' for phrase in candidate.trigger_phrases[:3])}

## Usage

Use this command when you want to: {candidate.suggested_implementation.lower()}

## Example Uses

{chr(10).join(f'- {ex[:100]}' for ex in candidate.example_uses[:5])}

---
*Generated by Conversation Insights Agent*
*Frequency: {candidate.frequency} uses | Priority: {candidate.priority}*
"""

        file_path = output_dir / filename
        file_path.write_text(content, encoding="utf-8")

        return str(file_path)


def quick_insights(days: int = 7) -> str:
    """Convenience function for quick insights."""
    generator = ReportGenerator()
    return generator.generate_quick_report(days=days)


def full_report(days: int = 30, project: Optional[str] = None) -> str:
    """Convenience function for full report."""
    generator = ReportGenerator()
    return generator.generate_full_report(days=days, project_name=project)
